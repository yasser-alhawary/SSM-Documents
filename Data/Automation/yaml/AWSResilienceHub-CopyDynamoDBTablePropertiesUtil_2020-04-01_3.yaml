description: "Restore To Point In Time SOP"
schemaVersion: "0.3"
assumeRole: "{{ AutomationAssumeRole }}"
parameters:
  DynamoDBTableSourceName:
    type: String
    description: (Required) The DynamoDB Table Source Name.
  DynamoDBTableTargetName:
    type: String
    description: (Required) The DynamoDB Table Target Name.
  DynamoDBSourceTableAlarmNames:
    type: StringList
    description: (Optional) The DynamoDB Source Table Name Alarm Names.
    default: []
  AutomationAssumeRole:
    type: String
    description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.
mainSteps:
  - name: CopyContinuousBackups
    action: aws:executeScript
    outputs:
      - Name: CopiedContinuousBackupsStatus
        Selector: $.Payload
        Type: String
    inputs:
      Runtime: python3.8
      Handler: copy_continuous_backups_properties
      InputPayload:
        SourceTableName: "{{ DynamoDBTableSourceName }}"
        TargetTableName: "{{ DynamoDBTableTargetName }}"
      Script: |-
        import logging
        import random
        import time
        from typing import Any, Callable, Iterator, List
        
        import boto3
        from botocore.config import Config
        
        boto3_config = Config(retries={'max_attempts': 20, 'mode': 'standard'})
        logger = logging.getLogger()
        logger.setLevel(logging.INFO)
        
        ENABLED_INSIGHTS_STATUSES = ['ENABLING', 'ENABLED']
        GLOBAL_TABLE_ACTIVE_STATUSES = ['ACTIVE']
        
        


        def _execute_boto3_dynamodb(delegate: Callable[[Any], dict]) -> dict:
            """
            Executes the given delegate with dynamodb client parameter
            :param delegate: The delegate to execute (with boto3 function)
            :return: The output of the given function
            """
            dynamo_db_client = boto3.client('dynamodb', config=boto3_config)
            description = delegate(dynamo_db_client)
            if not description['ResponseMetadata']['HTTPStatusCode'] == 200:
                logging.error(description)
                raise ValueError('Failed to execute request')
            return description
        
        

        def _describe_continuous_backups(table_name: str):
            """
            Describes continuous backups settings for the given table
            :param table_name: The table name
            """
            return _execute_boto3_dynamodb(
                delegate=lambda x: x.describe_continuous_backups(TableName=table_name))
        
        

        def _enable_continuous_backups(table_name: str):
            """
            Enables continuous backups for the given table
            :param table_name: The table name
            """
            return _execute_boto3_dynamodb(
                delegate=lambda x: x.update_continuous_backups(TableName=table_name,
                                                               PointInTimeRecoverySpecification={
                                                                   'PointInTimeRecoveryEnabled': True
                                                               }))
        
        

        def copy_continuous_backups_properties(events: dict, context: dict) -> List:
            """
            Copies continuous backups properties
            :param events: The dictionary that supposed to have the following keys:
            * `SourceTableName` - The source table name
            * `TargetTableName` - The target table name
            :return: The status of continuous backup
            """
            if 'SourceTableName' not in events:
                raise KeyError('Requires SourceTableName')
            if 'TargetTableName' not in events:
                raise KeyError('Requires TargetTableName')
        
            source_table_name: str = events['SourceTableName']
            target_table_name: str = events['TargetTableName']
            continuous_backups_settings = _describe_continuous_backups(table_name=source_table_name)
            continuous_backups_status = continuous_backups_settings \
                .get('ContinuousBackupsDescription', {}) \
                .get('PointInTimeRecoveryDescription', {}) \
                .get('PointInTimeRecoveryStatus', '')
        
            if continuous_backups_status in ['ENABLED', 'ENABLING']:
                _enable_continuous_backups(table_name=target_table_name)
        
            return continuous_backups_status
        
        

  - name: CopyDynamoDBTableStreamSettings
    action: aws:executeScript
    outputs:
      - Name: CopiedStreamSettings
        Selector: $.Payload
        Type: StringMap
    inputs:
      Runtime: python3.8
      Handler: copy_table_stream_settings
      InputPayload:
        SourceTableName: "{{ DynamoDBTableSourceName }}"
        TargetTableName: "{{ DynamoDBTableTargetName }}"
      Script: |-
        import logging
        import random
        import time
        from typing import Any, Callable, Iterator, List
        
        import boto3
        from botocore.config import Config
        
        boto3_config = Config(retries={'max_attempts': 20, 'mode': 'standard'})
        logger = logging.getLogger()
        logger.setLevel(logging.INFO)
        
        ENABLED_INSIGHTS_STATUSES = ['ENABLING', 'ENABLED']
        GLOBAL_TABLE_ACTIVE_STATUSES = ['ACTIVE']
        
        


        def _execute_boto3_dynamodb(delegate: Callable[[Any], dict]) -> dict:
            """
            Executes the given delegate with dynamodb client parameter
            :param delegate: The delegate to execute (with boto3 function)
            :return: The output of the given function
            """
            dynamo_db_client = boto3.client('dynamodb', config=boto3_config)
            description = delegate(dynamo_db_client)
            if not description['ResponseMetadata']['HTTPStatusCode'] == 200:
                logging.error(description)
                raise ValueError('Failed to execute request')
            return description
        
        

        def _update_table(table_name: str, **kwargs) -> dict:
            """
            Describes the given dynamodb table
            :param table_name: The table name
            :param kwargs: The arguments of `update_table` boto3 call
            :return: The dictionary of table description properties
            """
            return _execute_boto3_dynamodb(
                delegate=lambda x: x.update_table(TableName=table_name, **kwargs))
        
        

        def _describe_table(table_name: str) -> dict:
            """
            Describes the given dynamodb table
            :param table_name: The table name
            :return: The dictionary of table description properties
            """
            return _execute_boto3_dynamodb(
                delegate=lambda x: x.describe_table(TableName=table_name))
        
        

        def copy_table_stream_settings(events: dict, context: dict):
            """
            if `StreamEnabled` is True, enabled streaming for the given table according to the given `StreamViewType`
            :param events: The dictionary that supposed to have the following keys:
            * `SourceTableName` - The source table name
            * `TargetTableName` - The target table name
            :return: The dictionary that contains 'StreamViewType' and `StreamEnabled` values of the target table
            """
            if 'SourceTableName' not in events:
                raise KeyError('Requires SourceTableName')
            if 'TargetTableName' not in events:
                raise KeyError('Requires TargetTableName')
        
            source_table_name = events['SourceTableName']
            description = _describe_table(table_name=source_table_name)['Table']
            stream_enabled = description \
                .get('StreamSpecification', {}) \
                .get('StreamEnabled', False)
            if stream_enabled:
                target_table_name = events['TargetTableName']
                stream_view_type = description['StreamSpecification']['StreamViewType']
                settings = {
                    "StreamSpecification": {
                        "StreamEnabled": stream_enabled,
                        "StreamViewType": stream_view_type
                    }
                }
                result = _update_table(table_name=target_table_name, **settings)
                specification = result.get('StreamSpecification', {})
                return specification
        
        

  - name: WaitTableToBeActiveAfterSteamSet
    action: aws:waitForAwsResourceProperty
    maxAttempts: 1
    timeoutSeconds: 600
    inputs:
      Service: dynamodb
      Api: DescribeTable
      TableName: "{{DynamoDBTableTargetName}}"
      PropertySelector: "$.Table.TableStatus"
      DesiredValues:
        - "ACTIVE"
  - name: CopyDynamoDBTableKinesisDestination
    action: aws:executeScript
    outputs:
      - Name: CopiedKinesisDestinations
        Selector: $.Payload
        Type: StringList
    inputs:
      Runtime: python3.8
      Handler: copy_active_kinesis_destinations
      InputPayload:
        SourceTableName: "{{ DynamoDBTableSourceName }}"
        TargetTableName: "{{ DynamoDBTableTargetName }}"
      Script: |-
        import logging
        import random
        import time
        from typing import Any, Callable, Iterator, List
        
        import boto3
        from botocore.config import Config
        
        boto3_config = Config(retries={'max_attempts': 20, 'mode': 'standard'})
        logger = logging.getLogger()
        logger.setLevel(logging.INFO)
        
        ENABLED_INSIGHTS_STATUSES = ['ENABLING', 'ENABLED']
        GLOBAL_TABLE_ACTIVE_STATUSES = ['ACTIVE']
        
        


        def _execute_boto3_dynamodb(delegate: Callable[[Any], dict]) -> dict:
            """
            Executes the given delegate with dynamodb client parameter
            :param delegate: The delegate to execute (with boto3 function)
            :return: The output of the given function
            """
            dynamo_db_client = boto3.client('dynamodb', config=boto3_config)
            description = delegate(dynamo_db_client)
            if not description['ResponseMetadata']['HTTPStatusCode'] == 200:
                logging.error(description)
                raise ValueError('Failed to execute request')
            return description
        
        

        def _describe_kinesis_destinations(table_name: str) -> dict:
            """
            Describes the current kinesis destination of the given table
            :param table_name: The table name
            :return: The dictionary of kinesis destination settings
            """
            return _execute_boto3_dynamodb(
                delegate=lambda x: x.describe_kinesis_streaming_destination(TableName=table_name))
        
        

        def _enable_kinesis_destinations(table_name: str, kinesis_arn: str) -> dict:
            """
            Enabled kinesis destination
            :param table_name: The table name
            :param kinesis_arn: The Amazon Kinesis Data Streams ARN
            :return: The dictionary of kinesis destinations
            """
            return _execute_boto3_dynamodb(
                delegate=lambda x: x.enable_kinesis_streaming_destination(TableName=table_name,
                                                                          StreamArn=kinesis_arn))
        
        

        def copy_active_kinesis_destinations(events: dict, context: dict) -> dict:
            """
            Returns information about Amazon Kinesis Data Streams destinations of the given Dynamo DB table
            :param events: The dictionary that supposed to have the following keys:
            * `SourceTableName` - The source table name
            * `TargetTableName` - The target table name
            :return: The list of Amazon Kinesis Data Streams ARNs
            """
            if 'SourceTableName' not in events:
                raise KeyError('Requires SourceTableName')
            if 'TargetTableName' not in events:
                raise KeyError('Requires TargetTableName')
        
            ACTIVE_STATUSES = ['ACTIVE', 'ENABLING']
            source_table_name = events['SourceTableName']
            target_table_name = events['TargetTableName']
            kinesis_destinations = _describe_kinesis_destinations(table_name=source_table_name)
            destinations = [d['StreamArn'] for d in kinesis_destinations['KinesisDataStreamDestinations']
                            if d['DestinationStatus'] in ACTIVE_STATUSES]
        
            for d in destinations:
                _enable_kinesis_destinations(table_name=target_table_name, kinesis_arn=d)
        
            return destinations
        
        

  - name: CopyDynamoDBTableTimeToLive
    action: aws:executeScript
    outputs:
      - Name: TargetTTLCopied
        Selector: $.Payload.TTLCopied
        Type: Boolean
      - Name: TargetTTLAttribute
        Selector: $.Payload.TTLAttribute
        Type: String
    inputs:
      Runtime: python3.8
      Handler: copy_time_to_live
      InputPayload:
        SourceTableName: "{{ DynamoDBTableSourceName }}"
        TargetTableName: "{{ DynamoDBTableTargetName }}"
      Script: |-
        import logging
        import random
        import time
        from typing import Any, Callable, Iterator, List
        
        import boto3
        from botocore.config import Config
        
        boto3_config = Config(retries={'max_attempts': 20, 'mode': 'standard'})
        logger = logging.getLogger()
        logger.setLevel(logging.INFO)
        
        ENABLED_INSIGHTS_STATUSES = ['ENABLING', 'ENABLED']
        GLOBAL_TABLE_ACTIVE_STATUSES = ['ACTIVE']
        
        


        def _execute_boto3_dynamodb(delegate: Callable[[Any], dict]) -> dict:
            """
            Executes the given delegate with dynamodb client parameter
            :param delegate: The delegate to execute (with boto3 function)
            :return: The output of the given function
            """
            dynamo_db_client = boto3.client('dynamodb', config=boto3_config)
            description = delegate(dynamo_db_client)
            if not description['ResponseMetadata']['HTTPStatusCode'] == 200:
                logging.error(description)
                raise ValueError('Failed to execute request')
            return description
        
        

        def _describe_time_to_live(table_name: str) -> dict:
            """
            Describes TTL
            :param table_name: The table name
            :return: The dictionary of TTL description
            """
            return _execute_boto3_dynamodb(
                delegate=lambda x: x.describe_time_to_live(TableName=table_name))
        
        

        def _update_time_to_live(table_name: str, is_enabled: bool, attribute_name: str) -> dict:
            """
            Updates TTL
            :param table_name: The table name
            :param is_enabled: The flag to enabled TTL
            :param attribute_name: The attribute of data to check TTL
            :return: The dictionary of TTL update response
            """
            return _execute_boto3_dynamodb(
                delegate=lambda x: x.update_time_to_live(TableName=table_name,
                                                         TimeToLiveSpecification={
                                                             "Enabled": is_enabled,
                                                             "AttributeName": attribute_name
                                                         }))
        
        

        def copy_time_to_live(events: dict, context: dict) -> dict:
            """
            Updates TTL for the given table. Enables TTL is the provided `Status` equals to `ENABLED`
            :param events: The dictionary that supposed to have the following keys:
            * `SourceTableName` - The source table name
            * `TargetTableName` - The targe table name
            :return: The dictionary that contains repose of TTL update AWS API
            """
            if 'SourceTableName' not in events:
                raise KeyError('Requires SourceTableName')
            if 'TargetTableName' not in events:
                raise KeyError('Requires TargetTableName')
        
            source_table_name = events['SourceTableName']
            target_table_name = events['TargetTableName']
            ttl_description = _describe_time_to_live(table_name=source_table_name)
            is_enabled = ttl_description\
                .get('TimeToLiveDescription', {})\
                .get('TimeToLiveStatus', '') == 'ENABLED'
            attribute_name = ttl_description\
                .get('TimeToLiveDescription', {})\
                .get('AttributeName', '')
        
            logging.debug(f'table:{target_table_name};TTL is enabled: {is_enabled};')
            if is_enabled:
                _update_time_to_live(table_name=target_table_name,
                                     is_enabled=is_enabled,
                                     attribute_name=attribute_name)
        
            return {
                'TTLCopied': is_enabled,
                'TTLAttribute': attribute_name
            }
        
        

  - name: CopyDynamoDBTableTags
    action: aws:executeScript
    outputs:
      - Name: CopiedTags
        Selector: $.Payload.Tags
        Type: MapList
    inputs:
      Runtime: python3.8
      Handler: copy_resource_tags
      InputPayload:
        SourceTableName: "{{ DynamoDBTableSourceName }}"
        TargetTableName: "{{ DynamoDBTableTargetName }}"
        Region: "{{ global:REGION }}"
        Account: "{{ global:ACCOUNT_ID }}"
      Script: |-
        import logging
        import random
        import time
        from typing import Any, Callable, Iterator, List
        
        import boto3
        from botocore.config import Config
        
        boto3_config = Config(retries={'max_attempts': 20, 'mode': 'standard'})
        logger = logging.getLogger()
        logger.setLevel(logging.INFO)
        
        ENABLED_INSIGHTS_STATUSES = ['ENABLING', 'ENABLED']
        GLOBAL_TABLE_ACTIVE_STATUSES = ['ACTIVE']
        
        


        def _execute_boto3_dynamodb(delegate: Callable[[Any], dict]) -> dict:
            """
            Executes the given delegate with dynamodb client parameter
            :param delegate: The delegate to execute (with boto3 function)
            :return: The output of the given function
            """
            dynamo_db_client = boto3.client('dynamodb', config=boto3_config)
            description = delegate(dynamo_db_client)
            if not description['ResponseMetadata']['HTTPStatusCode'] == 200:
                logging.error(description)
                raise ValueError('Failed to execute request')
            return description
        
        

        def _execute_boto3_dynamodb_paginator(func_name: str, search_exp: str = None, **kwargs) -> Iterator[Any]:
            """
            Executes the given function with pagination
            :param func_name: The function name of dynamodb client
            :param search_exp: The search expression to return elements
            :param kwargs: The arguments of `func_name`
            :return: The iterator over elements on pages
            """
            dynamo_db_client = boto3.client('dynamodb', config=boto3_config)
            paginator = dynamo_db_client.get_paginator(func_name)
            page_iterator = paginator.paginate(**kwargs)
            if search_exp:
                return page_iterator.search(search_exp)
            else:
                return page_iterator
        
        

        def _update_tags(resource_arn: str, tags: List[dict]) -> dict:
            """
            Updates tags
            :param table_name: The table name
            :param tags: The MapList of tags
            """
            return _execute_boto3_dynamodb(
                delegate=lambda x: x.tag_resource(ResourceArn=resource_arn, Tags=tags))
        
        

        def _list_tags(resource_arn: str) -> Iterator[dict]:
            """
            Lists tags
            :param table_name: The table name
            :return: The MapList of tags
            """
            return _execute_boto3_dynamodb_paginator(func_name='list_tags_of_resource',
                                                     search_exp='Tags[]',
                                                     ResourceArn=resource_arn)
        
        

        def copy_resource_tags(events: dict, context: dict) -> dict:
            """
            Copied tags of a Dynamo DB table to a target one
            :param events: The dictionary that supposed to have the following keys:
            * `SourceTableName` - The source table name
            * `TargetTableName` - The target table name
            * `Region` - The region to concatenate ARN
            * `Account` - The account to concatenate ARN
            :return: The MapList of copied resource Tags
            """
            if 'SourceTableName' not in events:
                raise KeyError('Requires SourceTableName')
            if 'TargetTableName' not in events:
                raise KeyError('Requires TargetTableName')
            if 'Region' not in events:
                raise KeyError('Requires Region')
            if 'Account' not in events:
                raise KeyError('Requires Account')
        
            source_table_name = events['SourceTableName']
            region = events['Region']
            account = events['Account']
            resource_arn = f'arn:aws:dynamodb:{region}:{account}:table/{source_table_name}'
            tags = list(_list_tags(resource_arn=resource_arn))
            if tags:
                target_table_name = events['TargetTableName']
                resource_arn = f'arn:aws:dynamodb:{region}:{account}:table/{target_table_name}'
                _update_tags(resource_arn=resource_arn, tags=tags)
        
            return {
                "Tags": tags
            }
        
        

  - name: CopyDynamoDBTableContributorInsights
    action: aws:executeScript
    outputs:
      - Name: CopiedTableContributorInsightsStatus
        Selector: $.Payload.CopiedTableContributorInsightsStatus
        Type: String
      - Name: CopiedIndexesContributorInsightsStatus
        Selector: $.Payload.CopiedIndexesContributorInsightsStatus
        Type: MapList
    inputs:
      Runtime: python3.8
      Handler: copy_contributor_insights_settings
      InputPayload:
        SourceTableName: "{{ DynamoDBTableSourceName }}"
        TargetTableName: "{{ DynamoDBTableTargetName }}"
      Script: |-
        import logging
        import random
        import time
        from typing import Any, Callable, Iterator, List
        
        import boto3
        from botocore.config import Config
        
        boto3_config = Config(retries={'max_attempts': 20, 'mode': 'standard'})
        logger = logging.getLogger()
        logger.setLevel(logging.INFO)
        
        ENABLED_INSIGHTS_STATUSES = ['ENABLING', 'ENABLED']
        GLOBAL_TABLE_ACTIVE_STATUSES = ['ACTIVE']
        
        


        def _execute_boto3_dynamodb(delegate: Callable[[Any], dict]) -> dict:
            """
            Executes the given delegate with dynamodb client parameter
            :param delegate: The delegate to execute (with boto3 function)
            :return: The output of the given function
            """
            dynamo_db_client = boto3.client('dynamodb', config=boto3_config)
            description = delegate(dynamo_db_client)
            if not description['ResponseMetadata']['HTTPStatusCode'] == 200:
                logging.error(description)
                raise ValueError('Failed to execute request')
            return description
        
        

        def _describe_table(table_name: str) -> dict:
            """
            Describes the given dynamodb table
            :param table_name: The table name
            :return: The dictionary of table description properties
            """
            return _execute_boto3_dynamodb(
                delegate=lambda x: x.describe_table(TableName=table_name))
        
        

        def _get_global_secondary_indexes(table_name: str) -> List[str]:
            """
            Returns the list of global indexes
            :param table_name: The table name
            :return: The list of global secondary index names
            """
            result = _describe_table(table_name=table_name)
            logger.debug(result)
        
            return [gsi['IndexName'] for gsi in result['Table'].get('GlobalSecondaryIndexes', [])]
        
        

        def _describe_contributor_insights(table_name: str, index_name: str = None) -> dict:
            """
            Describes contributor insights for the given table or index
            :param table_name: The table name
            :param index_name: The index name
            """
            if index_name:
                return _execute_boto3_dynamodb(
                    delegate=lambda x: x.describe_contributor_insights(TableName=table_name, IndexName=index_name))
        
            return _execute_boto3_dynamodb(
                delegate=lambda x: x.describe_contributor_insights(TableName=table_name))
        
        

        def _update_contributor_insights(table_name: str, status: str, index_name: str = None) -> dict:
            """
            Update contributor insides for the given table or index
            :param table_name: The table name
            :param index_name: The index name
            :param status: The status 'ENABLE'|'DISABLE'
            """
            if index_name:
                return _execute_boto3_dynamodb(
                    delegate=lambda x: x.update_contributor_insights(TableName=table_name,
                                                                     IndexName=index_name,
                                                                     ContributorInsightsAction=status))
        
            return _execute_boto3_dynamodb(
                delegate=lambda x: x.update_contributor_insights(TableName=table_name,
                                                                 ContributorInsightsAction=status))
        
        

        def copy_contributor_insights_settings(events: dict, context: dict) -> dict:
            """
            Returns contributor insights settings for the given table and the list of indexes
            :param events: The dictionary that supposed to have the following keys:
            * `SourceTableName` - The source table name
            * `TargetTableName` - The target table name
            :return: The dictionary that contains copied contributor insights statuses for the table and also
            a list of `IndexName`-`Status` map
            """
            if 'SourceTableName' not in events:
                raise KeyError('Requires SourceTableName')
            if 'TargetTableName' not in events:
                raise KeyError('Requires TargetTableName')
        
            source_table_name: str = events['SourceTableName']
            target_table_name: str = events['TargetTableName']
        
            # coping settings for table
            table_result = _describe_contributor_insights(table_name=source_table_name)
            table_status = table_result['ContributorInsightsStatus']
            if table_status in ENABLED_INSIGHTS_STATUSES:
                _update_contributor_insights(table_name=target_table_name,
                                             status='ENABLE')
            # coping settings for indexes
            indexes = _get_global_secondary_indexes(table_name=source_table_name)
            indexes_results = [_describe_contributor_insights(
                table_name=source_table_name, index_name=index_name) for index_name in indexes]
        
            index_statuses = [{
                'IndexName': r['IndexName'],
                'ContributorInsightsStatus': r['ContributorInsightsStatus']
            } for r in indexes_results]
            for index_status in index_statuses:
                if index_status['ContributorInsightsStatus'] in ENABLED_INSIGHTS_STATUSES:
                    _update_contributor_insights(table_name=target_table_name,
                                                 status='ENABLE',
                                                 index_name=index_status['IndexName'])
        
            return {
                "CopiedTableContributorInsightsStatus": table_result['ContributorInsightsStatus'],
                "CopiedIndexesContributorInsightsStatus": index_statuses
            }
        
        

  - name: CopyScalingTargets
    action: aws:executeScript
    outputs:
      - Name: CopiedScalingTargets
        Selector: $.Payload
        Type: MapList
    inputs:
      Runtime: python3.8
      Handler: copy_scaling_targets
      InputPayload:
        SourceTableName: "{{ DynamoDBTableSourceName }}"
        TargetTableName: "{{ DynamoDBTableTargetName }}"
      Script: |-
        
        import logging
        from typing import Any, Callable, Iterator
        
        import boto3
        from botocore.config import Config
        
        boto3_config = Config(retries={'max_attempts': 20, 'mode': 'standard'})
        
        


        def _execute_boto3_auto_scaling(delegate: Callable[[Any], dict]) -> dict:
            """
            Executes the given delegate against `application-autoscaling` client.
            Validates is the response is successfull (return code `200`)
            :param delegate: The lambda function
            :return: The response of AWS API
            """
            auto_scaling_client = boto3.client('application-autoscaling', config=boto3_config)
            description = delegate(auto_scaling_client)
            if not description['ResponseMetadata']['HTTPStatusCode'] == 200:
                logging.error(description)
                raise ValueError('Failed to execute request')
            return description
        
        

        def _execute_boto3_auto_scaling_paginator(func_name: str, search_exp: str = None, **kwargs) -> Iterator[Any]:
            """
            Executes the given function with pagination
            :param func_name: The function name of auto_scaling client
            :param search_exp: The search expression to return elements
            :param kwargs: The arguments of `func_name`
            :return: The iterator over elements on pages
            """
            autoscaling_db_client = boto3.client('application-autoscaling', config=boto3_config)
            paginator = autoscaling_db_client.get_paginator(func_name)
            page_iterator = paginator.paginate(**kwargs)
            if search_exp:
                return page_iterator.search(search_exp)
            else:
                return page_iterator
        
        

        def _describe_scalable_targets(table_name: str) -> Iterator[dict]:
            """
            Describes scalable targets
            :param table_name: The table name
            :return: The response of AWS API
            """
            return _execute_boto3_auto_scaling_paginator(func_name='describe_scalable_targets',
                                                         search_exp='ScalableTargets[]',
                                                         ServiceNamespace='dynamodb',
                                                         ResourceIds=[f'table/{table_name}'])
        
        

        def _register_scalable_target(table_name: str, dimension: str,
                                      min_cap: int, max_cap: int, role_arn: str) -> dict:
            """
            Describes scalable targets
            :param table_name: The table name
            :param dimension: The dimension
            :param min_cap: The minimum of scaling target
            :param max_cap: The maximum of scaling target
            :param role_arn: The autoscaling role ARN
            :return: The response of AWS API
            """
            return _execute_boto3_auto_scaling(
                delegate=lambda x: x.register_scalable_target(ServiceNamespace='dynamodb',
                                                              ScalableDimension=dimension,
                                                              MinCapacity=min_cap,
                                                              MaxCapacity=max_cap,
                                                              RoleARN=role_arn,
                                                              ResourceId=f'table/{table_name}'))
        
        

        
        def copy_scaling_targets(events: dict, context: dict) -> dict:
            """
            Copy scaling targets settings from source table and applies to the target one
            :param events: The dictionary that supposed to have the following keys:
            * `SourceTableName` - The source table name
            * `TargetTableName` - The target table name
            :return: MapList of copied scalable targets
            """
            if 'SourceTableName' not in events:
                raise KeyError('Requires SourceTableName')
            if 'TargetTableName' not in events:
                raise KeyError('Requires SourceTableName')
        
            source_table_name: str = events['SourceTableName']
            target_table_name: str = events['TargetTableName']
            scaling_targets = _describe_scalable_targets(table_name=source_table_name)
        
            scaling_targets = \
                [{'ScalableDimension': x['ScalableDimension'],
                  'MinCapacity':int(x["MinCapacity"]),
                  'MaxCapacity':int(x["MaxCapacity"]),
                  'RoleARN':x['RoleARN']} for x in scaling_targets]
            for x in scaling_targets:
                _register_scalable_target(table_name=target_table_name,
                                          dimension=x['ScalableDimension'],
                                          min_cap=int(x["MinCapacity"]),
                                          max_cap=int(x["MaxCapacity"]),
                                          role_arn=x['RoleARN'])
        
            return scaling_targets

  - name: CopyAlarms
    action: aws:executeScript
    outputs:
      - Name: AlarmsChanged
        Selector: $.Payload.AlarmsChanged
        Type: Integer
    inputs:
      Runtime: python3.8
      Handler: copy_alarms_for_dynamo_db_table
      InputPayload:
        SourceTableName: "{{ DynamoDBTableSourceName }}"
        TargetTableName: "{{ DynamoDBTableTargetName }}"
        DynamoDBSourceTableAlarmNames: "{{ DynamoDBSourceTableAlarmNames }}"
      Script: |-
        import boto3
        import logging
        import time
        from botocore.config import Config
        from datetime import datetime, timedelta
        from typing import Any, Callable, Iterator, List
        
        boto3_config = Config(retries={'max_attempts': 20, 'mode': 'standard'})
        
        PUT_METRIC_ALARM_PARAMS = ['AlarmName', 'AlarmDescription', 'ActionsEnabled', 'OKActions',
                                   'AlarmActions', 'InsufficientDataActions', 'MetricName', 'Namespace', 'Statistic',
                                   'ExtendedStatistic',
                                   'Dimensions', 'Period', 'Unit', 'EvaluationPeriods', 'DatapointsToAlarm',
                                   'Threshold', 'ComparisonOperator', 'TreatMissingData', 'EvaluateLowSampleCountPercentile',
                                   'Metrics', 'Tags', 'ThresholdMetricId']
        
        


        def _execute_boto3_cloudwatch(delegate: Callable[[Any], dict]) -> dict:
            """
            Executes the given delegate with cloudwatch client parameter
            :param delegate: The delegate to execute (with boto3 function)
            :return: The output of the given function
            """
            cloudwatch_client = boto3.client('cloudwatch', config=boto3_config)
            response = delegate(cloudwatch_client)
            if not response['ResponseMetadata']['HTTPStatusCode'] == 200:
                logging.error(response)
                raise ValueError('Failed to execute request')
            return response
        
        

        def _execute_boto3_cloudwatch_paginator(func_name: str, search_exp: str = None, **kwargs) -> Iterator[Any]:
            """
            Executes the given function with pagination
            :param func_name: The function name of cloudwatch client
            :param search_exp: The search expression to return elements
            :param kwargs: The arguments of `func_name`
            :return: The iterator over elements on pages
            """
            dynamo_db_client = boto3.client('cloudwatch')
            paginator = dynamo_db_client.get_paginator(func_name)
            page_iterator = paginator.paginate(**kwargs)
            if search_exp:
                return page_iterator.search(search_exp)
            else:
                return page_iterator
        
        

        def _describe_metric_alarms(alarm_names: List[str]) -> Iterator[dict]:
            """
            Returns all alarms setup in the current region
            """
            return _execute_boto3_cloudwatch_paginator(func_name='describe_alarms',
                                                       search_exp='MetricAlarms[]',
                                                       AlarmTypes=['MetricAlarm'],
                                                       AlarmNames=alarm_names)
        
        

        def _put_metric_alarm(**kwargs):
            """
            Updates or creates metric alarm with the given paramters:
            :param kwargs: The parametes for boto3 put_metric_alarm
            """
            return _execute_boto3_cloudwatch(
                delegate=lambda x: x.put_metric_alarm(**kwargs))
        
        

        def get_metric_alarms_for_table(table_name: str, alarms_names: List[str]) -> Iterator[dict]:
            source_alarms = _describe_metric_alarms(alarm_names=alarms_names)
            for alarm in filter(lambda x: x.get('Namespace', '') == 'AWS/DynamoDB', source_alarms):
                for dimension in alarm['Dimensions']:
                    if dimension['Name'] == 'TableName' and \
                            dimension['Value'] == table_name:
                        yield alarm
        
        

        def copy_alarms_for_dynamo_db_table(events, context):
            """
            Copies all the given alarm names from the source to the target table
            """
            if 'SourceTableName' not in events:
                raise KeyError('Requires SourceTableName')
            if 'TargetTableName' not in events:
                raise KeyError('Requires TargetTableName')
            if 'DynamoDBSourceTableAlarmNames' not in events:
                raise KeyError('Requires DynamoDBSourceTableAlarmNames')
        
            source_table_name: str = events['SourceTableName']
            target_table_name: str = events['TargetTableName']
            alarms_names: str = events.get('DynamoDBSourceTableAlarmNames', [])
            logging.info(
                f"Coping alarms for dynamodb table. Source: {source_table_name}, "
                f"Target: {target_table_name}. Alarm Names: {alarms_names}")
        
            source_alarms = get_metric_alarms_for_table(table_name=source_table_name, alarms_names=alarms_names)
        
            alarms_copied_count: int = 0
        
            for alarm in source_alarms:
                for dimension in alarm['Dimensions']:
                    if dimension['Name'] == 'TableName' and \
                            dimension['Value'] == source_table_name:
                        dimension['Value'] = target_table_name
                        alarm['AlarmName'] = f"{alarm['AlarmName']}_{target_table_name}"
        
                keys = [*alarm.keys()]
                for key in keys:
                    if key not in PUT_METRIC_ALARM_PARAMS:
                        del alarm[key]
                _put_metric_alarm(**alarm)
                alarms_copied_count += 1
        
            return {
                "AlarmsChanged": alarms_copied_count
            }
        
        

  - name: CopyReplicationSetting
    action: aws:executeScript
    outputs:
      - Name: CopiedGlobalTableRegions
        Selector: $.Payload
        Type: StringList
    inputs:
      Runtime: python3.8
      Handler: copy_global_table_settings
      InputPayload:
        SourceTableName: "{{ DynamoDBTableSourceName }}"
        TargetTableName: "{{ DynamoDBTableTargetName }}"
      Script: |-
        import logging
        import random
        import time
        from typing import Any, Callable, Iterator, List
        
        import boto3
        from botocore.config import Config
        
        boto3_config = Config(retries={'max_attempts': 20, 'mode': 'standard'})
        logger = logging.getLogger()
        logger.setLevel(logging.INFO)
        
        ENABLED_INSIGHTS_STATUSES = ['ENABLING', 'ENABLED']
        GLOBAL_TABLE_ACTIVE_STATUSES = ['ACTIVE']
        
        


        def _execute_boto3_dynamodb(delegate: Callable[[Any], dict]) -> dict:
            """
            Executes the given delegate with dynamodb client parameter
            :param delegate: The delegate to execute (with boto3 function)
            :return: The output of the given function
            """
            dynamo_db_client = boto3.client('dynamodb', config=boto3_config)
            description = delegate(dynamo_db_client)
            if not description['ResponseMetadata']['HTTPStatusCode'] == 200:
                logging.error(description)
                raise ValueError('Failed to execute request')
            return description
        
        

        def _update_table(table_name: str, **kwargs) -> dict:
            """
            Describes the given dynamodb table
            :param table_name: The table name
            :param kwargs: The arguments of `update_table` boto3 call
            :return: The dictionary of table description properties
            """
            return _execute_boto3_dynamodb(
                delegate=lambda x: x.update_table(TableName=table_name, **kwargs))
        
        

        def _describe_table(table_name: str) -> dict:
            """
            Describes the given dynamodb table
            :param table_name: The table name
            :return: The dictionary of table description properties
            """
            return _execute_boto3_dynamodb(
                delegate=lambda x: x.describe_table(TableName=table_name))
        
        

        def _get_global_table_all_regions(table_name: str) -> List[dict]:
            """
            Returns all global table regions
            :param table_name: The table name
            """
            description = _describe_table(table_name=table_name)
            replicas = description['Table'].get('Replicas', [])
            return replicas
        
        

        def copy_global_table_settings(events: dict, context: dict) -> dict:
            """
            Sets up replicas in the given regions
            :param events: The dictionary that supposed to have the following keys:
            * `SourceTableName` - The source table name
            * `TargetTableName` - The target table name
            :return: The list of regions where replicas copied
            """
            if 'SourceTableName' not in events:
                raise KeyError('Requires SourceTableName')
            if 'TargetTableName' not in events:
                raise KeyError('Requires TargetTableName')
        
            source_table_name: str = events['SourceTableName']
            target_table_name: str = events['TargetTableName']
            global_table_all_regions = _get_global_table_all_regions(table_name=source_table_name)
            global_table_active_regions: str = [r['RegionName']
                                                for r in global_table_all_regions
                                                if r['ReplicaStatus'] in GLOBAL_TABLE_ACTIVE_STATUSES]
            if global_table_active_regions:
                _update_table(table_name=target_table_name, ReplicaUpdates=[
                    {'Create': {'RegionName': region}} for region in global_table_active_regions])
        
            return global_table_active_regions
        
        

  - name: WaitTableToBeActiveAfterGlobalTable
    action: aws:waitForAwsResourceProperty
    maxAttempts: 5
    timeoutSeconds: 600
    inputs:
      Service: dynamodb
      Api: DescribeTable
      TableName: "{{DynamoDBTableTargetName}}"
      PropertySelector: "$.Table.TableStatus"
      DesiredValues:
        - "ACTIVE"
  - name: WaitActiveStatusOfReplication
    action: aws:executeScript
    maxAttempts: 5
    outputs:
      - Name: GlobalTableRegionsAdded
        Selector: $.Payload.GlobalTableRegionsAdded
        Type: StringList
    inputs:
      Runtime: python3.8
      Handler: wait_replication_status_in_all_regions
      InputPayload:
        TableName: "{{ DynamoDBTableTargetName }}"
        ReplicasRegionsToWait: "{{ CopyReplicationSetting.CopiedGlobalTableRegions }}"
        WaitTimeoutSeconds: 600
      Script: |-
        import logging
        import random
        import time
        from typing import Any, Callable, Iterator, List
        
        import boto3
        from botocore.config import Config
        
        boto3_config = Config(retries={'max_attempts': 20, 'mode': 'standard'})
        logger = logging.getLogger()
        logger.setLevel(logging.INFO)
        
        ENABLED_INSIGHTS_STATUSES = ['ENABLING', 'ENABLED']
        GLOBAL_TABLE_ACTIVE_STATUSES = ['ACTIVE']
        
        


        def _execute_boto3_dynamodb(delegate: Callable[[Any], dict]) -> dict:
            """
            Executes the given delegate with dynamodb client parameter
            :param delegate: The delegate to execute (with boto3 function)
            :return: The output of the given function
            """
            dynamo_db_client = boto3.client('dynamodb', config=boto3_config)
            description = delegate(dynamo_db_client)
            if not description['ResponseMetadata']['HTTPStatusCode'] == 200:
                logging.error(description)
                raise ValueError('Failed to execute request')
            return description
        
        

        def _describe_table(table_name: str) -> dict:
            """
            Describes the given dynamodb table
            :param table_name: The table name
            :return: The dictionary of table description properties
            """
            return _execute_boto3_dynamodb(
                delegate=lambda x: x.describe_table(TableName=table_name))
        
        

        def _get_global_table_all_regions(table_name: str) -> List[dict]:
            """
            Returns all global table regions
            :param table_name: The table name
            """
            description = _describe_table(table_name=table_name)
            replicas = description['Table'].get('Replicas', [])
            return replicas
        
        

        def wait_replication_status_in_all_regions(events: dict, context: dict) -> dict:
            """
            Updates contributor insights settings for the given table and the list of indexes
            :param events: The dictionary that supposed to have the following keys:
            * `TableName` - The table name
            * `ReplicasRegionsToWait` - The list of regions where replicas should be active
            * `WaitTimeoutSeconds` - The number of seconds to wait Active status
            :return: The dictionary that contains list of regions where status is Active
            """
            if 'TableName' not in events:
                raise KeyError('Requires TableName')
            if 'ReplicasRegionsToWait' not in events:
                raise KeyError('Requires ReplicasRegionsToWait')
            if 'WaitTimeoutSeconds' not in events:
                raise KeyError('Requires WaitTimeoutSeconds')
        
            table_name: str = events['TableName']
            wait_timeout_seconds: int = int(events['WaitTimeoutSeconds'])
            replicas_regions_to_wait: str = events['ReplicasRegionsToWait']
            if not replicas_regions_to_wait:
                return {
                    "GlobalTableRegionsActive": []
                }
        
            start = time.time()
            elapsed = 0
            replicas: List[dict] = []
            while elapsed < wait_timeout_seconds:
                replicas = _get_global_table_all_regions(table_name=table_name)
                all_active = all([r['ReplicaStatus'] in GLOBAL_TABLE_ACTIVE_STATUSES
                                  for r in replicas
                                  if r['RegionName'] in replicas_regions_to_wait])
                if all_active:
                    return {
                        'GlobalTableRegionsActive': replicas_regions_to_wait
                    }
        
                end = time.time()
                logging.debug(f'time elapsed {elapsed} seconds. The last result:{replicas}')
                time.sleep(20)
                elapsed = end - start
        
            raise TimeoutError(f'After {elapsed} not all replicas are Active. '
                               f'Regions to waits: {replicas_regions_to_wait}. '
                               f'The latest response: {replicas}')
        
        


