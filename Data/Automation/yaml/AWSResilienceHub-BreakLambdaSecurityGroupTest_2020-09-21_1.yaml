#
# Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy of this
# software and associated documentation files (the "Software"), to deal in the Software
# without restriction, including without limitation the rights to use, copy, modify,
# merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
# INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
# PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
# HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
# SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#
---
description: |-
            ## Id
            AWSResilienceHub-BreakLambdaSecurityGroupTest_2020-09-21

            ## Intent
            Test Lambda behavior after breaking security group

            ## Type
            TEST

            ## Risk
            High

            ## Requirements
              * Lambda Function
              * Lambda Function has VPC configuration
              * Alarm for metric [Errors](https://docs.aws.amazon.com/lambda/latest/dg/monitoring-metrics.html) setup for the Lambda function

            ## Permissions required for AutomationAssumeRole
              * ec2:CreateSecurityGroup
              * ec2:DescribeSecurityGroups
              * ec2:DescribeSubnets
              * ec2:DescribeVpcs
              * cloudwatch:DescribeAlarms
              * ssm:GetAutomationExecution
              * ssm:StartAutomationExecution
              * lambda:GetFunction
              * lambda:UpdateFunctionConfiguration
              * iam:PassRole
              * ec2:CreateTags (for `ec2:CreateAction` value "CreateSecurityGroup")

            ##### Permissions for security groups with tag `ec2:ResourceTag/AWSResilienceHub` value "lambda:test:break_security_group"
              * ec2:DeleteSecurityGroup
              * ec2:RevokeSecurityGroupEgress
              * ec2:RevokeSecurityGroupIngress
              * ec2:UpdateSecurityGroupRuleDescriptionsIngress

            ## Supports Rollback
            Yes. Revert security groups to the original list

            ## Cancellation behavior
            Revert security groups to the original list

            ## Inputs
            ### (Required) AutomationAssumeRole
              * type: String
              * description: ARN of the IAM role with permissions listed above

            ### (Required) LambdaARN
              * type: String
              * description: The Lambda function ARN

            ### (Required) LambdaErrorAlarmName
              * type: String
              * description: Alarm for metric `Errors` setup for the Lambda function

            ### (Optional) SecurityGroupId
              * type: String
              * description: The identifier of the security group that allows communication between give Lambda function and another AWS Service (e.g. DynamoDB, RDS, and etc.) SSM document will try to remove this SG from Lambda
              * default: ''

            ### (Optional) IsRollback
              * type: String
              * description: Run the rollback steps of the document. True or False. If True, the parameter PreviousExecutionId should also be specified
              * default: false

            ### (Optional) PreviousExecutionId
              * type: String
              * description: SSM execution ID of the previous execution of this document for which resources need to be cleaned up

            ## Details
            The document injects failure by adding an empty security group (or replacing the specified security group)
            that blocks all egress connections. In case of issues users should manually revert security groups to the
            original state from backup.

            ## Steps executed in normal flow
              * CheckIsRollback
              * AssertAlarmToBeGreenBeforeTest
              * AssertLambdaInVPCAndBackupLambdaSecurityGroups
              * CreateEmptySecurityGroup
              * RemoveSecurityGroupAssignment
              * AssertAlarmToBeRed
              * RollbackCurrentExecution
              * AssertAlarmToBeGreen
              * ClearEmptySecurityGroup

            ## Steps executed in rollback flow
              * CheckIsRollback
              * GetInputsFromPreviousExecution
              * GetSecurityGroupsFromPreviousExecution
              * GetEmptySecurityGroupFromPreviousExecution
              * AssertLambdaARN
              * RollbackPreviousExecution
              * ClearEmptySecurityGroupOnRollback

            ## Outputs
            ### AssertLambdaInVPCAndBackupLambdaSecurityGroups.SecurityGroupList
              * type: StringList
              * description: List of original security groups

            ### RemoveSecurityGroupAssignment.SecurityGroupListUpdatedValue
                * type: StringList
                * description: Updated list of security groups

            ### RollbackCurrentExecution.SecurityGroupListRestoredValue
                * type: StringList
                * description: List of security groups after recovery (should be equal to original)
schemaVersion: "0.3"
assumeRole: "{{ AutomationAssumeRole }}"
parameters:
  LambdaARN:
    type: String
    description: (Required) The Lambda function ARN
  AutomationAssumeRole:
    type: String
    description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.
  LambdaErrorAlarmName:
    type: String
    description: >-
      (Required) Alarm which should be red after injection of the failure
      and green after the rollback process in the end of the test.
  SecurityGroupId:
    type: String
    description: >-
      (Optional) The identifier of the security group that allows communication
      between give Lambda function and another AWS Service (e.g. DynamoDB, RDS, and etc.)
      SSM document will try to remove this SG from Lambda
    default: ''
  IsRollback:
    type: String
    description: >-
      (Optional) Run rollback step of the given previous execution (parameter `PreviousExecutionId`).
      Can be either true or false.
    default: 'false'
  PreviousExecutionId:
    type: String
    description: >-
      (Optional) Previous execution id for which resources need to be cleaned up.
    default: ''
outputs:
  - AssertLambdaInVPCAndBackupLambdaSecurityGroups.SecurityGroupList
  - RemoveSecurityGroupAssignment.SecurityGroupListUpdatedValue
  - RollbackCurrentExecution.SecurityGroupListRestoredValue
mainSteps:
  - name: CheckIsRollback
    description: Check if document should be executed in rollback mode
    action: aws:branch
    inputs:
      Choices:
        - NextStep: GetInputsFromPreviousExecution
          Variable: "{{IsRollback}}"
          StringEquals: 'true'
      Default: AssertAlarmToBeGreenBeforeTest

  - name: GetInputsFromPreviousExecution
    description: Get input from previous execution. This will be used to validate that rollback is executed with the same input
    action: aws:executeScript
    outputs:
      - Name: LambdaARN
        Selector: $.Payload.LambdaARN[0]
        Type: String
    inputs:
      Runtime: python3.7
      Handler: get_inputs_from_ssm_execution
      InputPayload:
        ExecutionId: '{{ PreviousExecutionId }}'
      Script: |-
        import json
        import boto3
        from botocore.config import Config
        
        


        def get_inputs_from_ssm_execution(events, context):
            output = {}
            config = Config(retries={'max_attempts': 20, 'mode': 'standard'})
            ssm = boto3.client('ssm', config=config)
        
            if 'ExecutionId' not in events:
                raise KeyError('Requires ExecutionId')
        
            if not events['ExecutionId']:
                raise KeyError('Requires not empty ExecutionId')
        
            response = ssm.get_automation_execution(AutomationExecutionId=events['ExecutionId'])
            response_parameters = response['AutomationExecution']['Parameters']
            # TODO DIG-853
            for parameter in response_parameters:
                output[parameter] = response_parameters[parameter]
        
            return output
        
        


  - name: GetSecurityGroupsFromPreviousExecution
    description: Get list of original Lambda function's security groups for rollback
    action: aws:executeScript
    outputs:
      - Name: SecurityGroupList
        Selector: $.Payload.SecurityGroupList
        Type: StringList
    inputs:
      Runtime: python3.7
      Handler: get_output_from_ssm_step_execution
      InputPayload:
        ExecutionId: '{{ PreviousExecutionId }}'
        StepName: 'AssertLambdaInVPCAndBackupLambdaSecurityGroups'
        ResponseField: 'SecurityGroupList'
      Script: |-
        import json
        import boto3
        from botocore.config import Config
        
        


        def get_output_from_ssm_step_execution(events, context):
            config = Config(retries={'max_attempts': 20, 'mode': 'standard'})
            ssm = boto3.client('ssm', config=config)
        
            if 'ExecutionId' not in events or 'StepName' not in events or 'ResponseField' not in events:
                raise KeyError('Requires ExecutionId, StepName and ResponseField in events')
        
            ssm_response = ssm.get_automation_execution(AutomationExecutionId=events['ExecutionId'])
            for step in ssm_response['AutomationExecution']['StepExecutions']:
                if step['StepName'] == events['StepName']:
                    response_fields = events['ResponseField'].split(',')
                    output = {}
                    for response_field in response_fields:
                        if response_field in step['Outputs']:
                            output[response_field] = step['Outputs'][response_field]
                        else:
                            """
                            By default SSM ignores empty values when encodes API outputs to JSON. It may result in
                            a situation when an empty value is a valid value but step output completely misses it.
                            Usually happens with SQS queue policies, default policy is returned by API as an empty value
                            and executeApi step output ignores it. As a result, further steps in rollback execution will fail.
                            Instead of ignoring this value we should use a default empty value in rollback, i.e. empty string
                            represents a default sqs policy
                            """
                            output[response_field] = ['']
                    return output
        
            # Could not find step name
            raise Exception('Can not find step name % in ssm execution response', events['StepName'])
        
        


  - name: GetEmptySecurityGroupFromPreviousExecution
    description: Get empty security group for rollback
    action: aws:executeScript
    outputs:
      - Name: EmptySecurityGroupId
        Selector: $.Payload.EmptySecurityGroupId[0]
        Type: String
    inputs:
      Runtime: python3.7
      Handler: get_output_from_ssm_step_execution
      InputPayload:
        ExecutionId: '{{ PreviousExecutionId }}'
        StepName: 'CreateEmptySecurityGroup'
        ResponseField: 'EmptySecurityGroupId'
      Script: |-
        import json
        import boto3
        from botocore.config import Config
        
        


        def get_output_from_ssm_step_execution(events, context):
            config = Config(retries={'max_attempts': 20, 'mode': 'standard'})
            ssm = boto3.client('ssm', config=config)
        
            if 'ExecutionId' not in events or 'StepName' not in events or 'ResponseField' not in events:
                raise KeyError('Requires ExecutionId, StepName and ResponseField in events')
        
            ssm_response = ssm.get_automation_execution(AutomationExecutionId=events['ExecutionId'])
            for step in ssm_response['AutomationExecution']['StepExecutions']:
                if step['StepName'] == events['StepName']:
                    response_fields = events['ResponseField'].split(',')
                    output = {}
                    for response_field in response_fields:
                        if response_field in step['Outputs']:
                            output[response_field] = step['Outputs'][response_field]
                        else:
                            """
                            By default SSM ignores empty values when encodes API outputs to JSON. It may result in
                            a situation when an empty value is a valid value but step output completely misses it.
                            Usually happens with SQS queue policies, default policy is returned by API as an empty value
                            and executeApi step output ignores it. As a result, further steps in rollback execution will fail.
                            Instead of ignoring this value we should use a default empty value in rollback, i.e. empty string
                            represents a default sqs policy
                            """
                            output[response_field] = ['']
                    return output
        
            # Could not find step name
            raise Exception('Can not find step name % in ssm execution response', events['StepName'])
        
        


  - name: AssertLambdaARN
    description: Validate that rollback is executed with the same input
    action: aws:branch
    inputs:
      Choices:
        - NextStep: RollbackPreviousExecution
          Variable: "{{ GetInputsFromPreviousExecution.LambdaARN }}"
          StringEquals: '{{ LambdaARN }}'
    isEnd: true

  - name: RollbackPreviousExecution
    description: Execute script that reverts Lambda function's security groups to original state
    action: aws:executeScript
    inputs:
      Runtime: python3.7
      Handler: rollback_security_groups
      InputPayload:
        SecurityGroupList: '{{GetSecurityGroupsFromPreviousExecution.SecurityGroupList}}'
        LambdaARN: '{{GetInputsFromPreviousExecution.LambdaARN}}'
        ExecutionId: '{{PreviousExecutionId}}'
      Script: |-
        import time
        from datetime import datetime
        
        import boto3
        import logging
        
        from botocore.config import Config
        from botocore.exceptions import ClientError
        
        logger = logging.getLogger()
        logger.setLevel(logging.INFO)
        
        CONCURRENT_EXECUTION_QUOTA_CODE = 'L-B99A9384'
        MINIMUM_UNRESERVED_CONCURRENCY = 100
        
        


        def check_required_params(required_params, events):
            for key in required_params:
                if key not in events:
                    raise KeyError(f'Requires {key} in events')
        
        


        def rollback_security_groups(events: dict, context):
            required_params = [
                'LambdaARN',
                'SecurityGroupList',
                'ExecutionId'
            ]
            check_required_params(required_params, events)
            lambda_client = boto3.client('lambda')
            lambda_description = lambda_client.get_function(
                FunctionName=events['LambdaARN']
            )
        
            subnet_ids = lambda_description['Configuration']['VpcConfig']['SubnetIds']
        
            time_to_wait = 900
            if 'Timeout' in events:
                time_to_wait = events['Timeout']
            timeout_timestamp = datetime.timestamp(datetime.now()) + int(time_to_wait)
            while datetime.timestamp(datetime.now()) < timeout_timestamp:
                try:
                    response = lambda_client.update_function_configuration(
                        FunctionName=events['LambdaARN'],
                        VpcConfig={
                            'SecurityGroupIds': events['SecurityGroupList'],
                            'SubnetIds': subnet_ids
                        }
                    )
                    if response['ResponseMetadata']['HTTPStatusCode'] < 400:
                        break
                except ClientError as error:
                    if error.response['Error']['Code'] == 'ResourceConflictException':
                        logger.info(f'Function {events["LambdaARN"]} is still updating, waiting...')
                    time.sleep(5)
            return {'SecurityGroupListRestoredValue': events['SecurityGroupList']}
        
        


  - name: ClearEmptySecurityGroupOnRollback
    description: Execute script that deletes emptry security group used in failure injection
    action: aws:executeScript
    timeoutSeconds: 900
    maxAttempts: 3
    inputs:
      Runtime: python3.7
      Handler: remove_empty_security_group
      InputPayload:
        EmptySecurityGroupId: '{{GetEmptySecurityGroupFromPreviousExecution.EmptySecurityGroupId}}'
      Script: |-
        import boto3
        import logging
        from datetime import datetime, timezone
        import time
        
        from botocore.exceptions import ClientError
        from dateutil import parser
        
        logger = logging.getLogger()
        logger.setLevel(logging.INFO)
        
        


        def remove_empty_security_group(events, context):
            required_params = [
                'EmptySecurityGroupId'
            ]
        
            for key in required_params:
                if key not in events:
                    raise KeyError(f'Requires {key} in events')
        
            time_to_wait = 1800
            ec2_client = boto3.client('ec2')
            if 'Timeout' in events:
                time_to_wait = events['Timeout']
            timeout_timestamp = time.time() + int(time_to_wait)
        
            while time.time() < timeout_timestamp:
                try:
                    logger.info(f'Deleting empty security group: {events["EmptySecurityGroupId"]}')
                    group_list = ec2_client.describe_security_groups(
                        Filters=[
                            {
                                'Name': 'group-id',
                                'Values': [
                                    events["EmptySecurityGroupId"],
                                ]
                            },
                        ]
                    )
                    if not group_list['SecurityGroups']:
                        break
                    group_id = group_list['SecurityGroups'][0]['GroupId']
                    logger.info(f'Deleting empty security group: {group_id}')
                    response = ec2_client.delete_security_group(
                        GroupId=group_id
                    )
                    if response['ResponseMetadata']['HTTPStatusCode'] < 400:
                        break
                except ClientError as error:
                    if error.response['Error']['Code'] == 'InvalidGroup.NotFound':
                        logger.info(f"Empty security group doesn't exist: {events['EmptySecurityGroupId']}")
                        break
                    elif error.response['Error']['Code'] == 'DependencyViolation' \
                            or error.response['Error']['Code'] == 'RequestLimitExceeded':
                        time.sleep(5)
                        continue
                    else:
                        raise error
        
            if datetime.timestamp(datetime.now()) > timeout_timestamp:
                raise TimeoutError(f'Security group {events["EmptySecurityGroupId"]} couldn\'t '
                                   f'be deleted in {time_to_wait} seconds')
        
        

    isEnd: true

  - name: AssertAlarmToBeGreenBeforeTest
    description: Ensure alarm is green before starting test. Fail if alarm is not green within expected time.
    action: aws:waitForAwsResourceProperty
    maxAttempts: 1
    timeoutSeconds: 1200
    inputs:
      Service: cloudwatch
      Api: DescribeAlarms
      AlarmNames:
        - "{{LambdaErrorAlarmName}}"
      PropertySelector: "$.MetricAlarms[0].StateValue"
      DesiredValues: ["OK"]

  - name: AssertLambdaInVPCAndBackupLambdaSecurityGroups
    description: Check that Lambda function has VPC configuration and store security groups for rollback
    action: aws:executeScript
    onFailure: Abort
    outputs:
      - Name: SecurityGroupList
        Selector: $.Payload.SecurityGroupIds
        Type: StringList
      - Name: VpcId
        Selector: $.Payload.VpcId
        Type: String
    inputs:
      Runtime: python3.7
      Handler: assert_lambda_in_vpc_and_backup_sg
      InputPayload:
        LambdaARN: '{{LambdaARN}}'
      Script: |-
        import time
        from datetime import datetime
        
        import boto3
        import logging
        
        from botocore.config import Config
        from botocore.exceptions import ClientError
        
        logger = logging.getLogger()
        logger.setLevel(logging.INFO)
        
        CONCURRENT_EXECUTION_QUOTA_CODE = 'L-B99A9384'
        MINIMUM_UNRESERVED_CONCURRENCY = 100
        
        


        def check_required_params(required_params, events):
            for key in required_params:
                if key not in events:
                    raise KeyError(f'Requires {key} in events')
        
        


        def assert_lambda_in_vpc_and_backup_sg(events: dict, context):
            required_params = [
                'LambdaARN'
            ]
            check_required_params(required_params, events)
        
            lambda_client = boto3.client('lambda')
            lambda_description = lambda_client.get_function(
                FunctionName=events['LambdaARN']
            )
            result = {}
            if 'VpcId' in lambda_description['Configuration']['VpcConfig']:
                result['VpcId'] = lambda_description['Configuration']['VpcConfig']['VpcId']
                result['SecurityGroupIds'] = lambda_description['Configuration']['VpcConfig']['SecurityGroupIds']
            else:
                raise AssertionError(f'Lambda function:{events["LambdaARN"]} is not a member of any VPC')
        
            return result


  - name: CreateEmptySecurityGroup
    description: Create empty security group
    action: 'aws:executeScript'
    onFailure: step:RollbackCurrentExecution
    onCancel: step:TriggerRollback
    outputs:
      - Name: EmptySecurityGroupId
        Selector: $.Payload.EmptySecurityGroupId
        Type: String
    inputs:
      Runtime: python3.7
      Handler: create_empty_security_group
      InputPayload:
        VpcId: '{{AssertLambdaInVPCAndBackupLambdaSecurityGroups.VpcId}}'
        Tag: "lambda:test:break_security_group"
        ExecutionId: '{{automation:EXECUTION_ID}}'
      Script: |-
        import boto3
        import logging
        from datetime import datetime, timezone
        import time
        
        from botocore.exceptions import ClientError
        from dateutil import parser
        
        logger = logging.getLogger()
        logger.setLevel(logging.INFO)
        
        


        def remove_empty_security_group(events, context):
            required_params = [
                'EmptySecurityGroupId'
            ]
        
            for key in required_params:
                if key not in events:
                    raise KeyError(f'Requires {key} in events')
        
            time_to_wait = 1800
            ec2_client = boto3.client('ec2')
            if 'Timeout' in events:
                time_to_wait = events['Timeout']
            timeout_timestamp = time.time() + int(time_to_wait)
        
            while time.time() < timeout_timestamp:
                try:
                    logger.info(f'Deleting empty security group: {events["EmptySecurityGroupId"]}')
                    group_list = ec2_client.describe_security_groups(
                        Filters=[
                            {
                                'Name': 'group-id',
                                'Values': [
                                    events["EmptySecurityGroupId"],
                                ]
                            },
                        ]
                    )
                    if not group_list['SecurityGroups']:
                        break
                    group_id = group_list['SecurityGroups'][0]['GroupId']
                    logger.info(f'Deleting empty security group: {group_id}')
                    response = ec2_client.delete_security_group(
                        GroupId=group_id
                    )
                    if response['ResponseMetadata']['HTTPStatusCode'] < 400:
                        break
                except ClientError as error:
                    if error.response['Error']['Code'] == 'InvalidGroup.NotFound':
                        logger.info(f"Empty security group doesn't exist: {events['EmptySecurityGroupId']}")
                        break
                    elif error.response['Error']['Code'] == 'DependencyViolation' \
                            or error.response['Error']['Code'] == 'RequestLimitExceeded':
                        time.sleep(5)
                        continue
                    else:
                        raise error
        
            if datetime.timestamp(datetime.now()) > timeout_timestamp:
                raise TimeoutError(f'Security group {events["EmptySecurityGroupId"]} couldn\'t '
                                   f'be deleted in {time_to_wait} seconds')
        
        


        def create_empty_security_group(events: dict, context: dict) -> dict:
            """
            Creates a empty security group in provided VPC
            The name of this SG contains Execution Id of the SSM execution
            :param events: The dictionary that supposed to have the following keys:
                * `VpcId` - The vpc id to create SG into
                * `ExecutionId` - The execution id of SSM
                * `Tag` - a value of `AWSResilienceHub` tag to assign
            :param context:
            :return: Dict with two keys:
                * EmptySecurityGroupId - string wih SG id, you can use it as String parameter in SSM
                * EmptySecurityGroupId - one element list wih SG id, you can use it as StringList parameter in SSM
            """
            required_params = [
                'VpcId',
                'ExecutionId',
                'Tag'
            ]
        
            for key in required_params:
                if key not in events:
                    raise KeyError(f'Requires {key} in events')
        
            ec2_client = boto3.client('ec2')
        
            group_id = ec2_client.create_security_group(
                Description=f'Empty SG for executionID {events["ExecutionId"]}',
                GroupName=f'EmptySG-{events["ExecutionId"]}',
                VpcId=events['VpcId'],
                TagSpecifications=[
                    {
                        'ResourceType': 'security-group',
                        'Tags': [
                            {
                                'Key': 'AWSResilienceHub',
                                'Value': events['Tag']
                            },
                        ]
                    }
                ]
            )['GroupId']
        
            result = ec2_client.revoke_security_group_egress(
                GroupId=group_id,
                IpPermissions=[
                    {
                        "IpProtocol": "-1",
                        "IpRanges": [
                            {
                                "CidrIp": "0.0.0.0/0"
                            }
                        ],
                        "Ipv6Ranges": [],
                        "PrefixListIds": [],
                        "UserIdGroupPairs": []
                    }
                ]
            )
            if not result['Return']:
                remove_empty_security_group({'EmptySecurityGroupId': group_id}, context)
                raise ClientError(
                    error_response={
                        "Error":
                        {
                            "Code": "CouldNotRevoke",
                            "Message": f"Could not revoke egress from sg: {group_id}"
                        }
                    },
                    operation_name='RevokeSecurityGroupEgress'
                )
            return {'EmptySecurityGroupId': group_id, 'EmptySecurityGroupIdList': [group_id]}
        
        


  - name: RemoveSecurityGroupAssignment
    description: Execute script that replaces the specified security group with the empty one or just adds empty security group
    action: 'aws:executeScript'
    onFailure: step:RollbackCurrentExecution
    onCancel: step:TriggerRollback
    outputs:
      - Name: SecurityGroupListUpdatedValue
        Selector: $.Payload.SecurityGroupListUpdatedValue
        Type: StringList
    inputs:
      Runtime: python3.7
      Handler: remove_sg_assignment
      InputPayload:
        SecurityGroupId: '{{SecurityGroupId}}'
        EmptySecurityGroupId: '{{CreateEmptySecurityGroup.EmptySecurityGroupId}}'
        LambdaARN: '{{LambdaARN}}'
        ExecutionId: '{{automation:EXECUTION_ID}}'
      Script: |-
        import time
        from datetime import datetime
        
        import boto3
        import logging
        
        from botocore.config import Config
        from botocore.exceptions import ClientError
        
        logger = logging.getLogger()
        logger.setLevel(logging.INFO)
        
        CONCURRENT_EXECUTION_QUOTA_CODE = 'L-B99A9384'
        MINIMUM_UNRESERVED_CONCURRENCY = 100
        
        


        def check_required_params(required_params, events):
            for key in required_params:
                if key not in events:
                    raise KeyError(f'Requires {key} in events')
        
        


        def remove_sg_assignment(events: dict, context):
            required_params = [
                'LambdaARN',
                'EmptySecurityGroupId',
                'SecurityGroupId',
                'ExecutionId'
            ]
            check_required_params(required_params, events)
            lambda_client = boto3.client('lambda')
            lambda_description = lambda_client.get_function(
                FunctionName=events['LambdaARN']
            )
            security_group_list = lambda_description['Configuration']['VpcConfig']['SecurityGroupIds']
            subnet_ids = lambda_description['Configuration']['VpcConfig']['SubnetIds']
        
            logger.info(f'Emptying Security groups for lambda:{events["LambdaARN"]}')
        
            if events['SecurityGroupId']:
                if events['SecurityGroupId'] not in security_group_list:
                    raise KeyError(f"Security group {events['SecurityGroupId']} is not in security group list of Lambda: "
                                   f"{security_group_list}")
                security_group_list.remove(events['SecurityGroupId'])
            else:
                security_group_list = []
            security_group_list.append(events['EmptySecurityGroupId'])
        
            lambda_client.update_function_configuration(
                FunctionName=events['LambdaARN'],
                VpcConfig={
                    'SecurityGroupIds': security_group_list,
                    'SubnetIds': subnet_ids
                }
            )
            return {'SecurityGroupListUpdatedValue': security_group_list}
        
        


  - name: AssertAlarmToBeRed
    description: Wait for expected alarm to be red after failure is injected
    action: aws:waitForAwsResourceProperty
    maxAttempts: 1
    # Timeout value here should be less than default timeout of 1200s, to ensure TimedOut status
    timeoutSeconds: 900
    onFailure: step:RollbackCurrentExecution
    onCancel: step:TriggerRollback
    inputs:
      Service: cloudwatch
      Api: DescribeAlarms
      AlarmNames:
        - "{{LambdaErrorAlarmName}}"
      PropertySelector: "$.MetricAlarms[0].StateValue"
      DesiredValues: ["ALARM"]

  - name: RollbackCurrentExecution
    description: Execute script that reverts Lambda function's security groups to original state
    action: 'aws:executeScript'
    maxAttempts: 5
    onCancel: step:TriggerRollback
    outputs:
      - Name: SecurityGroupListRestoredValue
        Selector: $.Payload.SecurityGroupListRestoredValue
        Type: StringList
    inputs:
      Runtime: python3.7
      Handler: rollback_security_groups
      InputPayload:
        SecurityGroupList: '{{AssertLambdaInVPCAndBackupLambdaSecurityGroups.SecurityGroupList}}'
        LambdaARN: '{{LambdaARN}}'
        ExecutionId: '{{automation:EXECUTION_ID}}'
      Script: |-
        import time
        from datetime import datetime
        
        import boto3
        import logging
        
        from botocore.config import Config
        from botocore.exceptions import ClientError
        
        logger = logging.getLogger()
        logger.setLevel(logging.INFO)
        
        CONCURRENT_EXECUTION_QUOTA_CODE = 'L-B99A9384'
        MINIMUM_UNRESERVED_CONCURRENCY = 100
        
        


        def check_required_params(required_params, events):
            for key in required_params:
                if key not in events:
                    raise KeyError(f'Requires {key} in events')
        
        


        def rollback_security_groups(events: dict, context):
            required_params = [
                'LambdaARN',
                'SecurityGroupList',
                'ExecutionId'
            ]
            check_required_params(required_params, events)
            lambda_client = boto3.client('lambda')
            lambda_description = lambda_client.get_function(
                FunctionName=events['LambdaARN']
            )
        
            subnet_ids = lambda_description['Configuration']['VpcConfig']['SubnetIds']
        
            time_to_wait = 900
            if 'Timeout' in events:
                time_to_wait = events['Timeout']
            timeout_timestamp = datetime.timestamp(datetime.now()) + int(time_to_wait)
            while datetime.timestamp(datetime.now()) < timeout_timestamp:
                try:
                    response = lambda_client.update_function_configuration(
                        FunctionName=events['LambdaARN'],
                        VpcConfig={
                            'SecurityGroupIds': events['SecurityGroupList'],
                            'SubnetIds': subnet_ids
                        }
                    )
                    if response['ResponseMetadata']['HTTPStatusCode'] < 400:
                        break
                except ClientError as error:
                    if error.response['Error']['Code'] == 'ResourceConflictException':
                        logger.info(f'Function {events["LambdaARN"]} is still updating, waiting...')
                    time.sleep(5)
            return {'SecurityGroupListRestoredValue': events['SecurityGroupList']}
        
        


  - name: AssertAlarmToBeGreen
    description: Wait for the alarm to be green after test is complete
    action: aws:waitForAwsResourceProperty
    maxAttempts: 1
    timeoutSeconds: 1200
    inputs:
      Service: cloudwatch
      Api: DescribeAlarms
      AlarmNames:
        - "{{LambdaErrorAlarmName}}"
      PropertySelector: "$.MetricAlarms[0].StateValue"
      DesiredValues: ["OK"]

  - name: ClearEmptySecurityGroup
    description: Execute script that deletes emptry security group used in failure injection
    action: aws:executeScript
    timeoutSeconds: 900
    maxAttempts: 3
    inputs:
      Runtime: python3.7
      Handler: remove_empty_security_group
      InputPayload:
        EmptySecurityGroupId: '{{CreateEmptySecurityGroup.EmptySecurityGroupId}}'
      Script: |-
        import boto3
        import logging
        from datetime import datetime, timezone
        import time
        
        from botocore.exceptions import ClientError
        from dateutil import parser
        
        logger = logging.getLogger()
        logger.setLevel(logging.INFO)
        
        


        def remove_empty_security_group(events, context):
            required_params = [
                'EmptySecurityGroupId'
            ]
        
            for key in required_params:
                if key not in events:
                    raise KeyError(f'Requires {key} in events')
        
            time_to_wait = 1800
            ec2_client = boto3.client('ec2')
            if 'Timeout' in events:
                time_to_wait = events['Timeout']
            timeout_timestamp = time.time() + int(time_to_wait)
        
            while time.time() < timeout_timestamp:
                try:
                    logger.info(f'Deleting empty security group: {events["EmptySecurityGroupId"]}')
                    group_list = ec2_client.describe_security_groups(
                        Filters=[
                            {
                                'Name': 'group-id',
                                'Values': [
                                    events["EmptySecurityGroupId"],
                                ]
                            },
                        ]
                    )
                    if not group_list['SecurityGroups']:
                        break
                    group_id = group_list['SecurityGroups'][0]['GroupId']
                    logger.info(f'Deleting empty security group: {group_id}')
                    response = ec2_client.delete_security_group(
                        GroupId=group_id
                    )
                    if response['ResponseMetadata']['HTTPStatusCode'] < 400:
                        break
                except ClientError as error:
                    if error.response['Error']['Code'] == 'InvalidGroup.NotFound':
                        logger.info(f"Empty security group doesn't exist: {events['EmptySecurityGroupId']}")
                        break
                    elif error.response['Error']['Code'] == 'DependencyViolation' \
                            or error.response['Error']['Code'] == 'RequestLimitExceeded':
                        time.sleep(5)
                        continue
                    else:
                        raise error
        
            if datetime.timestamp(datetime.now()) > timeout_timestamp:
                raise TimeoutError(f'Security group {events["EmptySecurityGroupId"]} couldn\'t '
                                   f'be deleted in {time_to_wait} seconds')
        
        

    isEnd: true

  - name: TriggerRollback
    description: This step is executed when ssm document is cancelled while it was in progress. This step starts a new execution of document in rollback mode to rollback the changes made as part of normal execution
    action: 'aws:executeScript'
    onFailure: Abort
    outputs:
      - Name: RollbackExecutionId
        Selector: $.Payload.RollbackExecutionId
        Type: String
    inputs:
      Runtime: python3.7
      Handler: start_rollback_execution
      InputPayload:
        ExecutionId: '{{automation:EXECUTION_ID}}'
      Script: |-
        import json
        import boto3
        from botocore.config import Config
        
        


        def start_rollback_execution(events, context):
            output = {}
            config = Config(retries={'max_attempts': 20, 'mode': 'standard'})
            ssm = boto3.client('ssm', config=config)
        
            if 'ExecutionId' not in events or not events['ExecutionId']:
                raise KeyError('Requires not empty ExecutionId')
        
            response = ssm.get_automation_execution(AutomationExecutionId=events['ExecutionId'])
        
            # Get parameters for current execution and add IsRollback and PreviousExecutionId
            response_parameters = response['AutomationExecution']['Parameters']
            response_parameters['IsRollback'] = ['true']
            response_parameters['PreviousExecutionId'] = [events['ExecutionId']]
        
            rollback_execution_response = ssm.start_automation_execution(
                DocumentName=response['AutomationExecution']['DocumentName'],
                DocumentVersion=response['AutomationExecution']['DocumentVersion'],
                Parameters=response_parameters
            )
            output['RollbackExecutionId'] = rollback_execution_response['AutomationExecutionId']
            return output
        
        

    isEnd: true

