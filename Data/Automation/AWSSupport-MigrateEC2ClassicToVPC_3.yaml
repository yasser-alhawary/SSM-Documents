description: "# EC2ClassicToVPCMigration
---
This document migrates EC2 Classic
   instances to EC2 VPC (Xen Platform) by creating an AMI and launching a new EC2
   instance, from the AMI, in VPC. The document only supports EC2 Classic instances
   with **Virtualization Type** as **HVM** and **Root Volume** of type **EBS**, providing
   two types of Migration:
- Test -- Creates an AMI (without Reboot) from the EC2
   Classic Instance and launches new instance from AMI in VPC.
- CutOver -- Uses
   aws:approve automation action to ask user approval for stopping the original instance,
   if provided creates an AMI from the instance and launches Target instance from
   the AMI in VPC.
---

## Parameters
1. **InstanceId:**

Type: String


  Description: **(Required)** _Instance you want to migrate from EC2 Classic to VPC(e.g.
   i-123456789abcdefgh)_

2. **AutomationAssumeRole:**

Type: String 

Description:
   **(Optional)** _IAM role which SSM Systems Manager will assume to execute this
   automation. For more information, visit [link](https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-setup.html)_

  
3.  **DestinationSubnetId:**

Type: String

Description: **(Optional)** _Destination
   SubnetId. If DestinationSubnetId is not provided, automation will choose any random
   subnet in the default VPC of the region_

4.  **MigrationType:**

Type: String

  
Description: **(Required)** _Type of migration operation that is needed to be
   performed. If you choose ```CutOver```, the original instance will be stopped
   & started during the execution. Default is ``Test`` which won't affect the original
   instance._

5.  **TargetInstanceType:**

Type: String 

Description: **(Required)**
   _Target EC2 Instance type for the migration. Only T2 instance types are supported.
   Default is t2.xlarge_

6.   **SNSNotificationARNforApproval:**

Type: String
   

Description: **(Optional)** _ARN of SNS Topic for sending Approval notification.
   Only applicable when the MigrationType is CutOver. For more information visit
   [link](https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-action-approve.html)_

  
7.   **ApproverIAM**:

Type: StringList 

Description: **(Optional)** _ARN
   of the Approvers who are able to either approve or reject the action. Only applicable
   when the MigrationType is CutOver. For more information visit [link](https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-action-approve.html)_

  
8. **DestinationSecurityGroupId:**

Type: StringList 

Description: **(Optional)**
   _Destination SecurityGroup ID. If DestinationSecurityGroup ID is not provided,
   Security Groups attached to the source instance will be copied to VPC and used.
   If automation fails to copy security groups attached to source instance, then
   target instance will be launched with default security group of selected VPC._"
schemaVersion: "0.3"
assumeRole: "{{AutomationAssumeRole}}"
parameters:
  AutomationAssumeRole:
    default: ""
    type: "String"
    description: "(Optional) IAM role which SSM Systems Manager will assume to execute
       this automation. For more information, visit - https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-setup.html"
    allowedPattern: "^$|^arn:aws:iam::[0-9]*:role/[/w+=,.@-]+$"
  InstanceId:
    type: "String"
    description: "(Required) Instance you want to migrate from EC2 Classic to VPC
       (e.g. i-123456789abcdefgh)."
    allowedPattern: "^[m]{0,1}i-[a-z0-9]{8,17}$"
  TargetInstanceType:
    default: "t2.xlarge"
    type: "String"
    description: "(Required) Target EC2 Instance type for the migration. Only T2 instance
       types are supported."
    allowedValues:
    - "t2.nano"
    - "t2.micro"
    - "t2.small"
    - "t2.medium"
    - "t2.large"
    - "t2.xlarge"
    - "t2.2xlarge"
  MigrationType:
    default: "Test"
    type: "String"
    description: "(Required) ype of migration operation that is needed to be performed.
       If you choose CutOver, the original instance will be stopped & started during
       the execution. Default is Test which won't effect the original instance."
    allowedValues:
    - "Test"
    - "CutOver"
  SNSNotificationARNforApproval:
    default: ""
    type: "String"
    description: "(Optional) Provide the ARN of the SNS Topic for sending Approval
       notification. Only applicable when the MigrationType is CutOver. For more
       information visit - https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-action-approve.html"
    allowedPattern: "^$|arn:aws:sns:(us(-gov)?|ap|ca|cn|eu|sa)-(central|(north|south)?(east|west)?)-
      d:d{12}:.*"
  ApproverIAM:
    default: []
    type: "StringList"
    description: "(Optional) Provide the ARN of the Approver who are able to either
       approve or reject the action. Only applicable when the MigrationType is CutOver.
       For more information visit - https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-action-approve.html"
    allowedPattern: "^$|arn:aws:iam::d{12}:.*"
  DestinationSubnetId:
    default: ""
    type: "String"
    description: "(Optional) Destination SubnetId. If  DestinationSubnetId is not
       provided, automation which choose any random subnet in the default VPC."
    allowedPattern: "^$|^subnet-[a-z0-9]{8,17}$"
  DestinationSecurityGroupId:
    default: []
    type: "StringList"
    description: "(Optional) Provide the destination VPC SecurityGroup ID. If no SecurityGroup
       ID is provided, Security Groups attached to the source instance will be copied
       to VPC and used."
    allowedPattern: "^$|^sg-[0-9a-f]{8,17}$"
mainSteps:
- name: "getInstanceProperties"
  action: "aws:executeAwsApi"
  maxAttempts: 3
  onFailure: "Abort"
  nextStep: "checkInstanceIsInClassic"
  inputs:
    Service: "ec2"
    Api: "DescribeInstances"
    InstanceIds:
    - "{{InstanceId}}"
  outputs:
  - Name: "virtualizationType"
    Selector: "$.Reservations[0].Instances[0].VirtualizationType"
    Type: "String"
  - Name: "rootDeviceType"
    Selector: "$.Reservations[0].Instances[0].RootDeviceType"
    Type: "String"
  - Name: "Keypair"
    Selector: "$.Reservations[0].Instances[0].KeyName"
    Type: "String"
  - Name: "PublicIpAddress"
    Selector: "$.Reservations[0].Instances[0].PublicIpAddress"
    Type: "String"
  - Name: "VpcId"
    Selector: "$.Reservations[0].Instances[0].VpcId"
    Type: "String"
- name: "checkInstanceIsInClassic"
  action: "aws:branch"
  onFailure: "Abort"
  isCritical: true
  isEnd: true
  inputs:
    Choices:
    - NextStep: "checkIfVirtualizationTypeIsHVM"
      Not:
        Variable: "{{getInstanceProperties.VpcId}}"
        StartsWith: "vpc-"
- name: "checkIfVirtualizationTypeIsHVM"
  action: "aws:assertAwsResourceProperty"
  onFailure: "Abort"
  maxAttempts: 3
  isCritical: true
  nextStep: "checkIfRootVolumeIsEBS"
  inputs:
    Service: "ec2"
    Api: "DescribeInstances"
    InstanceIds:
    - "{{InstanceId}}"
    PropertySelector: "$.Reservations[0].Instances[0].VirtualizationType"
    DesiredValues:
    - "hvm"
- name: "checkIfRootVolumeIsEBS"
  action: "aws:assertAwsResourceProperty"
  onFailure: "Abort"
  isCritical: true
  maxAttempts: 3
  nextStep: "verifySecurityGroup"
  inputs:
    Service: "ec2"
    Api: "DescribeInstances"
    InstanceIds:
    - "{{InstanceId}}"
    PropertySelector: "$.Reservations[0].Instances[0].RootDeviceType"
    DesiredValues:
    - "ebs"
- name: "verifySecurityGroup"
  action: "aws:executeScript"
  isCritical: true
  onFailure: "Abort"
  nextStep: "verifySubnetId"
  inputs:
    Runtime: "python3.8"
    Handler: "verifysecurityGroup"
    InputPayload:
      security_group: "{{DestinationSecurityGroupId}}"
      subnet_id: "{{DestinationSubnetId}}"
      instance_id: "{{InstanceId}}"
    Script: "import boto3
import botocore
from botocore.exceptions import ClientError

      import sys

#ErrorCodes:
#140 - NoDefaultVPCFound
#141 - SubnetNotFound(InvalidSubnetID.NotFound)

      #142 - SecurityGroupExists
#143 - SecurityGroupsFromDifferentVpcs

def initiazlize_client(service):

          try:
        global client
        client = boto3.client(service)
 
         except ClientError as e:
        raise Exception ("[ERROR] Failed to initiazlie
       EC2 client",e)

def get_default_vpc():
    print ("[INFO] Looking for
       the default VPC")
    try:
        default_vpc=client.describe_vpcs(

                  Filters = [
                {
                    "Name": "
      isDefault",
                    "Values": [
                        "
      true"
                    ]
                }
            ]
        )

              if not default_vpc['Vpcs']:
            print ('[ERROR] No default
       VPC found')
            return 140
        else:
            return (default_vpc['Vpcs'][0]['VpcId'])

          except ClientError as e:
        raise Exception ("[ERROR]",e)

def
       find_vpc_from_subnet(subnet_id):
    print("[INFO] Finding VPC Id from the
       provided subnet:", subnet_id)
    try:
        subnet_details=client.describe_subnets(

                  SubnetIds = [
                subnet_id
            ]
     
         )
        if "InvalidSubnetID.NotFound" in subnet_details:
        
          return 141
        else:
            return subnet_details['Subnets'][0]['VpcId']

          except ClientError as e:
        raise Exception ("[ERROR]",e)

def
       find_vpc_from_security_group(sg_id):
    index=0
    vpcids=[]
    print('[INFO]
       Finding VPC of Provided Security groups:', sg_id)

    try:
        for
       i in sg_id:
            security_group = client.describe_security_groups(

                      Filters = [
                    {
                      
        "Name": "group-id",
                        "Values": [
        
                          sg_id[index]
                        ]
             
             }
                ]
            )
            if (len(security_group['SecurityGroups'])
       == 0):
                raise Exception ('[ERROR] No Security Group found',
       sg_id[index])
            else:
                vpcid = security_group['SecurityGroups'][0]['VpcId']

                      vpcids.append(vpcid)
            index+=1
        if(len(set(vpcids))
       != 1):
            return 143
        else:
            return vpcids[0]
            
    except ClientError as e:
        raise Exception ("[ERROR]"
      ,e)

def check_if_security_group_exists(security_group_name, vpcid):
   
       print("[INFO] Checking if Security group by name ", security_group_name,"
      exists")
    try:    
        security_group = client.describe_security_groups(

                      Filters = [
                    {
                      
        "Name": "group-name",
                        "Values": [
      
                            security_group_name
                        ]
    
                      },
                    {
                        "Name"
      : "vpc-id",
                        "Values": [
                     
             vpcid
                        ]
                    }
          
            ]
            )
        if (len(security_group['SecurityGroups']) !=
       0):
            security_group_id = security_group['SecurityGroups'][0]['GroupId']

                  return security_group_id
        else:
            return 142

          except ClientError as e:
        raise Exception ("[ERROR]",e)    

          
def create_security_group(vpcid, instance_id):    
    index=0
   
       new_security_group_ids=[]
    print("[INFO] Finding security groups attached
       to source instance:", instance_id)
    try:            
        instance_details=client.describe_instances(InstanceIds
       = [instance_id])
        for i in instance_details['Reservations'][0]['Groups']:

                  security_group_Id = instance_details['Reservations'][0]['Groups'][index].get('GroupId',
       '')
            security_group_name = instance_details['Reservations'][0]['Groups'][index].get('GroupName',
       '')+'-CopiedFromClassic'
            
            security_group_exists
       = check_if_security_group_exists(security_group_name, vpcid)
           
       if  security_group_exists != 142:
                print("[INFO] Security
       group by name ", security_group_name," exists")
                new_security_group_ids.append(security_group_exists)

                      
            else:
                try:
               
           security_group = client.describe_security_groups(GroupIds = [security_group_Id])

                          
                    security_group_description = security_group['SecurityGroups'][0].get('Description',
       '')
                    print ('[INFO] Creating new Security Group in VPC:',
       vpcid)
                    
                    new_security_group = client.create_security_group(GroupName=security_group_name,
       VpcId=vpcid, Description=security_group_description)
                   
       new_security_group_id = new_security_group['GroupId']
                  
        
                    print ('[INFO] Created Security Group:', new_security_group_id
       )
                    
                    add_ingress_rules = client.authorize_security_group_ingress(

                              GroupId=new_security_group_id,
                  
            IpPermissions=security_group['SecurityGroups'][0].get('IpPermissions',
       '')
                        )                                    
     
                     new_security_group_ids.append(new_security_group_id)
     
                 except ClientError as e:
                    error = e.response['Error']['Code']
       
                    if error == 'InvalidParameterCombination':
       
                       print('[ERROR] Unable to copy security group due to:', e)

                              print('[ERROR] Ensure the source security does not
       have a rule with source as security group')
                    else:
 
                             print('[ERROR] Unable to copy security group due to:',
       e)
                    print('[INFO] Deleting the security group:', new_security_group_id)

                          delete = client.delete_security_group(GroupId = new_security_group_id)

                  index+=1
        return new_security_group_ids
    except ClientError
       as e:
        raise Exception ("[ERROR]",e)

def create_security_group_in_default_vpc(instance_id):

          vpcid = get_default_vpc()
    try:
        if (vpcid == 140):
     
             raise Exception ('[ERROR] No Default VPC Found')
        else:
  
                return create_security_group(vpcid, instance_id)
    except ClientError
       as e:
        raise Exception ("[ERROR]",e)
        
def create_security_group_in_provided_vpc(vpcid,
       instance_id):
    return create_security_group(vpcid, instance_id)
    
          
def verifysecurityGroup(events,context):
    initiazlize_client('ec2')

          if (events['security_group'] == []):
        if (events['subnet_id'] ==
       ""):
            final_security_groupid = create_security_group_in_default_vpc(events['instance_id'])

              else:
            final_security_groupid = create_security_group_in_provided_vpc(find_vpc_from_subnet(events['subnet_id']),events['instance_id'])

          else:
        if (events['subnet_id'] == ""):
            vpcid1 =
       get_default_vpc()
            vpcid2 = find_vpc_from_security_group(events['security_group'])

                  if vpcid2 != 143:
                if vpcid1 == vpcid2:
     
                     final_security_groupid=events['security_group']
          
            else:
                    raise Exception('[ERROR] Security Group and
       Subnet are not in same VPC')
            else:
                raise Exception
       ('[ERROR] Provided Security groups are not from same VPC')               
       
        else:
            vpcid1 = find_vpc_from_subnet(events['subnet_id'])

                  vpcid2 = find_vpc_from_security_group(events['security_group'])

                  if vpcid2 != 143:            
                if vpcid1 == vpcid2:

                          final_security_groupid=events['security_group']
     
                 else:
                    raise Exception('[ERROR] Security Group
       and Subnet are not in same VPC')
            else:
                raise
       Exception ('[ERROR] Provided Security groups are not from same VPC')
   
       if len(final_security_groupid) == 0:
        print('[WARN] No security group
       found, target instance will be launched with default security group')
  
        print (final_security_groupid)       
    return {
        "SecuritygroupId"
      : final_security_groupid
    }
"
  outputs:
  - Name: "VerifiedSecurityGroupID"
    Type: "StringList"
    Selector: "$.Payload.SecuritygroupId"
- name: "verifySubnetId"
  action: "aws:branch"
  isCritical: true
  onFailure: "Abort"
  isEnd: true
  inputs:
    Choices:
    - NextStep: "createAMIWithoutReboot"
      Not:
        Variable: "{{DestinationSubnetId}}"
        StringEquals: ""
    Default: "getDefaultVPC"
- name: "getDefaultVPC"
  action: "aws:executeAwsApi"
  onFailure: "Abort"
  maxAttempts: 3
  nextStep: "getSubnetIdDefaultVPC"
  inputs:
    Service: "ec2"
    Api: "DescribeVpcs"
    Filters:
    - Name: "isDefault"
      Values:
      - "true"
  outputs:
  - Name: "VpcId"
    Selector: "$.Vpcs[0].VpcId"
    Type: "String"
- name: "getSubnetIdDefaultVPC"
  action: "aws:executeAwsApi"
  onFailure: "Abort"
  maxAttempts: 3
  nextStep: "createAMIWithoutReboot"
  inputs:
    Service: "ec2"
    Api: "DescribeSubnets"
    Filters:
    - Name: "vpc-id"
      Values:
      - "{{getDefaultVPC.VpcId}}"
  outputs:
  - Name: "subnetIdFromDefaultVpc"
    Selector: "$.Subnets[0].SubnetId"
    Type: "String"
- name: "createAMIWithoutReboot"
  action: "aws:createImage"
  maxAttempts: 3
  onFailure: "Abort"
  nextStep: "branchOnMigrationType"
  inputs:
    InstanceId: "{{InstanceId}}"
    ImageName: "Test_BackupAMI_fromAutomation_{{automation:EXECUTION_ID}}"
    NoReboot: true
    ImageDescription: "InitialBackup_createdFrom_{{InstanceId}}_byAutomationId:{{automation:EXECUTION_ID}}_{{global:DATE_TIME}}"
- name: "branchOnMigrationType"
  action: "aws:branch"
  isCritical: true
  onFailure: "Abort"
  isEnd: true
  inputs:
    Choices:
    - NextStep: "checkInstanceStopBehavior"
      Variable: "{{MigrationType}}"
      StringEquals: "CutOver"
    Default: "chooseSubnetToUseTest"
- name: "chooseSubnetToUseTest"
  action: "aws:branch"
  isCritical: true
  onFailure: "Abort"
  isEnd: true
  inputs:
    Choices:
    - NextStep: "launchTestInstanceDefaultVPC"
      Variable: "{{DestinationSubnetId}}"
      StringEquals: ""
    Default: "launchTestInstanceProvidedSubnet"
- name: "launchTestInstanceDefaultVPC"
  action: "aws:runInstances"
  maxAttempts: 3
  isCritical: true
  onFailure: "step:terminateTestInstanceDefaultVPC"
  nextStep: "branchOnPublicIp"
  timeoutSeconds: 1200
  inputs:
    ImageId: "{{createAMIWithoutReboot.ImageId}}"
    InstanceType: "{{TargetInstanceType}}"
    MinInstanceCount: 1
    MaxInstanceCount: 1
    SubnetId: "{{getSubnetIdDefaultVPC.subnetIdFromDefaultVpc}}"
    SecurityGroupIds:
    - "{{verifySecurityGroup.VerifiedSecurityGroupID}}"
    KeyName: "{{getInstanceProperties.Keypair}}"
    TagSpecifications:
    - ResourceType: "instance"
      Tags:
      - Key: "Name"
        Value: "CreatedBySSMAutomation_from_{{InstanceId}}"
      - Key: "CreatedFromAMI"
        Value: "{{ createAMIWithoutReboot.ImageId }}"
      - Key: "Category"
        Value: "TestEC2ClassicMigration"
      - Key: "AutomationExecutionID"
        Value: "{{automation:EXECUTION_ID}}"
  outputs:
  - Name: "InstanceId"
    Selector: "InstanceIds[0]"
    Type: "String"
- name: "terminateTestInstanceDefaultVPC"
  action: "aws:changeInstanceState"
  maxAttempts: 3
  isCritical: true
  isEnd: true
  timeoutSeconds: 300
  onFailure: "Abort"
  inputs:
    InstanceIds:
    - "{{launchTestInstanceDefaultVPC.InstanceIds}}"
    CheckStateOnly: false
    DesiredState: "terminated"
- name: "launchTestInstanceProvidedSubnet"
  action: "aws:runInstances"
  maxAttempts: 3
  isCritical: true
  onFailure: "step:terminateTestInstanceProvidedSubnet"
  nextStep: "branchOnPublicIp"
  timeoutSeconds: 1200
  inputs:
    ImageId: "{{createAMIWithoutReboot.ImageId}}"
    InstanceType: "{{TargetInstanceType}}"
    MinInstanceCount: 1
    MaxInstanceCount: 1
    SubnetId: "{{DestinationSubnetId}}"
    SecurityGroupIds:
    - "{{verifySecurityGroup.VerifiedSecurityGroupID}}"
    KeyName: "{{getInstanceProperties.Keypair}}"
    TagSpecifications:
    - ResourceType: "instance"
      Tags:
      - Key: "Name"
        Value: "CreatedBySSMAutomation_from_{{InstanceId}}"
      - Key: "CreatedFromAMI"
        Value: "{{ createAMIWithoutReboot.ImageId }}"
      - Key: "Category"
        Value: "TestEC2ClassicMigration"
      - Key: "AutomationExecutionID"
        Value: "{{automation:EXECUTION_ID}}"
  outputs:
  - Name: "InstanceId"
    Selector: "InstanceIds[0]"
    Type: "String"
- name: "terminateTestInstanceProvidedSubnet"
  action: "aws:changeInstanceState"
  maxAttempts: 3
  isCritical: true
  isEnd: true
  timeoutSeconds: 300
  onFailure: "Abort"
  inputs:
    InstanceIds:
    - "{{launchTestInstanceProvidedSubnet.InstanceIds}}"
    CheckStateOnly: false
    DesiredState: "terminated"
- name: "checkInstanceStopBehavior"
  action: "aws:assertAwsResourceProperty"
  onFailure: "Abort"
  isCritical: true
  maxAttempts: 3
  nextStep: "approvalToStopOriginalInstance"
  inputs:
    Service: "ec2"
    Api: "DescribeInstanceAttribute"
    InstanceId: "{{InstanceId}}"
    Attribute: "instanceInitiatedShutdownBehavior"
    PropertySelector: "$.InstanceInitiatedShutdownBehavior.Value"
    DesiredValues:
    - "stop"
- name: "approvalToStopOriginalInstance"
  action: "aws:approve"
  timeoutSeconds: 1800
  maxAttempts: 3
  onFailure: "Abort"
  nextStep: "stopOriginalInstance"
  inputs:
    NotificationArn: "{{SNSNotificationARNforApproval}}"
    Message: "Provide approval for stopping the original instance and migrate"
    MinRequiredApprovals: 1
    Approvers:
    - "{{ApproverIAM}}"
- name: "stopOriginalInstance"
  action: "aws:changeInstanceState"
  maxAttempts: 3
  timeoutSeconds: 300
  onFailure: "step:forceStopOriginalInstance"
  inputs:
    InstanceIds:
    - "{{InstanceId}}"
    CheckStateOnly: false
    DesiredState: "stopped"
  nextStep: "createAMIAfterStoppingInstance"
- name: "forceStopOriginalInstance"
  action: "aws:changeInstanceState"
  maxAttempts: 3
  timeoutSeconds: 300
  onFailure: "Abort"
  nextStep: "createAMIAfterStoppingInstance"
  inputs:
    InstanceIds:
    - "{{InstanceId}}"
    CheckStateOnly: false
    DesiredState: "stopped"
    Force: true
- name: "createAMIAfterStoppingInstance"
  action: "aws:createImage"
  maxAttempts: 3
  onFailure: "Abort"
  nextStep: "chooseSubnetToUseCutOver"
  inputs:
    InstanceId: "{{InstanceId}}"
    ImageName: "CutOver_BackupAMI_fromAutomation_{{automation:EXECUTION_ID}}"
    NoReboot: true
    ImageDescription: "Backup_createdFrom_{{InstanceId}}_byAutomationId:{{automation:EXECUTION_ID}}_{{global:DATE_TIME}}"
- name: "chooseSubnetToUseCutOver"
  action: "aws:branch"
  isCritical: true
  onFailure: "Abort"
  isEnd: true
  inputs:
    Choices:
    - NextStep: "launchCutOverInstanceDefaultVPC"
      Variable: "{{DestinationSubnetId}}"
      StringEquals: ""
    Default: "launchCutOverInstanceProvidedSubnet"
- name: "launchCutOverInstanceDefaultVPC"
  action: "aws:runInstances"
  maxAttempts: 3
  isCritical: true
  onFailure: "step:awaitFailureApprovalDefaultVPC"
  nextStep: "branchOnPublicIp"
  timeoutSeconds: 1200
  inputs:
    ImageId: "{{createAMIAfterStoppingInstance.ImageId}}"
    InstanceType: "{{TargetInstanceType}}"
    MinInstanceCount: 1
    MaxInstanceCount: 1
    SubnetId: "{{getSubnetIdDefaultVPC.subnetIdFromDefaultVpc}}"
    SecurityGroupIds:
    - "{{verifySecurityGroup.VerifiedSecurityGroupID}}"
    KeyName: "{{getInstanceProperties.Keypair}}"
    TagSpecifications:
    - ResourceType: "instance"
      Tags:
      - Key: "Name"
        Value: "CreatedBySSMAutomation_from_{{InstanceId}}"
      - Key: "CreatedFromAMI"
        Value: "{{ createAMIWithoutReboot.ImageId }}"
      - Key: "Category"
        Value: "CutOverEC2ClassicMigration"
      - Key: "AutomationExecutionID"
        Value: "{{automation:EXECUTION_ID}}"
  outputs:
  - Name: "InstanceId"
    Selector: "InstanceIds[0]"
    Type: "String"
- name: "awaitFailureApprovalDefaultVPC"
  action: "aws:approve"
  timeoutSeconds: 1800
  maxAttempts: 3
  onFailure: "Abort"
  nextStep: "terminateCutOverInstanceDefaultVPC"
  inputs:
    NotificationArn: "{{SNSNotificationARNforApproval}}"
    Message: "Failed to launch the instance in the Default VPC. Provide approval for
       starting the Original instance and terminating the new CutOver instance. This
       step will timeout after 3600s"
    MinRequiredApprovals: 1
    Approvers:
    - "{{ApproverIAM}}"
- name: "terminateCutOverInstanceDefaultVPC"
  action: "aws:changeInstanceState"
  maxAttempts: 3
  isCritical: true
  timeoutSeconds: 300
  nextStep: "startOriginalInstance"
  onFailure: "step:startOriginalInstance"
  inputs:
    InstanceIds:
    - "{{launchCutOverInstanceDefaultVPC.InstanceIds}}"
    CheckStateOnly: false
    DesiredState: "terminated"
- name: "launchCutOverInstanceProvidedSubnet"
  action: "aws:runInstances"
  maxAttempts: 3
  isCritical: true
  onFailure: "step:awaitFailureApprovalProvidedSubnet"
  nextStep: "branchOnPublicIp"
  timeoutSeconds: 1200
  inputs:
    ImageId: "{{createAMIAfterStoppingInstance.ImageId}}"
    InstanceType: "{{TargetInstanceType}}"
    MinInstanceCount: 1
    MaxInstanceCount: 1
    SubnetId: "{{DestinationSubnetId}}"
    SecurityGroupIds:
    - "{{verifySecurityGroup.VerifiedSecurityGroupID}}"
    KeyName: "{{getInstanceProperties.Keypair}}"
    TagSpecifications:
    - ResourceType: "instance"
      Tags:
      - Key: "Name"
        Value: "CreatedBySSMAutomation_from_{{InstanceId}}"
      - Key: "CreatedFromAMI"
        Value: "{{ createAMIWithoutReboot.ImageId }}"
      - Key: "Category"
        Value: "CutOverEC2ClassicMigration"
      - Key: "AutomationExecutionID"
        Value: "{{automation:EXECUTION_ID}}"
  outputs:
  - Name: "InstanceId"
    Selector: "InstanceIds[0]"
    Type: "String"
- name: "awaitFailureApprovalProvidedSubnet"
  action: "aws:approve"
  maxAttempts: 3
  timeoutSeconds: 1800
  onFailure: "Abort"
  nextStep: "terminateCutOverInstanceProvidedSubnet"
  inputs:
    NotificationArn: "{{SNSNotificationARNforApproval}}"
    Message: "Failed to launch the instance in the Default VPC. Provide approval for
       starting the Original instance and terminating the new CutOver instance. This
       step will timeout after 3600s"
    MinRequiredApprovals: 1
    Approvers:
    - "{{ApproverIAM}}"
- name: "terminateCutOverInstanceProvidedSubnet"
  action: "aws:changeInstanceState"
  maxAttempts: 3
  isCritical: true
  timeoutSeconds: 300
  nextStep: "startOriginalInstance"
  onFailure: "step:startOriginalInstance"
  inputs:
    InstanceIds:
    - "{{launchCutOverInstanceProvidedSubnet.InstanceIds}}"
    CheckStateOnly: false
    DesiredState: "terminated"
- name: "startOriginalInstance"
  action: "aws:changeInstanceState"
  isCritical: true
  maxAttempts: 3
  isEnd: true
  timeoutSeconds: 300
  inputs:
    InstanceIds:
    - "{{InstanceId}}"
    CheckStateOnly: false
    DesiredState: "running"
- name: "branchOnPublicIp"
  action: "aws:branch"
  isCritical: true
  isEnd: true
  onFailure: "Abort"
  inputs:
    Choices:
    - NextStep: "verifyPublicIpIsEIP"
      Not:
        Variable: "{{getInstanceProperties.PublicIpAddress}}"
        Contains: "PublicIpAddress"
- name: "verifyPublicIpIsEIP"
  action: "aws:executeAwsApi"
  maxAttempts: 3
  onFailure: "Abort"
  isCritical: false
  nextStep: "branchOnInstanceLaunched"
  inputs:
    Service: "ec2"
    Api: "DescribeAddresses"
    PublicIps:
    - "{{getInstanceProperties.PublicIpAddress}}"
- name: "branchOnInstanceLaunched"
  action: "aws:branch"
  isCritical: true
  onFailure: "Abort"
  inputs:
    Choices:
    - NextStep: "moveEIPToVPC"
      Variable: "{{launchCutOverInstanceDefaultVPC.InstanceId}}"
      StartsWith: "i-"
    - NextStep: "moveEIPToVPC"
      Variable: "{{launchCutOverInstanceProvidedSubnet.InstanceId}}"
      StartsWith: "i-"
    - NextStep: "verifySubnetIsPublicTestDefaultVPC"
      Variable: "{{launchTestInstanceDefaultVPC.InstanceId}}"
      StartsWith: "i-"
    - NextStep: "verifySubnetIsPublicTestProvidedSubnet"
      Variable: "{{launchTestInstanceProvidedSubnet.InstanceId}}"
      StartsWith: "i-"
- name: "moveEIPToVPC"
  action: "aws:executeAwsApi"
  maxAttempts: 3
  isCritical: true
  onFailure: "Abort"
  nextStep: "getAllocationIDOfEIP"
  inputs:
    Service: "ec2"
    Api: "MoveAddressToVpc"
    PublicIp: "{{getInstanceProperties.PublicIpAddress}}"
- name: "getAllocationIDOfEIP"
  action: "aws:executeAwsApi"
  maxAttempts: 3
  onFailure: "Abort"
  nextStep: "branchOnCutOverInstanceLaunched"
  inputs:
    Service: "ec2"
    Api: "DescribeAddresses"
    PublicIps:
    - "{{getInstanceProperties.PublicIpAddress}}"
  outputs:
  - Name: "AllocationId"
    Selector: "Addresses[0].AllocationId"
    Type: "String"
- name: "branchOnCutOverInstanceLaunched"
  action: "aws:branch"
  isCritical: true
  onFailure: "Abort"
  inputs:
    Choices:
    - NextStep: "associateEIPCutOverDefaultVPC"
      Variable: "{{launchCutOverInstanceDefaultVPC.InstanceId}}"
      StartsWith: "i-"
    - NextStep: "associateEIPCutOverProvidedSubnet"
      Variable: "{{launchCutOverInstanceProvidedSubnet.InstanceId}}"
      StartsWith: "i-"
- name: "associateEIPCutOverDefaultVPC"
  action: "aws:executeAwsApi"
  maxAttempts: 3
  onFailure: "Abort"
  isEnd: true
  inputs:
    Service: "ec2"
    Api: "AssociateAddress"
    AllocationId: "{{getAllocationIDOfEIP.AllocationId}}"
    InstanceId: "{{launchCutOverInstanceDefaultVPC.InstanceId}}"
- name: "associateEIPCutOverProvidedSubnet"
  action: "aws:executeAwsApi"
  maxAttempts: 3
  onFailure: "Abort"
  isEnd: true
  inputs:
    Service: "ec2"
    Api: "AssociateAddress"
    AllocationId: "{{getAllocationIDOfEIP.AllocationId}}"
    InstanceId: "{{launchCutOverInstanceProvidedSubnet.InstanceId}}"
- name: "verifySubnetIsPublicTestDefaultVPC"
  action: "aws:executeScript"
  isCritical: true
  onFailure: "Abort"
  isEnd: true
  inputs:
    Runtime: "python3.8"
    Handler: "verifyIfSubnetIsPublic"
    InputPayload:
      instance_id: "{{launchTestInstanceDefaultVPC.InstanceId}}"
    Script: "import boto3
import botocore
from botocore.exceptions import ClientError

      
def initiazlize_client(service):
    try:
        global client
      
        client = boto3.client(service)
    except ClientError as e:
        raise
       Exception ("[ERROR] Failed to initiazlie EC2 client",e)
    
def verifyIfSubnetIsPublic(event,
       context):
    initiazlize_client('ec2')
    try:
        instance_id =
       event['instance_id']
        subnet_id = client.describe_instances(InstanceIds
       = [instance_id])['Reservations'][0]['Instances'][0]['SubnetId']
        route_table
       = client.describe_route_tables(
            Filters = [
               
       {
                    'Name': 'association.subnet-id',
                
          'Values': [
                        subnet_id
                    ]

                      }
            ]
        )
        
        if (len(route_table['RouteTables'])
       == 0):
            route_table = client.describe_route_tables(
        
              Filters = [
                    {
                        'Name':
       'association.main',
                        'Values': [
               
                   'true'
                        ]
                    }
   
                   ]
            )
        print ("[INFO] Verifying if Route table"
      , route_table['RouteTables'][0]['RouteTableId'], "of Instance has Internet
       Gateway ")
        all_routes = route_table['RouteTables'][0]['Routes']

              for route in all_routes:
            gateway_id = route.get('GatewayId',
       '')
            if gateway_id.startswith('igw-'):
                igw_present
       = 'True'
            else:
                igw_present = 'False'

   
       except ClientError as e:
        raise Exception ("[ERROR]",e)
    

          return {
        "PublicSubnet": igw_present
    }
"
  outputs:
  - Name: "IsSubnetPublic"
    Type: "String"
    Selector: "$.Payload.PublicSubnet"
- name: "verifySubnetIsPublicTestProvidedSubnet"
  action: "aws:executeScript"
  isCritical: true
  onFailure: "Abort"
  isEnd: true
  inputs:
    Runtime: "python3.8"
    Handler: "verifyIfSubnetIsPublic"
    InputPayload:
      instance_id: "{{launchTestInstanceProvidedSubnet.InstanceId}}"
    Script: "import boto3
import botocore
from botocore.exceptions import ClientError

      
def initiazlize_client(service):
    try:
        global client
      
        client = boto3.client(service)
    except ClientError as e:
        raise
       Exception ("[ERROR] Failed to initiazlie EC2 client",e)
    
def verifyIfSubnetIsPublic(event,
       context):
    initiazlize_client('ec2')
    try:
        instance_id =
       event['instance_id']
        subnet_id = client.describe_instances(InstanceIds
       = [instance_id])['Reservations'][0]['Instances'][0]['SubnetId']
        route_table
       = client.describe_route_tables(
            Filters = [
               
       {
                    'Name': 'association.subnet-id',
                
          'Values': [
                        subnet_id
                    ]

                      }
            ]
        )
        
        if (len(route_table['RouteTables'])
       == 0):
            route_table = client.describe_route_tables(
        
              Filters = [
                    {
                        'Name':
       'association.main',
                        'Values': [
               
                   'true'
                        ]
                    }
   
                   ]
            )
        print ("[INFO] Verifying if Route table"
      , route_table['RouteTables'][0]['RouteTableId'], "of Instance has Internet
       Gateway ")
        all_routes = route_table['RouteTables'][0]['Routes']

              for route in all_routes:
            gateway_id = route.get('GatewayId',
       '')
            if gateway_id.startswith('igw-'):
                igw_present
       = 'True'
            else:
                igw_present = 'False'

   
       except ClientError as e:
        raise Exception ("[ERROR]",e)
    

          return {
        "PublicSubnet": igw_present
    }
"
  outputs:
  - Name: "IsSubnetPublic"
    Type: "String"
    Selector: "$.Payload.PublicSubnet"
outputs:
- "getInstanceProperties.virtualizationType"
- "getInstanceProperties.rootDeviceType"
- "createAMIWithoutReboot.ImageId"
- "verifySecurityGroup.VerifiedSecurityGroupID"
- "getDefaultVPC.VpcId"
- "getSubnetIdDefaultVPC.subnetIdFromDefaultVpc"
- "launchTestInstanceDefaultVPC.InstanceIds"
- "launchTestInstanceDefaultVPC.InstanceStates"
- "launchTestInstanceProvidedSubnet.InstanceIds"
- "launchTestInstanceProvidedSubnet.InstanceStates"
- "createAMIAfterStoppingInstance.ImageId"
- "launchCutOverInstanceProvidedSubnet.InstanceIds"
- "launchCutOverInstanceProvidedSubnet.InstanceStates"
- "launchCutOverInstanceDefaultVPC.InstanceIds"
- "launchCutOverInstanceDefaultVPC.InstanceStates"
- "verifySubnetIsPublicTestDefaultVPC.IsSubnetPublic"
- "verifySubnetIsPublicTestProvidedSubnet.IsSubnetPublic"
