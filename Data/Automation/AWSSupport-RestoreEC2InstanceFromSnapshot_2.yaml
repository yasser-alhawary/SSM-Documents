description: "This runbook helps identifying working snapshot (if any) of an EC2 instance
   and restore the EC2 instance with this identified snapshot."
schemaVersion: "0.3"
assumeRole: "{{ AutomationAssumeRole }}"
outputs:
- "launchCloneInstance.InstanceIds"
- "ListSnapshotByDate.finalSnapshots"
- "ListSnapshotByDate.remainingSnapshotToBeCheckedInSameDateRange"
- "findWorkingSnapshot.workingSnapshot"
- "InstanceRecovery.result"
parameters:
  InstanceId:
    type: "String"
    description: "The Instance Id of the EC2 Instance you need to restore from Snapshot."
    allowedPattern: "^i-[a-z0-9]{8,17}$"
  SnapshotId:
    type: "String"
    description: "(Optional) If you already have a snapshot Id you want to restore
       from, you can enter it here."
    default: ""
    allowedPattern: "^$|^snap-[a-z0-9]{8,17}$"
  InplaceSwap:
    type: "Boolean"
    description: "(Optional) If you wish to replace new volume in your exisiting instance
       or launch a new instance."
  StartDate:
    type: "String"
    description: "(Optional) The Start date for which we need to look for snapshot."
    default: ""
    allowedPattern: "^$|^(19|20)dd[- /.](0[1-9]|1[012])[- /.](0[1-9]|[12][0-9]|3[01])$"
  EndDate:
    type: "String"
    description: "(Optional) The end date for which we need to look for snapshot."
    default: ""
    allowedPattern: "^$|^(19|20)dd[- /.](0[1-9]|1[012])[- /.](0[1-9]|[12][0-9]|3[01])$"
  LookForInstancetStatusCheck:
    description: " (Optional) To look for first instance status check failed in given
       time range in order to filter out snapshots more efficiently.  Default is
       set to ‘True’."
    type: "Boolean"
    default: true
  TotalSnapshotsToLook:
    type: "String"
    description: "(Optional) Determines how many snapshots automation will look in
       a single execution."
    default: ""
    allowedPattern: "^$|^[1-2]$"
  skipSnapshotsBy:
    type: "String"
    description: "(Optional) Number of snapshots to be skipped while looking. For
       example if there are 100 snapshots available in an input time range and 'skipSnapshotsBy'
       value is set to 2 then every third snapshot will be taken into consideration
       for execution."
    default: "0"
    allowedPattern: "^$|^[0-4]$"
  AutomationAssumeRole:
    type: "String"
    description: "(Optional) The Amazon Resource Name (ARN) of the AWS Identity and
       Access Management (IAM) role that allows Systems Manager Automation to perform
       the actions on your behalf. If no role is specified, Systems Manager Automation
       uses the permissions of the user that runs this document."
    default: ""
mainSteps:
- name: "describeInstance"
  action: "aws:executeAwsApi"
  outputs:
  - Name: "InstanceType"
    Selector: "$.Reservations[0].Instances[0].InstanceType"
    Type: "String"
  - Name: "AvailabilityZone"
    Selector: "$.Reservations[0].Instances[0].Placement.AvailabilityZone"
    Type: "String"
  - Name: "RootVolId"
    Selector: "$.Reservations[0].Instances[0].BlockDeviceMappings[0].Ebs.VolumeId"
    Type: "String"
  - Name: "SecurityGroupIds"
    Selector: "$.Reservations[0].Instances[0].SecurityGroups..GroupId"
    Type: "StringList"
  - Name: "KeyName"
    Selector: "$.Reservations[0].Instances[0].KeyName"
    Type: "String"
  - Name: "SubnetId"
    Selector: "$.Reservations[0].Instances[0].NetworkInterfaces[0].SubnetId"
    Type: "String"
  - Name: "rootDeviceName"
    Selector: "$.Reservations[0].Instances[0].RootDeviceName"
    Type: "String"
  - Name: "Platform"
    Selector: "$.Reservations[0].Instances[0].Platform"
    Type: "String"
  inputs:
    Service: "ec2"
    Api: "DescribeInstances"
    InstanceIds:
    - "{{ InstanceId }}"
  description: "describe the instance."
- name: "checkInstanceisNotTerminated"
  action: "aws:assertAwsResourceProperty"
  inputs:
    Service: "ec2"
    Api: "DescribeInstances"
    PropertySelector: "$.Reservations[0].Instances[0].State.Name"
    DesiredValues:
    - "running"
    - "stopped"
    InstanceIds:
    - "{{ InstanceId }}"
  description: "checks if the instance is available or not"
- name: "assertRootVolumeIsEbs"
  action: "aws:assertAwsResourceProperty"
  inputs:
    Service: "ec2"
    Api: "DescribeInstances"
    DesiredValues:
    - "ebs"
    PropertySelector: "$.Reservations[0].Instances[0].RootDeviceType"
    InstanceIds:
    - "{{ InstanceId }}"
  description: "check root vol is ebs"
- name: "checkForConcurrentExecution"
  action: "aws:assertAwsResourceProperty"
  inputs:
    Service: "ec2"
    Api: "DescribeTags"
    PropertySelector: "$.Tags"
    DesiredValues:
    - "[]"
    Filters:
    - Name: "resource-id"
      Values:
      - "{{ InstanceId}}"
    - Name: "key"
      Values:
      - "SSMExecutionStatusOn"
  description: "This will check if any other SSM documentation is running simultaneously
     at this moment."
- name: "AddTagsOnOriginalInstance"
  action: "aws:executeAwsApi"
  description: "This step adds tag on input instance which indicates that this instance
     is currently being used by SSM."
  inputs:
    Service: "ec2"
    Api: "CreateTags"
    Resources:
    - "{{InstanceId}}"
    Tags:
    - Key: "SSMExecutionStatusOn"
      Value: "Yes"
- name: "createImageWithNoReboot"
  action: "aws:executeAwsApi"
  inputs:
    Service: "ec2"
    Api: "CreateImage"
    InstanceId: "{{ InstanceId }}"
    Name: "AWSSupport_RestoreInstanceFromSnapshot-{{ automation:EXECUTION_ID }}"
  outputs:
  - Name: "ImageId"
    Selector: "$.ImageId"
    Type: "String"
  onCancel: "step:CleanResources"
- name: "describeOriginalInstanceImage"
  action: "aws:executeAwsApi"
  inputs:
    Service: "ec2"
    Api: "DescribeImages"
    Filters:
    - Name: "name"
      Values:
      - "AWSSupport_RestoreInstanceFromSnapshot-{{ automation:EXECUTION_ID }}"
  outputs:
  - Name: "ImageId"
    Selector: "$.Images[0].ImageId"
    Type: "String"
  onFailure: "step:CleanResources"
  onCancel: "step:CleanResources"
- name: "waitTillOriginalInstanceImageImageReady"
  action: "aws:waitForAwsResourceProperty"
  inputs:
    Service: "ec2"
    Api: "DescribeImages"
    DesiredValues:
    - "available"
    PropertySelector: "$.Images[0].State"
    ImageIds:
    - "{{ describeOriginalInstanceImage.ImageId }}"
  onFailure: "step:CleanResources"
  onCancel: "step:CleanResources"
- name: "launchCloneInstance"
  action: "aws:executeScript"
  inputs:
    Runtime: "python3.8"
    Handler: "launchCloneInstance"
    Script: "import json
import boto3
def launchCloneInstance(events, context):

        
    client = boto3.client(
        'ec2'
    )
    instanceId = ''

          InstanceIds = []
    try:
        runInstance = client.run_instances(

                          ImageId=events['ImageId'],
                    InstanceType=events['InstanceType'],

                          KeyName=events['KeyName'],
                    MaxCount=1,

                          MinCount=1,
                    SecurityGroupIds=
  
                          events['SecurityGroupIds']
                    ,
   
                       SubnetId=events['SubnetId'],
                    TagSpecifications=[

                              {
                            'ResourceType': 'instance',

                                  'Tags': [
                                {

                                          'Key': 'Name',
                      
                    'Value': 'AWSSupport-RestoreFromSnapshot'
                 
                     },
                            ]
                        },

                          ]
        )
        instanceId = runInstance['Instances'][0]['InstanceId']

              if instanceId:
            client.get_waiter('instance_running').wait(

                              InstanceIds=[
                                instanceId

                                      ],
                    
                
              WaiterConfig={
                            'Delay':30,
         
                         'MaxAttempts':30
                            }
      
                            )
            instanceStatus = client.describe_instances(

                                              InstanceIds=[
                   
                               instanceId
                                     
                     ]
                                    )
            if instanceStatus['Reservations'][0]['Instances'][0]['State']['Name']=='running':

                      print("Instance is running")
                InstanceIds.append(instanceId)

      
            

    except Exception as e:
                print('***Failed
       to launch the instance')
                print(type(e), ':', e) 
    

          return {'InstanceIds':InstanceIds, 'InstanceId':InstanceIds[0]}
"
    InputPayload:
      ImageId: "{{ describeOriginalInstanceImage.ImageId }}"
      InstanceType: "{{ describeInstance.InstanceType }}"
      SubnetId: "{{ describeInstance.SubnetId }}"
      KeyName: "{{ describeInstance.KeyName }}"
      SecurityGroupIds: "{{ describeInstance.SecurityGroupIds }}"
      AutomationId: "{{ automation:EXECUTION_ID }}"
  maxAttempts: 3
  nextStep: "waitTillInstanceIsReady"
  timeoutSeconds: 7200
  outputs:
  - Selector: "$.Payload.InstanceIds"
    Type: "StringList"
    Name: "InstanceIds"
  - Name: "InstanceId"
    Selector: "$.Payload.InstanceId"
    Type: "String"
  onFailure: "step:CleanResources"
  onCancel: "step:CleanResources"
- name: "waitTillInstanceIsReady"
  action: "aws:assertAwsResourceProperty"
  inputs:
    Service: "ec2"
    Api: "DescribeInstances"
    InstanceIds:
    - "{{ launchCloneInstance.InstanceIds }}"
    PropertySelector: "$.Reservations[0].Instances[0].State.Name"
    DesiredValues:
    - "running"
    - "stopped"
  maxAttempts: 3
  timeoutSeconds: 600
  onFailure: "step:CleanResources"
  nextStep: "getCloneInstance"
  onCancel: "step:CleanResources"
- name: "getCloneInstance"
  action: "aws:executeAwsApi"
  inputs:
    Service: "ec2"
    Api: "DescribeInstances"
    InstanceIds:
    - "{{launchCloneInstance.InstanceIds}}"
  outputs:
  - Name: "InstanceId"
    Selector: "$.Reservations[0].Instances[0].InstanceId"
    Type: "String"
  - Name: "availabilityZone"
    Selector: "$.Reservations[0].Instances[0].Placement.AvailabilityZone"
    Type: "String"
  - Name: "RootVolId"
    Selector: "$.Reservations[0].Instances[0].BlockDeviceMappings[0].Ebs.VolumeId"
    Type: "String"
  - Name: "rootDeviceName"
    Selector: "$.Reservations[0].Instances[0].RootDeviceName"
    Type: "String"
  onFailure: "step:CleanResources"
  onCancel: "step:CleanResources"
- name: "checkIfSnapshotIdProvided"
  action: "aws:branch"
  inputs:
    Choices:
    - NextStep: "ListSnapshotByDate"
      Variable: "{{SnapshotId}}"
      StringEquals: ""
    - NextStep: "createNewRootVolumeFromSnapshot"
      Variable: "{{SnapshotId}}"
      StartsWith: "snap-"
  description: "Check if we have to restore from a custom Snapshot-ID"
  onFailure: "step:CleanResources"
  onCancel: "step:CleanResources"
- name: "ListSnapshotByDate"
  action: "aws:executeScript"
  inputs:
    Runtime: "python3.8"
    Handler: "ListSnapshotByDate"
    Script: "import boto3
import json
import datetime
from datetime import datetime

      def ListSnapshotByDate(events, context):
                  volId= events["
      VolumeId"]
                  objList = [ ]
                  startDate =
       events["StartDate"]
                  endDate = events["EndDate"]
 
                       startDate += "T00:00:00+00:00"
                  endDate
       += "T23:59:00+00:00" 
                  skipSnapshotsBy = events["skipSnapshotsBy"
      ]
                  startDateDatetimeObj = datetime.strptime(startDate, '%Y/%m/%dT%H:%M:%S%z')

                        endDateDatetimeObj =  datetime.strptime(endDate, '%Y/%m/%dT%H:%M:%S%z')

                        checkInstanceStatus = events["CheckInstanceStatus"]
 
                       totalSnapshotsToLookFor = events["TotalSnapshotsToLook"
      ]
                  if totalSnapshotsToLookFor == '':
                   
        totalSnapshotsToLookFor= 10000
                  else: 
              
            totalSnapshotsToLookFor = int(totalSnapshotsToLookFor)
            
            client = boto3.client('ec2')
                  cwClient = boto3.client('cloudwatch')

                        response = client.describe_snapshots(
                 
                 Filters=[
                                {
                 
                         'Name': 'volume-id',
                                 
         'Values': [
                                        volId,
          
                                ]
                                },
         
                             {
                                    'Name': 'status',

                                          'Values': [
                         
                     'completed',
                                    ]
      
                                }
                            ]
              
                  )
                  for snap in response['Snapshots']:
     
                             obj = {'SnapID':snap['SnapshotId'], 'Date':snap['StartTime']}

                                  objList.append(obj)
                  objList
       = sorted(objList, key=lambda k: k['Date'], reverse=True)

             
           nonCorruptedSnapshots = []
                  for snap in objList:
 
                         snapshotId = (snap['SnapID'])
                    checkSnapStatus
       = client.describe_tags(
                                        Filters=[

                                                  {
                           
                           'Name': 'resource-id',
                             
                         'Values': [
                                          
                snapshotId,
                                                ]

                                                  },
                          
                        {
                                                'Name':
       'key',
                                                'Values': [
    
                                                      'corrupted',
            
                                          ]
                                   
               }
                                    ]
                       
                   
                                )
                    if checkSnapStatus['Tags']:

                              if checkSnapStatus['Tags'][0]['Value']=='yes':
  
                                    continue
                        else:
   
                               nonCorruptedSnapshots.append(snap)
             
             else:
                        nonCorruptedSnapshots.append(snap)

                        
                  objList = nonCorruptedSnapshots
   
                     
                  if checkInstanceStatus:
              
                    inputJson = [
                                          {

                                                    "Id": "e1",
           
                                         "Expression": "IF(m1>0, m1)",
    
                                                "Label": "Expression1"
    
                                            },
                                
                {
                                              "Id": "m1",

                                                    "MetricStat": {
         
                                               "Metric": {
                  
                                          "Namespace": "AWS/EC2",
         
                                                   "MetricName": "StatusCheckFailed"
      ,
                                                      "Dimensions": [

                                                                {
             
                                                       "Name": "InstanceId",

                                                                    "Value": events["
      InstanceId"]
                                                          }

                                                            ]
                 
                                       },
                                     
                   "Period": 3600,
                                          
              "Stat": "Average",
                                          
              "Unit": "Count"
                                             
       },
                                              "ReturnData": False

                                                }
                             
                   
                                      ]
                  
                instanceCheckFail = cwClient.get_metric_data(
                 
                                   MetricDataQueries=inputJson,
               
                                     StartTime=startDateDatetimeObj,
          
                                          EndTime=endDateDatetimeObj,
         
                                           ScanBy='TimestampAscending'
        
                                        )

                            statusFailTime
       = instanceCheckFail['MetricDataResults'][0]['Timestamps']
              
                    if statusFailTime:
                              endDateDatetimeObj
       = min(endDateDatetimeObj, statusFailTime[0])




                  testSnapshotIds
       = [] # This contains list of snapshots which will be tested.
           
             leftOutSnapshotIds = [] # This contains list of snapshots which will
       be not be tested in further steps this time
                  finalSnapshotIds
       = [] # This contains all snapshots which are relevent
                  

                        if skipSnapshotsBy > '0':
                      skipSnapshotsBy
       = int(skipSnapshotsBy) +1
                      objList = objList[::skipSnapshotsBy]

      
                  
                  for snap in objList:
             
               snapDate =  (snap['Date'])
                      if snapDate >= startDateDatetimeObj
       and snapDate <= endDateDatetimeObj:
                        finalSnapshotIds.append(snap['SnapID'])

                        
                  if events['Platform'] == 'windows':

                            totalSnapshotsToLookFor = min(totalSnapshotsToLookFor,
       2)
                      testSnapshotIds = finalSnapshotIds[0:totalSnapshotsToLookFor]

                            leftOutSnapshotIds = finalSnapshotIds[totalSnapshotsToLookFor:]

                        else:
                      totalSnapshotsToLookFor = min(totalSnapshotsToLookFor,
       2) # min snapshots for linux is also 2 at this stage because instance status
       check takes around 5 min and 12 min is hard cord limit for ssm run script,
       so more than 2 can't be tested for any platform. 
                      testSnapshotIds
       = finalSnapshotIds[0:totalSnapshotsToLookFor]
                      leftOutSnapshotIds
       = finalSnapshotIds[totalSnapshotsToLookFor:]
                  
       
                 return {'finalSnapshots': testSnapshotIds, 'leftOutSnapshotIds':
       leftOutSnapshotIds}
"
    InputPayload:
      VolumeId: "{{ describeInstance.RootVolId}}"
      StartDate: "{{StartDate}}"
      EndDate: "{{EndDate}}"
      Platform: "{{describeInstance.Platform}}"
      CheckInstanceStatus: "{{LookForInstancetStatusCheck}}"
      TotalSnapshotsToLook: "{{TotalSnapshotsToLook}}"
      InstanceId: "{{ InstanceId }}"
      skipSnapshotsBy: "{{ skipSnapshotsBy }}"
  description: "This will give the list of snapshots which were created later or on
     same date given by user"
  nextStep: "findWorkingSnapshot"
  outputs:
  - Name: "finalSnapshots"
    Selector: "$.Payload.finalSnapshots"
    Type: "StringList"
  - Name: "remainingSnapshotToBeCheckedInSameDateRange"
    Selector: "$.Payload.leftOutSnapshotIds"
    Type: "StringList"
  onFailure: "step:CleanResources"
  onCancel: "step:CleanResources"
- name: "createNewRootVolumeFromSnapshot"
  action: "aws:executeAwsApi"
  inputs:
    Service: "ec2"
    Api: "CreateVolume"
    AvailabilityZone: "{{getCloneInstance.availabilityZone }}"
    SnapshotId: "{{SnapshotId}}"
  outputs:
  - Name: "newRootVolumeId"
    Selector: "$.VolumeId"
    Type: "String"
  nextStep: "stopInstance"
  onFailure: "step:CleanResources"
  onCancel: "step:CleanResources"
- name: "stopInstance"
  action: "aws:executeAwsApi"
  inputs:
    Service: "ec2"
    Api: "StopInstances"
    InstanceIds:
    - "{{ launchCloneInstance.InstanceIds }}"
  nextStep: "verifyVolumeAvailability"
  onFailure: "step:CleanResources"
  onCancel: "step:CleanResources"
- name: "verifyVolumeAvailability"
  action: "aws:waitForAwsResourceProperty"
  inputs:
    Service: "ec2"
    Api: "DescribeVolumes"
    PropertySelector: "$.Volumes[0].State"
    DesiredValues:
    - "available"
    VolumeIds:
    - "{{ createNewRootVolumeFromSnapshot.newRootVolumeId }}"
  nextStep: "verifyInstanceStopped"
  onFailure: "step:CleanResources"
  onCancel: "step:CleanResources"
  maxAttempts: 3
- name: "verifyInstanceStopped"
  action: "aws:waitForAwsResourceProperty"
  inputs:
    Service: "ec2"
    DesiredValues:
    - "stopped"
    Api: "DescribeInstances"
    PropertySelector: "$.Reservations[0].Instances[0].State.Name"
    InstanceIds:
    - "{{ launchCloneInstance.InstanceIds }}"
  nextStep: "detachRootVolume"
  onFailure: "step:CleanResources"
  onCancel: "step:CleanResources"
- name: "detachRootVolume"
  action: "aws:executeAwsApi"
  inputs:
    Service: "ec2"
    Api: "DetachVolume"
    VolumeId: "{{ getCloneInstance.RootVolId}}"
  nextStep: "verifyRootVolumeDetached"
  onFailure: "step:CleanResources"
  onCancel: "step:CleanResources"
  maxAttempts: 3
  timeoutSeconds: 3
- name: "verifyRootVolumeDetached"
  action: "aws:waitForAwsResourceProperty"
  inputs:
    Service: "ec2"
    Api: "DescribeVolumes"
    PropertySelector: "$.Volumes[0].State"
    DesiredValues:
    - "available"
    VolumeIds:
    - "{{getCloneInstance.RootVolId}}"
  timeoutSeconds: 30
  nextStep: "attachNewRootVolume"
  onFailure: "step:CleanResources"
  onCancel: "step:CleanResources"
  maxAttempts: 3
- name: "attachNewRootVolume"
  action: "aws:executeAwsApi"
  inputs:
    Service: "ec2"
    Api: "AttachVolume"
    Device: "{{ getCloneInstance.rootDeviceName }}"
    VolumeId: "{{ createNewRootVolumeFromSnapshot.newRootVolumeId }}"
    InstanceId: "{{ launchCloneInstance.InstanceId }}"
  nextStep: "verifyNewRootVolumeAttached"
  onFailure: "step:CleanResources"
  onCancel: "step:CleanResources"
- name: "verifyNewRootVolumeAttached"
  action: "aws:waitForAwsResourceProperty"
  inputs:
    Service: "ec2"
    Api: "DescribeVolumes"
    PropertySelector: "$.Volumes[0].Attachments[0].State"
    DesiredValues:
    - "attached"
    VolumeIds:
    - "{{ createNewRootVolumeFromSnapshot.newRootVolumeId }}"
  timeoutSeconds: 30
  nextStep: "startInstance"
  onFailure: "step:CleanResources"
  onCancel: "step:CleanResources"
  maxAttempts: 3
- name: "startInstance"
  action: "aws:executeAwsApi"
  inputs:
    Service: "ec2"
    Api: "StartInstances"
    InstanceIds:
    - "{{ launchCloneInstance.InstanceIds }}"
  outputs:
  - Name: "InstanceState"
    Selector: "$.StartingInstances[0].CurrentState.Name"
    Type: "String"
  nextStep: "InstanceStatusCheck"
  timeoutSeconds: 180
  onFailure: "step:CleanResources"
  onCancel: "step:CleanResources"
- name: "InstanceStatusCheck"
  action: "aws:waitForAwsResourceProperty"
  inputs:
    PropertySelector: "$.Reservations[0].Instances[0].State.Name"
    Service: "ec2"
    Api: "DescribeInstances"
    DesiredValues:
    - "running"
    InstanceIds: "{{launchCloneInstance.InstanceIds}}"
  nextStep: "InstanceHealthCheck"
  maxAttempts: 3
  timeoutSeconds: 300
  onFailure: "step:CleanResources"
  onCancel: "step:CleanResources"
- name: "InstanceHealthCheck"
  action: "aws:waitForAwsResourceProperty"
  inputs:
    Api: "DescribeInstanceStatus"
    PropertySelector: "$.InstanceStatuses[0].InstanceStatus.Details[0].Status"
    DesiredValues:
    - "passed"
    Service: "ec2"
    InstanceIds: "{{launchCloneInstance.InstanceIds}}"
  description: "Check if both System status checks and Instance status checks gets
     passed."
  onFailure: "step:CleanResources"
  timeoutSeconds: 420
  nextStep: "InstanceRecovery"
  onCancel: "step:CleanResources"
- name: "findWorkingSnapshot"
  action: "aws:executeScript"
  inputs:
    Runtime: "python3.8"
    Handler: "findWorkingSnapshot"
    Script: "import json
import boto3
import time
import botocore
import botocore.exceptions

      import sys
def findWorkingSnapshot(event, context):
    client = boto3.client(

              'ec2'
    )
    snapshots= event['Snapshots']
    workingSnapFound
       = False
    workingSnap =''
    for snap in snapshots:
        checkSnapStatus
       = client.describe_tags(
                Filters=[
                    {

                              'Name': 'resource-id',
                        'Values':
       [
                            snap,
                        ]
        
                  },
                    {
                        'Name': 'key',

                              'Values': [
                            'corrupted',

                              ]
                    }
                ]
     
                 
            )
        
        if checkSnapStatus['Tags']:

                  if checkSnapStatus['Tags'][0]['Value']=='yes':
              
        continue
            elif checkSnapStatus['Tags'][0]['Value']=='no':
 
                     workingSnapFound = True
                workingSnap = snap

                      break
        
        volumeId = ''
        
        try:

                  response = client.create_volume(
                AvailabilityZone=event['AvailabilityZone'],

                      SnapshotId=snap)
            
            if response['ResponseMetadata']['HTTPStatusCode']==
       200:
                volumeId= response['VolumeId']
                print('***volume:',
       volumeId)
            
            client.get_waiter('volume_available').wait(

                      VolumeIds=[volumeId],
                WaiterConfig={
   
                       'Delay': 10,
                    'MaxAttempts': 12
    
                  
                }
            )
            print('***Success!!
       volume:', volumeId, 'created...')
            
            
          
            
                    
        except Exception as e:
            
          print('***Failed to create the volume...')
                print(type(e),
       ':', e)
                continue
            
        
        if volumeId:

                  try:
                stopInstance = client.stop_instances(
 
                         InstanceIds=[
                            event['InstanceId'][0]

                                      ]
                )
                
  
                    if stopInstance['ResponseMetadata']['HTTPStatusCode']== 200:

                              client.get_waiter('instance_stopped').wait(
     
                         InstanceIds=[
                            event['InstanceId'][0]

                                      ],
                    
                
              WaiterConfig={
                            'Delay': 10,
        
                          'MaxAttempts': 40
                            }
    
                      )
                        print ("Instance is stopped")

                      
        
            except Exception as e:
          
            print('***Failed to stop the instance...')
                print(type(e),
       ':', e)
                continue
        
        try:
            

                  describeInstance = client.describe_instances(
               
                       InstanceIds=[
                                    event['InstanceId'][0],

                                      ]
                                )
    
              rootVolId = describeInstance['Reservations'][0]['Instances'][0]['BlockDeviceMappings'][0]['Ebs']['VolumeId']

      
            deviceName = describeInstance['Reservations'][0]['Instances'][0]['BlockDeviceMappings'][0]['DeviceName']

      
            
            if deviceName == event['DeviceId'] and rootVolId.startswith("
      vol"):
                    response = client.detach_volume(
            
                          VolumeId= rootVolId )
                    if response['ResponseMetadata']['HTTPStatusCode']
       == 200:
                        print( "***Success**" + "detaching root
       volume")
                        client.get_waiter('volume_available').wait(

                                      VolumeIds=[
                             
             rootVolId
                                        ],
            
                          
                                WaiterConfig={
    
                                      'Delay': 10,
                            
              'MaxAttempts':12
                                    }
         
                         )
                        
                        VolumeStatus
       = client.describe_volumes(
                                            VolumeIds=[rootVolId]

                              )
                        
                     
         if VolumeStatus['Volumes'][0]['State'] == 'available':
               
                   print ("Volume detached")
                        else:
 
                                 print ("Volume Not Detached")
              
        
                
        except Exception as e:
                print('***Failed
       to detached the volume')
                print(type(e), ':', e)
       
               continue
        
        
        try:
            response =
       client.attach_volume(
                        Device=event['DeviceId'],

                              InstanceId=
                            event['InstanceId'][0]

                                      ,
                        VolumeId=volumeId

                              )
            
            if response['ResponseMetadata']['HTTPStatusCode']
       == 200:
                
                print( "***Success***" + "attaching
       root volume")
                client.get_waiter('volume_in_use').wait(

                              VolumeIds=[
                                volumeId

                                      ],
                        
            
                  WaiterConfig={
                            'Delay': 10,
    
                              'MaxAttempts':20
                            }
 
                         )
                VolumeStatus = client.describe_volumes(

                                          VolumeIds=[volumeId]
                )

                      if VolumeStatus['Volumes'][0]['Attachments'][0]['State'] ==
       'attached':
                    print ("Volume is attached")
        
              
        
                
        except Exception as e:
    
                  print('***Failed to attach the volume')
                print(type(e),
       ':', e)
                continue    
                
        try:
  
                response = client.start_instances(
                    InstanceIds=[event['InstanceId'][0]]

                              )
            
            if response['ResponseMetadata']['HTTPStatusCode']==
       200:
                        client.get_waiter('instance_running').wait(

                              InstanceIds=[
                            event['InstanceId'][0]

                                      ],
                    
                
              WaiterConfig={
                            'Delay': 10,
        
                          'MaxAttempts':30
                            }
     
                             )
                        
                      
        client.get_waiter('instance_status_ok').wait(
                         
         InstanceIds=[
                            event['InstanceId'][0]
    
                                  ],
                    
                    
          WaiterConfig={
                            'Delay': 10,
            
                      'MaxAttempts':26
                            }
         
                         
                            )
                      
        instanceStatus = client.describe_instance_status(
                     
                         InstanceIds=[
                                        
          event['InstanceId'][0]
                                              
            ]
                                    )
                        

                              
                        if instanceStatus['InstanceStatuses'][0]['InstanceStatus']['Status']=='ok'
       and instanceStatus['InstanceStatuses'][0]['SystemStatus']['Status']=='ok':

                                      print ("Instance Passed")
             
                         workingSnap = snap
                                workingSnapFound
       = True
                                client.create_tags(
    
      
                                        Resources=[
                           
                       snap,
                                        ],
      
                                        Tags=[
                                
                  {
                                                'Key': 'corrupted',

                                                      'Value': 'no'
           
                                       },
                                     
         ]
                                    )
                             
         break
                                
                        else:

                                  client.create_tags(
    
                   
                           Resources=[
                                        
          snap,
                                        ],
                   
                           Tags=[
                                            {

                                                      'Key': 'corrupted',
     
                                                 'Value': 'yes'
               
                                   },
                                        ]

                                          )
                            continue

                                      
                        
        except
       botocore.exceptions.WaiterError  as waiterr:
            print("***Failed
       to reach out to the instance. Status check is getting timed out")
     
             workingSnap = "No working instance found, getting instance check timed
       out, please check is separately or look for further snapshots"
        
          print(type(waiterr), ':', waiterr)
            client.create_tags(
 
         
                                        Resources=[
                
                                  snap,
                                       
       ],
                                        Tags=[
                     
                             {
                                                'Key':
       'corrupted',
                                                'Value': 'yes'

                                                  },
                          
                    ]
                                    )                
  
            except Exception as e:
                print('***Failed to Start the
       Instance')
                print(type(e), ':', e)
                client.create_tags(

          
                                        Resources=[
               
                                   snap,
                                      
        ],
                                        Tags=[
                    
                              {
                                               
       'Key': 'corrupted',
                                                'Value':
       'yes'
                                            },
                  
                            ]
                                    )
          
            continue         
        
            
            
           
       
        
          
        
    return {'workingSnap':workingSnap}
"
    InputPayload:
      Snapshots: "{{ListSnapshotByDate.finalSnapshots}}"
      DeviceId: "{{getCloneInstance.rootDeviceName}}"
      VolumeId: "{{getCloneInstance.RootVolId}}"
      InstanceId: "{{launchCloneInstance.InstanceIds}}"
      AvailabilityZone: "{{describeInstance.AvailabilityZone}}"
  outputs:
  - Name: "workingSnapshot"
    Selector: "$.Payload.workingSnap"
    Type: "String"
  nextStep: "InstanceRecovery"
  timeoutSeconds: 1200
  onFailure: "step:CleanResources"
  onCancel: "step:CleanResources"
- name: "InstanceRecovery"
  action: "aws:executeScript"
  inputs:
    Runtime: "python3.8"
    Handler: "InstanceRecovery"
    Script: "import json
import boto3
import sys
import botocore
import botocore.exceptions

      
def InstanceRecovery(event, context):
  client = boto3.client(
        'ec2'

          )
  inplaceSwap = event['InplaceSwap']
  snapshotId = event['SnapShotId']

        workingSnapshot = event['WorkingSnapshot']
  result = ''
  
  if inplaceSwap
       == True:
            
        if snapshotId =='':

                if
       workingSnapshot:
                    volumeId = ''
            
      
                    try:
                        response = client.create_volume(

                                  AvailabilityZone=event['AvailabilityZone'],
 
                                 SnapshotId=workingSnapshot)
                  
            
                        if response['ResponseMetadata']['HTTPStatusCode']==
       200:
                            volumeId= response['VolumeId']
       
                           print('***volume:', volumeId)
                      
        
                        client.get_waiter('volume_available').wait(
 
                                 VolumeIds=[volumeId],
                        
          WaiterConfig={
                                'Delay': 10,
        
                              'MaxAttempts': 12
                            
 
                                 }
                        )
                 
             print('***Success!! volume:', volumeId, 'created...')
            
                  
                        
                            
    
                                  
                    except Exception as e:

                                  print('***Failed to create the volume...')
  
                                print(type(e), ':', e)
                        

                          
                    if volumeId:
                  
            try:
                            stopInstance = client.stop_instances(

                                      InstanceIds=[
                           
                   event['InstanceId']
                                        
          ]
                            )
                            
      
                            if stopInstance['ResponseMetadata']['HTTPStatusCode']==
       200:
                                    client.get_waiter('instance_stopped').wait(

                                          InstanceIds=[
                       
                       event['InstanceId']
                                    
              ],
                                
                            
              WaiterConfig={
                                        'Delay': 10,

                                              'MaxAttempts': 40
               
                               }
                                )
           
                               print ("Instance is stopped")
                
                  
                    
                        except Exception
       as e:
                            print('***Failed to stop the instance...')

                                  print(type(e), ':', e)
                    

                          try:
                        response = client.detach_volume(

                                          VolumeId= event['VolumeId'] )
       
                       if response['ResponseMetadata']['HTTPStatusCode'] == 200:

                                  print( "**Success**" + "detaching root volume"
      )
                            client.get_waiter('volume_available').wait(

                                          VolumeIds=[
                         
                     event['VolumeId']
                                        
          ],
                                    
                            
              WaiterConfig={
                                        'Delay': 10,

                                              'MaxAttempts':12
                
                              }
                                )
            
                      
                            volumeStatus = client.describe_volumes(

                                                      VolumeIds=[event['VolumeId']]

                                  )
                            
             
                     if volumeStatus['Volumes'][0]['State'] == 'available':
   
                                   print ("Volume detached")
                
                  else:
                                print ("Volume Not Detached"
      )
                            
                            
            
              except Exception as e:
                            print('***Failed
       to detached the volume')
                            print(type(e), ':',
       e)
                            
                    
                 
         
                    try:
                        response = client.attach_volume(

                                          Device=event['DeviceId'],
           
                               InstanceId=
                                    
          event['InstanceId']
                                            ,
  
                                        VolumeId=volumeId
                     
                     )
                        
                        if response['ResponseMetadata']['HTTPStatusCode']
       == 200:
                            
                            print(
       "***" + "ataching root volume")
                            client.get_waiter('volume_in_use').wait(

                                          VolumeIds=[
                         
                         volumeId
                                            ],

                                          
                                    WaiterConfig={

                                              'Delay': 10,
                    
                          'MaxAttempts':12
                                    
          }
                                )
                            volumeStatus
       = client.describe_volumes(
                                             
         VolumeIds=[volumeId]
                            )
                  
                if volumeStatus['Volumes'][0]['Attachments'][0]['State'] == 'attached':

                                      print ("Volume is attached")
          
                        
                    
                            
  
                        except Exception as e:
                            print('***Failed
       to attach the volume')
                            print(type(e), ':', e)

                                
                            
                
          try:
                        response = client.start_instances(
    
                                  InstanceIds=[event['InstanceId']]
           
                               )
                        
                    
          if response['ResponseMetadata']['HTTPStatusCode']== 200:
            
                              client.get_waiter('instance_running').wait(
     
                                     InstanceIds=[
                            
                  event['InstanceId']
                                         
         ],
                                
                                 
         WaiterConfig={
                                        'Delay': 10,
 
                                             'MaxAttempts':30
                 
                             }
                                        )
     
                                     
                                    client.get_waiter('instance_status_ok').wait(

                                                  InstanceIds=[
               
                                       event['InstanceId']
                    
                                      ],
                                      
        
                                            WaiterConfig={
          
                                            'Delay': 10,
                      
                                'MaxAttempts':40
                              
                        }
                                                )
  
                                        instanceStatus = client.describe_instance_status(

                                                          InstanceIds=[
       
                                                       event['InstanceId']
    
                                                                  ]
           
                                           )
                                  
        
                                    
                                
          if instanceStatus['InstanceStatuses'][0]['InstanceStatus']['Status']=='ok'
       and instanceStatus['InstanceStatuses'][0]['SystemStatus']['Status']=='ok':

                                                  print ("Instance Passed")
 
                                                 result += "Instance status Passed
       and inplace swap is done"
                                            

                                                  
                            
              else:
                                        print ("Instance status
       failed")
                                        result += "Instance status
       failed"
                                            
                 
                         
                    except botocore.exceptions.WaiterError
        as waiterr:
                            print("***Failed to reach out to
       the instance. Status check is getting timed out")
                     
             print(type(waiterr), ':', waiterr)  
                            result
       += "Instance status check Timed out"            
                    except
       Exception as e:
                            print('***Failed to Start the
       Instance')
                            print(type(e), ':', e)
         
                         result += "Instance status failed"      
           
       
                         
                else:
                     
          print ("No working snapshot is available")
                        
       result += "No working snapshot is available"
                 
      
                
            
        else:
                
               
               volumeId = ''
        
                        try:
          
                        response = client.create_volume(
                      
                AvailabilityZone=event['AvailabilityZone'],
                   
                   SnapshotId=snapshotId)
                            
       
                           if response['ResponseMetadata']['HTTPStatusCode']== 200:

                                      volumeId= response['VolumeId']
          
                            print('***volume:', volumeId)
                     
             
                            client.get_waiter('volume_available').wait(

                                      VolumeIds=[volumeId],
                   
                   WaiterConfig={
                                    'Delay': 10,

                                          'MaxAttempts': 12
                   
                   
                                }
                        
          )
                            print('***Success!! volume:', volumeId,
       'created...')
                            
                            

                                      
                                    
  
                            except Exception as e:
                            
          print('***Failed to create the volume...')
                          
            print(type(e), ':', e)
                                
          
                        
                        
                        if volumeId:

                                  try:
                                stopInstance
       = client.stop_instances(
                                    InstanceIds=[

                                                  event['InstanceId']
         
                                             ]
                                )

                                      
                                if stopInstance['ResponseMetadata']['HTTPStatusCode']==
       200:
                                        client.get_waiter('instance_stopped').wait(

                                              InstanceIds=[
                   
                               event['InstanceId']
                            
                          ],
                                    
            
                                  WaiterConfig={
                              
                    'Delay': 10,
                                            'MaxAttempts':
       30
                                            }
                      
                    )
                                        print ("Instance
       is stopped")
                                
                        

                                  except Exception as e:
                      
                print('***Failed to stop the instance...')
                    
                  print(type(e), ':', e)
                            
        
                      
                        try:
                          
        response = client.detach_volume(
                                      
        VolumeId= event['VolumeId'] )
                            if response['ResponseMetadata']['HTTPStatusCode']
       == 200:
                                print( "***" + "detaching root
       volume")
                                client.get_waiter('volume_available').wait(

                                              VolumeIds=[
                     
                             event['VolumeId']
                                
                      ],
                                        
            
                                  WaiterConfig={
                              
                    'Delay': 10,
                                            'MaxAttempts':12

                                                  }
                           
               )
                                
                            
          volumeStatus = client.describe_volumes(
                             
                             VolumeIds=[event['VolumeId']]
                    
                  )
                                
                         
             if volumeStatus['Volumes'][0]['State'] == 'available':
           
                               print ("Volume detached")
                    
                  else:
                                    print ("Volume Not
       Detached")
                                
                          
            
                        except Exception as e:
                  
                    print('***Failed to detached the volume')
                 
                     print(type(e), ':', e)
                                
 
                             
                        
                       
       try:
                            response = client.attach_volume(
     
                                         Device=event['DeviceId'],
            
                                  InstanceId=
                                 
                 event['InstanceId']
                                          
            ,
                                        VolumeId=volumeId
      
                                        )
                            
       
                           if response['ResponseMetadata']['HTTPStatusCode'] == 200:

                                      
                                print( "
      **" + "ataching root volume")
                                client.get_waiter('volume_in_use').wait(

                                              VolumeIds=[
                     
                                 volumeId
                                     
                 ],
                                        
                 
                             WaiterConfig={
                                   
               'Delay': 10,
                                            'MaxAttempts':6

                                                  }
                           
               )
                                volumeStatus = client.describe_volumes(

                                                          VolumeIds=[volumeId]

                                      )
                                if volumeStatus['Volumes'][0]['Attachments'][0]['State']
       == 'attached':
                                    print ("Volume is attached"
      )
                                
                        
            
                          
                        except Exception as e:
    
                                  print('***Failed to attach the volume')
     
                                 print(type(e), ':', e)
                       
                  
                                
                        try:

                                  response = client.start_instances(
          
                                InstanceIds=[event['InstanceId']]
             
                                 )
                            
              
                    if response['ResponseMetadata']['HTTPStatusCode']== 200:
  
                                            client.get_waiter('instance_running').wait(

                                              InstanceIds=[
                   
                               event['InstanceId']
                            
                          ],
                                    
            
                                  WaiterConfig={
                              
                    'Delay': 10,
                                            'MaxAttempts':30

                                                  }
                           
                       )
                                        print ("Instance
       is running")
                                        client.get_waiter('instance_status_ok').wait(

                                              InstanceIds=[
                   
                               event['InstanceId']
                            
                          ],
                                    
            
                                  WaiterConfig={
                              
                    'Delay': 10,
                                            'MaxAttempts':40

                                                  }
                           
                       )
                                        instanceStatus
       = client.describe_instance_status(
                                     
                         InstanceIds=[
                                        
                          event['InstanceId']
                                 
                                         ]
                                    
                      )
                                        
             
                                 
                                        if instanceStatus['InstanceStatuses'][0]['InstanceStatus']['Status']=='ok'
       and instanceStatus['InstanceStatuses'][0]['SystemStatus']['Status']=='ok':

                                                      print ("Instance Passed and
       inplace swap is done")
                                                result
       += "Instance Passed and inplace swap is done"
                        
                              
                                                

                                              else:
                           
                       print ("Instance status failed")
                     
                             result += "Instance status failed"
             
                                         
                                     
         
                        except botocore.exceptions.WaiterError  as waiterr:

                                  print("***Failed to reach out to the instance.
       Status check is getting timed out")
                            print(type(waiterr),
       ':', waiterr)
                            result += "Instance status check
       Timed out"               
                        except Exception as e:

                                      print('***Failed to Start the Instance')

                                      print(type(e), ':', e)
                  
                    result += "Instance status failed"
        
        try:

                  response = client.terminate_instances(
                      
            InstanceIds=[
                                event['CloneInstanceId'][0]])

              except Exception as terminateFailed:
                print('***Instance
       Termination failed')
                print(type(terminateFailed), ':', terminateFailed)

      
         
  else:
                if snapshotId:
                    print
       ("working Instance", event['CloneInstanceId'][0])
                    result
       += "working Instance" + event['CloneInstanceId'][0]
                  
        
                else:
                    if workingSnapshot:
      
                        print ("working Instance", event['CloneInstanceId'][0])

                              result += "working Instance" + event['CloneInstanceId'][0]

                          else:
                        print ("Instance recovery
       cannot happen as it does not have working snapshot")
                  
            result += "Instance recovery cannot happen as it does not have working
       snapshot"
                
    
        
  return {'result':result}
"
    InputPayload:
      InplaceSwap: "{{InplaceSwap}}"
      SnapShotId: "{{SnapshotId}}"
      CloneInstanceId: "{{launchCloneInstance.InstanceIds}}"
      DeviceId: "{{getCloneInstance.rootDeviceName}}"
      AvailabilityZone: "{{describeInstance.AvailabilityZone}}"
      VolumeId: "{{describeInstance.RootVolId}}"
      InstanceId: "{{ InstanceId }}"
      WorkingSnapshot: "{{ findWorkingSnapshot.workingSnapshot}}"
  onFailure: "step:CleanResources"
  outputs:
  - Name: "result"
    Selector: "$.Payload.result"
    Type: "String"
  onCancel: "step:CleanResources"
- name: "CleanResources"
  action: "aws:executeScript"
  description: "This will clean all the additional resources which were created by
     SSM document during execution."
  inputs:
    Runtime: "python3.8"
    Handler: "CleanResources"
    Script: "import json
import boto3
def CleanResources(events, context):
  

        client = boto3.client(
        'ec2'
    )
  
  try:
    client.delete_tags(

          Resources = [
        events['InstanceId']
    ],
    Tags = [
   
           {
            'Key': 'SSMExecutionStatusOn',
            'Value': 'Yes'

              }
    ]
  )
    if events['ImageId'].startswith("ami"):
    
        checkImageStatus =  client.describe_images(
        Filters=[
        
          {
                'Name': 'name',
                'Values': [
     
                     events['TagValue']
                ]
            }
     
         ],
        ImageIds=[
            events['ImageId']
        ]
    )

            if checkImageStatus['Images'] !='':
                try:
         
               response = client.deregister_image(
                            
       ImageId=events['ImageId']
                             )

            
          except Exception as e:
                  print('***Failed to deregister
       the image.')
                  print(type(e), ':', e)

  except Exception
       as e:
                print('***Failed to delete the tags')
           
           print(type(e), ':', e)
  
  if events['CloneInstanceId'][0].startswith("
      i-"):
    if events['CloneInstanceId'][0] and events['InplaceSwap'] :
  
              try:
            client.terminate_instances(
                   
                   InstanceIds=[
                                    events['CloneInstanceId'][0]])

                except Exception as e:
                  print('***Failed to terminate
       the instance.')
                  print(type(e), ':', e)
  return 0
"
    InputPayload:
      InstanceId: "{{InstanceId }}"
      ImageId: "{{ describeOriginalInstanceImage.ImageId }}"
      CloneInstanceId: "{{launchCloneInstance.InstanceIds }}"
      TagValue: "AWSSupport_RestoreInstanceFromSnapshot-{{ automation:EXECUTION_ID
         }}"
      InplaceSwap: "{{InplaceSwap}}"
