description: "# AWSSupport-TroubleshootManagedInstance
---
This automation document
   checks if the instance meets the prerequisites for EC2 Instances to come up as
   SSM Managed Instances. This documents runs checks related to VPC configuration
   like security group rules, VPC endpoints, Network ACL configuration,Route table
   and if IAM role is attached or not.  At the last, it shares information about
   SSM Agent troubleshooting kit which can be downloaded and run on the instances
   to check OS level issues in related to SSM agent. Supports both Windows and Linux.

  
---

### **Parameters**
1.  **InstanceId**:

Type: StringList

Description:
   **(Required)** Provide the Instance Id. (e.g. i-05fa91429c6cdcb49)

2.  **AutomationAssumeRole**:

  
Type: String

Description: **(Optional)** The ARN of the role that allows Automation
   to perform the actions on your behalf. If no role is specified, this document
   will use the permissions of the user that executes this document.

"
schemaVersion: "0.3"
outputs:
- "FinalOutput.output"
- "InstanceisOnline.output"
assumeRole: "{{ AutomationAssumeRole }}"
parameters:
  InstanceId:
    type: "String"
    description: "(Required) Provide the Instance Id. (e.g. i-07330aca1eb7fecc6 )"
    allowedPattern: "^[i]{0,1}-[a-z0-9]{8,17}$"
  AutomationAssumeRole:
    type: "String"
    description: "(Optional)The ARN of the role that allows Automation to perform
       the actions on your behalf. If no role is specified,this document will use
       the permissions of the user that executes this document."
    allowedPattern: "^$|^arn:aws:iam::[0-9]*:role/[/w+=,.@-]+$"
    default: ""
mainSteps:
- name: "GetPingStatus"
  action: "aws:executeAwsApi"
  onFailure: "Abort"
  nextStep: "IsInstanceAlreadyOnline"
  inputs:
    Service: "ssm"
    Api: "DescribeInstanceInformation"
    Filters:
    - Key: "InstanceIds"
      Values:
      - "{{ InstanceId }}"
  outputs:
  - Name: "pingstatus"
    Selector: "$.InstanceInformationList[0].PingStatus"
    Type: "String"
- name: "IsInstanceAlreadyOnline"
  action: "aws:branch"
  onFailure: "Abort"
  isCritical: "true"
  inputs:
    Choices:
    - NextStep: "GetEC2InstanceProperties"
      Not:
        Variable: "{{ GetPingStatus.pingstatus }}"
        StringEquals: "Online"
    Default: "InstanceisOnline"
- name: "GetEC2InstanceProperties"
  action: "aws:executeAwsApi"
  maxAttempts: 2
  onFailure: "Abort"
  inputs:
    Service: "ec2"
    Api: "DescribeInstances"
    InstanceIds:
    - "{{ InstanceId }}"
  outputs:
  - Name: "SecurityGroupIds"
    Selector: "$.Reservations[0].Instances[0].SecurityGroups..GroupId"
    Type: "StringList"
  - Name: "SubnetId"
    Selector: "$.Reservations[0].Instances[0].SubnetId"
    Type: "String"
  - Name: "VpcId"
    Selector: "$.Reservations[0].Instances[0].VpcId"
    Type: "String"
  - Name: "PrivateIpAddress"
    Selector: "$.Reservations[0].Instances[0].NetworkInterfaces[0].PrivateIpAddresses[0].PrivateIpAddress"
    Type: "String"
  - Name: "InstanceProfile"
    Selector: "$.Reservations[0].Instances[0].IamInstanceProfile.Arn"
    Type: "String"
  - Name: "platform"
    Selector: "$.Reservations[0].Instances[0].Platform"
    Type: "String"
  nextStep: "CheckVpcEndpoint"
- name: "CheckVpcEndpoint"
  action: "aws:executeScript"
  onFailure: "Abort"
  nextStep: "CheckRouteTable"
  inputs:
    Runtime: "python3.8"
    Handler: "script_handler"
    InputPayload:
      GetInstance: "{{InstanceId}}"
      InstanceSGList: "{{GetEC2InstanceProperties.SecurityGroupIds}}"
      EC2InstanceIPs: "{{ GetEC2InstanceProperties.PrivateIpAddress }}"
      EC2InstanceSubnet: "{{ GetEC2InstanceProperties.SubnetId }}"
      EC2VPC: "{{ GetEC2InstanceProperties.VpcId}}"
    Script: "def script_handler(events, context):
    import boto3
    import ipaddress

          from ipaddress import ip_network,ip_address
    from botocore.exceptions
       import ClientError,ParamValidationError
    
    #Getting current region

          current_session = boto3.session.Session()
    current_region = current_session.region_name

          ssm_url = 'com.amazonaws.' + current_region + '.ssm'
    
    #Getting
       Instance Information#
    Instance = events['GetInstance']
    instance_security_groups
       = events['InstanceSGList']
    subnetdetails = events['EC2InstanceSubnet']

          instance_priv_ip = events['EC2InstanceIPs']
    VPCdetails = events['EC2VPC']

      
    https_port = 443
    Results = ""
    AWS_SG_DOC = '
 For reference,
       Working with security groups - https://docs.aws.amazon.com/vpc/latest/userguide/VPC_SecurityGroups.html#WorkingWithSecurityGroups
      n
'
    AWS_VPCE_DOC = '
 For reference, Modifying an Interface endpoint
       -  https://docs.aws.amazon.com/vpc/latest/userguide/vpce-interface.html#create-interface-endpoint
      n
'

    
    vpce_security_groups = []
    ec2 = boto3.client('ec2')

          try:
       results = ec2.describe_vpc_endpoints(Filters=[{'Name':'service-name','Values':[ssm_url]},{'Name':'vpc-id','Values':[VPCdetails]}])

             if not results['VpcEndpoints']:
        return {'output': '1. Checking
       for VPC Endpoints for SSM: 

' + ' No VPC endpoints for SSM available
       found for the same VPC as of the Instance: ' + VPCdetails + '. Instance can
       still connect to SSM Endoints if correct routes and NACL rules are configured
       to reach the ssm endpoints.

', 'vpceid': "Absent" }
       else:

              print(' ')
        print('VPC endpoint exist for the SSM service.
       Checking details of the vpc endpoint. ')
        for items in results['VpcEndpoints']:

               vpce_id = items['VpcEndpointId']
         vpce_subnet = items['SubnetIds']

               vpce_priv_dns = items['PrivateDnsEnabled']
         allsg = items['Groups']

               for vpcesg in allsg:
          VpceSecurityGroupsdetails = vpcesg['GroupId']

                vpce_security_groups.append(VpceSecurityGroupsdetails)
    except
       ClientError as e:
        raise Exception ("[ERROR]",e)
        
   
       list_vpce_security_groups = ','.join(vpce_security_groups)
    list_vpce_subnet
       = ','.join(vpce_subnet)
    
    
    Heading = '1. Checking for VPC Endpoints:
       

'
    Found = ' VPC endpoint for SSM Found: ' + vpce_id
    vpcesubnets
       = '
  a. Subnets configured for the vpc endpoint found:' + list_vpce_subnet

          vpcedns = '
  b. PrivateDNS is set as True or False? Answer: ' + str(vpce_priv_dns)
       + '. (Recommended to set as True.)'
    vpcesg = '
  c. Security group
       attached to the vpc endpoints ' + list_vpce_security_groups
    
    if
       subnetdetails in vpce_subnet:
        print('Subnet configured for VPC endpoint
       matches that of the instance. SSM agent on the instance will communicate to
       ssm endpoints via vpc endpoints network interfaces. Ensure PrivateDNS parameter
       is enabled.')
        print('Checking the security group rules attached to
       the VPC endpoint ')
        print(' ')       
        print('...Results...')

              for vpc_security_group in vpce_security_groups:
            try:

                     response = ec2.describe_security_groups(GroupIds=[vpc_security_group])

                     for sg in response['SecurityGroups']:
                   for
       rule in sg['IpPermissions']:
                       if ((rule.get('IpProtocol')
       == '-1') or (rule.get('FromPort') == -1 and rule.get('ToPort') == -1) or (https_port
       in range(rule.get('FromPort'), rule.get('ToPort') +1))):
               
                  for cidr in rule['IpRanges']:
                               if
       ipaddress.ip_address(instance_priv_ip) in ip_network(cidr['CidrIp'], strict=False):

                                         Results = '

 PASSED : VPC endpoint
       for SSM Exist: ' + vpce_id + ' . Ingress rules on Security groups of VPC endpoints
       allow traffic on port 443 from the Instance IP.

'                   
               
                                   print(Results)
            
                             finalresults = Heading + Found + vpcesubnets + vpcedns
       + vpcesg +  Results
                                   return {'output':
       finalresults, 'vpceid': "Present" }
                           for group
       in rule['UserIdGroupPairs']:
                               if any(sg in
       group['GroupId'] for sg in instance_security_groups):
                  
                       Results = '

 PASSED : VPC endpoint for SSM Exist: ' +
       vpce_id + ' . Ingress rules on Security groups of VPC endpoints allow traffic
       on port 443 from the Instances Security group.

'
                  
                       print(Results)
                                   finalresults
       = Heading + Found + vpcesubnets + vpcedns + vpcesg +  Results
          
                               return {'output': finalresults, 'vpceid': "Present"
       }
            except ClientError as e:
               raise Exception ("
      [ERROR]",e)
        if not Results.strip():
            FailedResults = '
      n
 FAILED : VPC Endpoints for SSM exist, ' + vpce_id + ' but Ingress rules
       on Security groups of VPC endpoints do not allow traffic on port 443 from
       the Instance.' + AWS_SG_DOC
            print(FailedResults)
          
        finalresultsfailed = Heading + Found + vpcesubnets + vpcedns + vpcesg + 
       FailedResults
            return{'output': finalresultsfailed, 'vpceid':
       "Present"}
    else:
       print('...Results...')
       FailedSubnetResults
       = '

 Warning : VPC endpoint for SSM exist, ' + vpce_id + ' but subnets
       associated with the VPC Endpoint does not include the subnet of instance.
       This can still work if the NACL rules are correct to allow traffic between
       the subnets on port 443. Or alternatively, you can add the Instance subnet
       ' + subnetdetails + ' to the VPC endpoint.' + AWS_VPCE_DOC
       print(FailedSubnetResults)

             finalresultssubnet = Heading + Found + vpcesubnets + vpcedns + vpcesg
       +  FailedSubnetResults
       return {'output': finalresultssubnet, 'vpceid':
       "Absent" }
"
  outputs:
  - Name: "output"
    Selector: "$.Payload.output"
    Type: "String"
  - Name: "vpceid"
    Selector: "$.Payload.vpceid"
    Type: "String"
- name: "CheckRouteTable"
  action: "aws:executeScript"
  onFailure: "Abort"
  nextStep: "CheckNacl"
  inputs:
    Runtime: "python3.8"
    Handler: "script_handler"
    InputPayload:
      GetInstance: "{{InstanceId}}"
      EC2InstanceSubnet: "{{ GetEC2InstanceProperties.SubnetId }}"
    Script: "def script_handler(events, context):
   import boto3
   import json

         from botocore.exceptions import ClientError,ParamValidationError

   #Getting
       Instance Information#
   Instance = events['GetInstance']
   subnetdetails
       = events['EC2InstanceSubnet']
   
   ec2 = boto3.client('ec2')
   try:

            result = ec2.describe_route_tables(Filters=[{'Name':'association.subnet-id','Values':[subnetdetails]}])

         except ClientError as e:
      raise Exception ("[ERROR] Failed to initialize
       EC2 client",e)     

   internet_route_list = []
   cidr_for_local_list
       = []

   for items in result['RouteTables']:
    route_table_id = items['RouteTableId']

          print('Route table found: ' + route_table_id)
    AllRouteRules_list =
       items['Routes']
    for routes_dict in AllRouteRules_list:
     # 0.0.0.0/0
       Routes  
     if 'GatewayId' in routes_dict and 'DestinationCidrBlock' in
       routes_dict and routes_dict['DestinationCidrBlock'] == '0.0.0.0/0':
    
        internet_route = routes_dict['GatewayId']
      internet_route_list.append(internet_route)

           elif 'NatGatewayId' in routes_dict and 'DestinationCidrBlock' in routes_dict
       and routes_dict['DestinationCidrBlock'] == '0.0.0.0/0':
      internet_route
       = routes_dict['NatGatewayId']
      internet_route_list.append(internet_route)

           elif 'TransitGatewayId' in routes_dict and 'DestinationCidrBlock' in routes_dict
       and routes_dict['DestinationCidrBlock'] == '0.0.0.0/0':
      internet_route
       = routes_dict['TransitGatewayId']
      internet_route_list.append(internet_route)

           elif 'NetworkInterfaceId' in routes_dict and 'DestinationCidrBlock' in
       routes_dict and routes_dict['DestinationCidrBlock'] == '0.0.0.0/0':
    
        internet_route = routes_dict['NetworkInterfaceId']
      internet_route_list.append(internet_route)

           elif 'VpcPeeringConnectionId' in routes_dict and 'DestinationCidrBlock'
       in routes_dict and routes_dict['DestinationCidrBlock'] == '0.0.0.0/0':
 
           internet_route = routes_dict['VpcPeeringConnectionId']
      internet_route_list.append(internet_route)
            
     # Local Route 
     if 'GatewayId' in routes_dict and 'DestinationIpv6CidrBlock'
       not in routes_dict and routes_dict['GatewayId'] == 'local':
      cidr_for_local
       = routes_dict['DestinationCidrBlock']
      cidr_for_local_list.append(cidr_for_local)

         print(' ')   
   print('Analysing Route table entries for the Instance
       subnet ' + subnetdetails )
   print(' ')
   print('...Results...')
   cidrforlocallist
       = ''.join(cidr_for_local_list)
   LocalRoutes = ' PASSED : Local route available
       for ' + cidrforlocallist + '. If VPC endpoint for SSM is present, then Local
       route is used to communicate with VPC endpoint interface.'

   if not internet_route_list:

          AllOtherRoutes = ' WARNING :  No Route found for 0.0.0.0/0. If VPC endpoint
       is present, then this warning can be ignored as Local route will be used to
       communicate with vpc endpoints interface. If VPC endpoint is not present,
       then your network configuration must have open internet access so that ssm
       endpoints is reachable.'
   else:
    for items in internet_route_list:

           if 'igw' in items:
      OtherRoutes = ' PASSED : Internet gateway '
       + items + ' is present and routing traffic towards 0.0.0.0/0. Hence, Internet
       availability is present on the Instance and ssm endpoints should be accesible.'

            AllOtherRoutes = ''.join(OtherRoutes)
     elif 'nat' in items:
  
          OtherRoutes = ' PASSED : NAT gateway ' + items + ' is present and routing
       traffic towards 0.0.0.0/0. If Internet is not working, Check the NACL/Security
       Groups associated with ' + items + ' are configured correctly for internet
       access.'
      AllOtherRoutes = ''.join(OtherRoutes)
     elif 'eni-' in
       items:
      OtherRoutes = ' WARNING : ENI ' + items + ' is present and routing
       traffic towards 0.0.0.0. This could be working as NAT Instance.If Internet
       is not working, Check the NACL/Security Groups associated with ' + items +
       ' are configured correctly for internet access.'
      AllOtherRoutes = ''.join(OtherRoutes)

           elif 'vgw' in items:
      OtherRoutes = ' WARNING : 0.0.0.0/0 traffic
       is routed through the VPN connection ' + items +'.VPN routes must be configured
       for connectivity to SSM endpoints. Alternatively, you can use VPC endpoints
       for SSM.'
      AllOtherRoutes = ''.join(OtherRoutes)
     elif 'tgw' in
       items:
      OtherRoutes = ' WARNING : 0.0.0.0/0 traffic is routed through
       transit gateway ' + items + '. Transit Gatway routes must be configured for
       connectivity to SSM endpoints. Alternatively, you can use VPC endpoints for
       SSM.'
      AllOtherRoutes = ''.join(OtherRoutes)
     elif 'pcx' in items:

            OtherRoutes = ' WARNING : 0.0.0.0/0 traffic is routed through VPC peering
       instead ' + items + '. This may not have connectivity towards ssm endpoints.
       Your network configuration must have open internet access or you must have
       custom VPC Endpoints for SSM configured.'
      AllOtherRoutes = ''.join(OtherRoutes)

      
   Heading = "2. Checking Route Table entries of the instance's subnet
       : 

"

   Results = Heading + LocalRoutes + '
' + AllOtherRoutes
       + '

'
   return {'output': Results}
"
  outputs:
  - Name: "output"
    Selector: "$.Payload.output"
    Type: "String"
- name: "CheckNacl"
  action: "aws:executeScript"
  onFailure: "Abort"
  nextStep: "CheckInstanceSG"
  inputs:
    Runtime: "python3.8"
    Handler: "script_handler"
    InputPayload:
      GetInstance: "{{InstanceId}}"
      isVpceIdPresent: "{{CheckVpcEndpoint.vpceid}}"
      EC2InstanceSubnet: "{{ GetEC2InstanceProperties.SubnetId }}"
    Script: "def script_handler(events, context):
  import boto3
  from botocore.exceptions
       import ClientError,ParamValidationError

  #assigning variables
  src_port_from
       = 1024
  src_port_to = 65536
  https_port = 443  
  Instance = events['GetInstance']

        vpceid = events['isVpceIdPresent']
  subnetdetails = events['EC2InstanceSubnet']

        Heading = "3. Checking NACL rules of the instance subnet: 

"

 
       if vpceid == 'Present':
   print("VPC Endpoint for SSM found: " + vpceid)

         Results = Heading + ' Skipped : VPC Endpoint for SSM is present. Skipping
       this test..
 
'
   return {'output': Results }
  else:
   print("
      VPC Endpoint for SSM is not found/")  
   
  #Get Instance NACL entries/rules

        ec2 = boto3.client('ec2')
  try:
     results = ec2.describe_network_acls(Filters=[{'Name':'association.subnet-id','Values':[subnetdetails]}])

        except ClientError as e:
     raise Exception ("[ERROR] Failed to initialize
       EC2 client",e)
     
  for rt in results['NetworkAcls']:
   entries_list
       = rt['Entries']

  egress_acls = [acl for acl in entries_list if acl['Egress']]

        ingress_acls = [acl for acl in entries_list if not acl['Egress']]
  
 
       #Sorting the rules as per Rule number.
  
  sorted_egress_acls=sorted(egress_acls,
       key = lambda i: i['RuleNumber'])
  sorted_ingress_acls=sorted(ingress_acls,
       key = lambda i: i['RuleNumber'])
  
  print(' ')
  print('Evaluating NACL
       rules for the Instance subnet ' + subnetdetails)
  print(' ')
  print('...Results...')
        
  
  #Check if the Port range provided is in the range of the NACL rule

        def is_in_range(src_port_from, src_port_to,acl):
    if ((acl.get('Protocol')
       == '-1') or (src_port_from  in range(acl['PortRange']['From'], acl['PortRange']['To']))
       or (src_port_to in  range(acl['PortRange']['From'], acl['PortRange']['To']+1))):

              return acl['RuleAction']
        
  
  for acl in sorted_egress_acls:

          if acl.get('CidrBlock') == '0.0.0.0/0': #Checking only for Anywhere Destination

            rule_action = is_in_range(https_port,https_port,acl)
      if rule_action
       is not None:
          Egress_Access = rule_action
          print("Egress
       rule for Port 443 is " + rule_action)
          break


  for acl in
       sorted_ingress_acls:
    if acl.get('CidrBlock') == '0.0.0.0/0': #Checking
       only for Anywhere source
      rule_action = is_in_range(src_port_from,src_port_to,acl)

            if rule_action is not None:
          Ingress_Access = rule_action

                print("Ingress rule for ephemeral ports " + rule_action)
    
            break


  # For Egress
  if Egress_Access == 'allow':
    EgressResult
       = ' PASSED : Network Acl Egress Rules ALLOWS outbound traffic on port 443
       towards 0.0.0.0/0.'  
  else:
   EgressResult = ' FAILED : Network Acl Egress
       Rules do not allow outbound traffic on port 443 towards 0.0.0.0/0'


 
       # For Ingress
  if Ingress_Access == 'allow':
   IngressResult = ' PASSED
       : Network Acl Ingress Rules ALLOWS inbound traffic on ephemeral ports from
       0.0.0.0/0'
  else:
   IngressResult = ' FAILED : Network Acl Ingress Rules
       do not allow Inbound traffic on  ephemeral ports from  0.0.0.0/0'
  
  Results
       = Heading + EgressResult + '
' + IngressResult + '
 
'
  return {'output':
       Results}
"
  outputs:
  - Name: "output"
    Selector: "$.Payload.output"
    Type: "String"
- name: "CheckInstanceSG"
  action: "aws:executeScript"
  onFailure: "Abort"
  nextStep: "CheckInstanceIAM"
  inputs:
    Runtime: "python3.8"
    Handler: "script_handler"
    InputPayload:
      GetInstance: "{{InstanceId}}"
      InstanceSGList: "{{GetEC2InstanceProperties.SecurityGroupIds}}"
    Script: "def script_handler(events, context):
    import boto3
    from botocore.exceptions
       import ClientError,ParamValidationError
    
    #Assigning static variables#

          Instance = events['GetInstance']
    list_instance_sg = events['InstanceSGList']
       
    https_port = 443
    allowed_ip = []
    Heading = "4. Checking SGs
       of the instance for Port 443 outbound rule: 

"
    ec2 = boto3.client('ec2')

      
    for security_group in list_instance_sg:
        try:
           response
       = ec2.describe_security_groups(GroupIds=[security_group])
           for
       sg in response['SecurityGroups']:
               for rule in sg['IpPermissionsEgress']:

                         if ((rule.get('IpProtocol') == '-1') or (rule.get('FromPort')
       == -1 and rule.get('ToPort') == -1) or (https_port in range(rule.get('FromPort'),
       rule.get('ToPort') +1))):
                       for cidr in rule['IpRanges']:

                                 if cidr['CidrIp'] == '0.0.0.0/0':
            
                         SGResults = " PASSED : Found Outbound Rule for TCP 443
       to 0.0.0.0/0

"
                               Results = Heading + SGResults
       
                               return {'output': Results }
           

                         #if no rule found for 0.0.0.0/0, check further.
      
           
                   if ((rule.get('IpProtocol') == '-1') or (rule.get('FromPort')
       == -1 and rule.get('ToPort') == -1) or (https_port in range(rule.get('FromPort'),
       rule.get('ToPort') +1))):
                       for cidr in rule['IpRanges']:

                                 if cidr['CidrIp'] != '0.0.0.0/0':
            
                         cidr_ip = str(cidr['CidrIp'])
                        
             allowed_ip.append(cidr_ip)
        except ClientError as e:
     
            raise Exception ("[ERROR]",e)        

    if  allowed_ip:
    
          SGResults = " Warning: Restricted outbound rule for TCP 443 found to "
       + str(allowed_ip) + '

'
        Results = Heading + SGResults     

              return {'output': Results } 
    else:
        SGResults = " FAILED:
       No outbound rule for TCP 443 found.

"
        Results = Heading + SGResults
       
        return {'output': Results }

                            
"
  outputs:
  - Name: "output"
    Selector: "$.Payload.output"
    Type: "String"
- name: "CheckInstanceIAM"
  action: "aws:executeScript"
  onFailure: "Abort"
  nextStep: "PlatformEvaluation"
  inputs:
    Runtime: "python3.8"
    Handler: "script_handler"
    InputPayload:
      GetInstance: "{{InstanceId}}"
      EC2InstanceProfile: "{{GetEC2InstanceProperties.InstanceProfile}}"
    Script: "def script_handler(events, context):

   import boto3
   from botocore.exceptions
       import ClientError,ParamValidationError
   
   def initialize_client(service):

            try:
        global client
        client = boto3.client(service)

            except ClientError as e:
        raise Exception ("[ERROR] Failed to
       initialize" + service + " client",e)

        
   def get_iam_role(Name):

            initialize_client('iam')
      try:
         response = client.get_instance_profile(InstanceProfileName=Name)

               InstanceProfile_in_response = response.get('InstanceProfile')
  
             for values in InstanceProfile_in_response['Roles']:
             rolename
       = values['RoleName']
             return rolename            
      except
       ClientError as e:
         raise Exception ("[ERROR]",e)  
         

         
   def get_list_policy(ec2profile):
      ec2profile_name = ec2profile.split("
      /")[1]
      AWS_SSM_IAM_DOC = '
 For reference, follow steps provided here
       : https://docs.aws.amazon.com/systems-manager/latest/userguide/setup-instance-profile.html
      n'
      Role = get_iam_role(ec2profile_name)   
      try:
         response
       = client.list_attached_role_policies(RoleName=Role)      
         for policy
       in response['AttachedPolicies']:
            if policy['PolicyName'] in ['AmazonSSMManagedInstanceCore',
       'AmazonSSMFullAccess', 'AdministratorAccess', 'AmazonEC2RoleforSSM']:
  
                   found_policy = policy['PolicyName']
               IAMResults
       = " PASSED: Found Instance profile attached to the Instance: " + ec2profile
       + ". AWS Managed policy," + found_policy + " is attached to the Instance
       profile.
"
               break
            else:            
     
                IAMResults = " Warning: Found Instance profile attached to the Instance
       " + Instance + " is " + ec2profile + ". However, couldn't find AWS Managed
       policies for SSM attached to it. 
 Ensure existing attached policies have
       required ssm permissions. The minimum permissions for ssm can be referenced
       from the AWS Managed Policy,AmazonSSMManagedInstanceCore." + AWS_SSM_IAM_DOC

               return IAMResults
      except ClientError as e:
         raise
       Exception ("[ERROR] Failed to initialize IAM client",e)    
      
  
       Instance = events['GetInstance']
   InstanceProfile = events['EC2InstanceProfile']

         substring = 'GetEC2InstanceProperties'
   
   AWS_SSM_IAM_DOC = '
 For
       reference, follow steps provided here : https://docs.aws.amazon.com/systems-manager/latest/userguide/setup-instance-profile.html
      n'
   
   if substring in InstanceProfile:
               NoInstanceprofile
       = " FAILED : No Instance Profile  is attached to the instance, " + Instance

                     IAMResults = NoInstanceprofile + ". Instance profile must be
       attached on the Instance with required ssm permissions. The minimum permissions
       for ssm can be referenced from the AWS Managed Policy,AmazonSSMManagedInstanceCore.
       This is a required step.
" + AWS_SSM_IAM_DOC 
    
   else:
      IAMResults
       = get_list_policy(InstanceProfile)

         
   Heading = "5. Checking
       if Instance Profile is attached : 

"
   Results = Heading + IAMResults

         return {'output': Results}
"
  outputs:
  - Name: "output"
    Selector: "$.Payload.output"
    Type: "String"
- name: "PlatformEvaluation"
  action: "aws:branch"
  onFailure: "Abort"
  isCritical: "true"
  inputs:
    Choices:
    - NextStep: "WindowsOsTroubleshooting"
      Variable: "{{ GetEC2InstanceProperties.platform }}"
      StringEquals: "windows"
    Default: "LinuxOsTroubleshooting"
- name: "LinuxOsTroubleshooting"
  action: "aws:executeScript"
  onFailure: "Abort"
  nextStep: "FinalOutput"
  inputs:
    Runtime: "python3.8"
    Handler: "script_handler"
    Script: "def script_handler(events, context):
    import boto3

    
    Info
       = ("
 - - - - - - - - - - - - - - - - - - - 
"
    "
 |     For
       Further Investigation     | 
"
    "
 - - - - - - - - - - - - - - -
       - - - - 
"
    "
 You can use SSMAgentToolkit-Linux to troubleshoot
       further for Operating system level problems. The SSMAgent-Toolkit is a bash
       script developed to run multiple checks to determined why a Linux EC2 instance
       does not come online as Managed Instance.

"
    "
 You can run the
       following commands on your Linux Machine. This will download the SSMAgentToolkit-Linux
       Script and execute it. The output will show various tests ran and its results.
      n"
    "
 wget https://raw.githubusercontent.com/awslabs/aws-support-tools/master/Systems%20Manager/SSMAGENT-TOOLKIT-LINUX/ssmagent-toolkit-Linux.sh"
      
    "
 bash ssmagent-toolkit-Linux.sh > AWS-SSMtroubleshooting-output.txt"
      
    "
 cat AWS-SSMtroubleshooting-output.txt"
    "

# Reference
       : 
"
    " a. https://github.com/awslabs/aws-support-tools/tree/master/Systems%20Manager/SSMAGENT-TOOLKIT-LINUX
       
"
    " b. https://aws.amazon.com/premiumsupport/knowledge-center/systems-manager-ec2-instance-not-appear/
       

"
    )

    return {'output' : Info}


"
  outputs:
  - Name: "output"
    Selector: "$.Payload.output"
    Type: "String"
- name: "WindowsOsTroubleshooting"
  action: "aws:executeScript"
  onFailure: "Abort"
  nextStep: "FinalOutput"
  inputs:
    Runtime: "python3.8"
    Handler: "script_handler"
    Script: "def script_handler(events, context):
    import boto3

    
    Info
       = ("
 - - - - - - - - - - - - - - - - - - - 
"
    "
 |     For
       Further Investigation     | 
"
    "
 - - - - - - - - - - - - - - -
       - - - - 
"
    "
 You can use SSMAgentToolkit-Windows to troubleshoot
       further for Operating system level problems. The SSMAgent-Toolkit is a set
       of PowerShell scripts developed to run multiple checks to determined why a
       Windows EC2 instance does not come online as Managed Instance.
"
    "
      
 Simply download the ZIP file included in the below package and extract.
       "
    "
 Package location : https://github.com/awslabs/aws-support-tools/tree/master/Systems%20Manager/SSMAgent-Toolkit-Windows
      n"
    "
 Change directory to the extracted folder and Run the followings
       as administrator in PowerShell."
    "
 Import-Module .SSMAgent-Toolkit.psm1;Invoke-SSMChecks
      n"
    "

# Reference : 
"
    " a. https://github.com/awslabs/aws-support-tools/tree/master/Systems%20Manager/SSMAGENT-TOOLKIT-LINUX
       
"
    " b. https://aws.amazon.com/premiumsupport/knowledge-center/systems-manager-ec2-instance-not-appear/
       

"
    )

    return {'output' : Info}


"
  outputs:
  - Name: "output"
    Selector: "$.Payload.output"
    Type: "String"
- name: "FinalOutput"
  action: "aws:executeScript"
  onFailure: "Abort"
  isEnd: "true"
  inputs:
    Runtime: "python3.8"
    Handler: "script_handler"
    InputPayload:
      Vpce: "{{CheckVpcEndpoint.output}}"
      routetable: "{{CheckRouteTable.output}}"
      nacl: "{{CheckNacl.output}}"
      sg: "{{CheckInstanceSG.output}}"
      iam: "{{CheckInstanceIAM.output}}"
      linuxscript: "{{LinuxOsTroubleshooting.output}}"
      windowsscript: "{{WindowsOsTroubleshooting.output}}"
    Script: "def script_handler(events, context):
   import boto3
   import json

      
   #Capturing other steps output.
   
   Heading = "Total Number of Tests:
       5

"
   vpceoutput = events['Vpce']
   routetableoutput = events['routetable']

         nacloutput = events['nacl']
   sgoutput = events['sg']
   iamoutput =
       events['iam']
   linuxscriptoutput = events['linuxscript']
   windowsscriptoutput
       = events['windowsscript']

 
   if 'SSMAgentToolkit-Linux' in linuxscriptoutput:

                Results = Heading + vpceoutput + routetableoutput  + nacloutput 
       + sgoutput  + iamoutput  + linuxscriptoutput
   else:
          Results
       = Heading + vpceoutput + routetableoutput  + nacloutput  + sgoutput  + iamoutput
        + windowsscriptoutput
       
   return {'output': Results}





"
  outputs:
  - Name: "output"
    Selector: "$.Payload.output"
    Type: "String"
- name: "InstanceisOnline"
  action: "aws:executeScript"
  onFailure: "Abort"
  isEnd: "true"
  inputs:
    Runtime: "python3.8"
    Handler: "script_handler"
    Script: "def script_handler(events, context):
    import boto3
    
    Info
       = "Instance is already Online under Fleet Manager."

    return {'output'
       : Info}


"
  outputs:
  - Name: "output"
    Selector: "$.Payload.output"
    Type: "String"
