description: "This document helps to troubleshoot connectivity across two resource
   using their IP addresses as input. This document supports IPv4 only."
schemaVersion: "0.3"
assumeRole: "{{AutomationAssumeRole}}"
parameters:
  AutomationAssumeRole:
    type: "String"
    description: "(Optional) The ARN of the role that allows Automation to perform
       the actions on your behalf. If no role is specified, Systems Manager Automation
       uses the permissions of the user that executes this document."
    default: ""
    allowedPattern: "^$|^arn:aws:iam::[0-9]*:role/[/w+=,.@-]+$"
  SourceIP:
    type: "String"
    description: "(Required) Private IPv4 address of a VPC resource."
    allowedPattern: "b((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(.|$)){4}b"
  DestinationIP:
    type: "String"
    description: "(Required) IPv4 address of the destination resource."
    allowedPattern: "b((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(.|$)){4}b"
  DestinationPort:
    type: "String"
    description: "(Required) Destination Server port the source is trying to connect.
       For e.g 22 for SSH, 80 for HTTP, 443 for HTTPS, 3389 for RDP"
    allowedPattern: "^(6553[0-5]|655[0-2]d|65[0-4]dd|6[0-4]d{3}|[1-5]d{4}|[1-9]
      d{0,3}|0)$"
  SourceVpc:
    type: "String"
    description: "(Optional) VPC Id of the source Amazon VPC"
    allowedPattern: "^$|^(?:vpc-[0-9a-f]{8}|vpc-[0-9a-f]{17}|)$"
    default: ""
  DestinationVpc:
    type: "String"
    description: "(Optional) VPC Id of the destination Amazon VPC"
    allowedPattern: "^$|^(?:vpc-[0-9a-f]{8}|vpc-[0-9a-f]{17}|)$"
    default: ""
  SourcePortRange:
    type: "String"
    description: "(Optional) Source port range used by source resource. For e.g. if
       the source port is fixed- 123-123 or if source ports uses a defined range-
       32000-65000"
    allowedPattern: "^(6553[0-5]|655[0-2]d|65[0-4]dd|6[0-4]d{3}|[1-5]d{4}|[1-9]
      d{0,3}|0)-(6553[0-5]|655[0-2]d|65[0-4]dd|6[0-4]d{3}|[1-5]d{4}|[1-9]
      d{0,3}|0)$"
    default: "0-65535"
mainSteps:
- name: "getSourceDetails"
  action: "aws:executeScript"
  outputs:
  - Name: "SrcNetworkInterface"
    Selector: "$.Payload.SrcNetworkInterface"
    Type: "StringMap"
  - Name: "SrcSecurityGroups"
    Selector: "$.Payload.SrcSecurityGroups"
    Type: "StringList"
  - Name: "SrcSubnetId"
    Selector: "$.Payload.SrcSubnetId"
    Type: "String"
  - Name: "SrcVpcId"
    Type: "String"
    Selector: "$.Payload.SrcVpcId"
  - Name: "Routes"
    Selector: "$.Payload.Routes"
    Type: "MapList"
  inputs:
    Runtime: "python3.8"
    Handler: "get_source_details"
    Script: "def get_source_details(events, context):
    src_ip = events['SourceIP']

          src_vpc = events['SourceVpc']
    dst_ip = events['DestinationIP']


          if src_ip == dst_ip:
        raise Exception('Input parameters SourceIP
       and DestinationIP are same, kindly provide different input parameters')


          import boto3

    ec2_client = boto3.client('ec2')

    filters = [

              {
            'Name': 'addresses.private-ip-address',
          
        'Values': [
                src_ip
            ]
        }
    ]
  
        if src_vpc != '':
        filters.append(
                {
         
                 'Name': 'vpc-id',
                    'Values': [
           
                   src_vpc
                    ]
                }
        )

      
    network_interface = ec2_client.describe_network_interfaces(Filters=filters)

      
    if len(network_interface['NetworkInterfaces']) > 0:
        network_interface
       = network_interface['NetworkInterfaces'][0]
        if 'AttachTime' in str(network_interface):

                  network_interface['Attachment']['AttachTime'] = str(network_interface['Attachment']['AttachTime'])

          else:
        raise Exception('Kindly check the SourceIP and SourceVpc
       input parameters, no network interface found')
    
    output = {
   
           'SrcNetworkInterface': network_interface
    }
    output['SrcVpcId']
       = network_interface['VpcId']
    output['SrcSubnetId'] = network_interface['SubnetId']

          output['SrcSecurityGroups'] = [group['GroupId'] for group in network_interface['Groups']]
                  
    
    routes = ec2_client.describe_route_tables(
      
        Filters=[
        {
            'Name': 'association.subnet-id',
    
              'Values': [
                network_interface['SubnetId']
      
            ]
        }
    ]
    )

    if len(routes['RouteTables']) > 0:

              routes = routes['RouteTables'][0]['Routes']
    # if RouteTable is
       not returned, this indicates association of subnet with main route table

          else:
        try:
            routes = ec2_client.describe_route_tables(

                      Filters=[
                    {
                        'Name':
       'association.main',
                        'Values': [
               
                   'true'
                        ]
                    },
  
                        {
                        'Name': 'vpc-id',
          
                    'Values': [
                            network_interface['VpcId']

                              ]
                    }                    
    
                  ]
            )['RouteTables'][0]['Routes']
        except Exception
       as e:
            raise Exception('Could not find route table for input SourceIP')

          
    output['Routes'] = routes
    return output
"
    InputPayload:
      SourceVpc: "{{SourceVpc}}"
      SourceIP: "{{SourceIP}}"
      DestinationIP: "{{DestinationIP}}"
  isCritical: true
  timeoutSeconds: 30
  onFailure: "Abort"
  nextStep: "getNextHop"
  isEnd: false
- name: "getNextHop"
  action: "aws:executeScript"
  outputs:
  - Name: "NextHop"
    Selector: "$.Payload"
    Type: "String"
  inputs:
    Runtime: "python3.8"
    Handler: "get_next_hop"
    Script: "def get_next_hop(events, context):
    from ipaddress import ip_network,ip_address

          routes = events['Routes'] 
    destination = ip_address(events['DestinationIP'])
              
    most_specific = -1

    AWS_DOC = '
Working with route tables
       - https://docs.aws.amazon.com/vpc/latest/userguide/WorkWithRouteTables.html'

          for route in routes:
        if route.get('DestinationCidrBlock'):
 
                 mask = int(route['DestinationCidrBlock'].split('/')[1])
      
            if not 'DestinationPrefixListId' in str(route) and destination in ip_network(route['DestinationCidrBlock'],
       strict=False) and mask > most_specific:
                if route['State']
       != 'blackhole':
                    most_specific = mask
              
            next_hop = route
    #0.0.0.0/0
    if most_specific >= 0:
      
        return next_hop.get('EgressOnlyInternetGatewayId') or next_hop.get('GatewayId')
       or next_hop.get('InstanceId') or next_hop.get('NetworkInterfaceId') or next_hop.get('LocalGatewayId')
       or next_hop.get('NatGatewayId') or next_hop.get('TransitGatewayId') or next_hop.get('VpcPeeringConnectionId')

          raise Exception('No route found for destination: ' + events['DestinationIP']
       + AWS_DOC)      
"
    InputPayload:
      Routes: "{{getSourceDetails.Routes}}"
      DestinationIP: "{{DestinationIP}}"
  isCritical: true
  timeoutSeconds: 30
  onFailure: "Abort"
  nextStep: "branchByNextHopType"
  isEnd: false
- name: "branchByNextHopType"
  action: "aws:branch"
  inputs:
    Choices:
    - NextStep: "localDestination"
      Variable: "{{getNextHop.NextHop}}"
      StringEquals: "local"
    - NextStep: "peeringDestination"
      Variable: "{{getNextHop.NextHop}}"
      StartsWith: "pcx-"
    - NextStep: "natDestination"
      Variable: "{{getNextHop.NextHop}}"
      StartsWith: "nat-"
    - NextStep: "igwDestination"
      Variable: "{{getNextHop.NextHop}}"
      StartsWith: "igw-"
  isCritical: true
  timeoutSeconds: 30
  onFailure: "Abort"
  nextStep: "hopTypeNotSupported"
  isEnd: false
- name: "localDestination"
  action: "aws:executeAwsApi"
  outputs:
  - Name: "DstSecurityGroups"
    Selector: "$.NetworkInterfaces[0].Groups..GroupId"
    Type: "StringList"
  - Name: "DstSubnetId"
    Selector: "$.NetworkInterfaces[0].SubnetId"
    Type: "String"
  - Name: "DstVpcId"
    Selector: "$.NetworkInterfaces[0].VpcId"
    Type: "String"
  inputs:
    Service: "ec2"
    Api: "DescribeNetworkInterfaces"
    Filters:
    - Name: "addresses.private-ip-address"
      Values:
      - "{{DestinationIP}}"
  isCritical: true
  timeoutSeconds: 30
  onFailure: "Abort"
  nextStep: "checkDestinationVpcId"
  isEnd: false
- name: "checkDestinationVpcId"
  action: "aws:executeScript"
  inputs:
    Runtime: "python3.8"
    Handler: "check_destination_vpcid"
    Script: "def check_destination_vpcid(events, context):
    dst_vpc_from_input
       = events['InputDstVpc']
    dst_vpc_from_route = events['RouteDstVpc']


          AWS_DOC = '
Working with route tables - https://docs.aws.amazon.com/vpc/latest/userguide/WorkWithRouteTables.html'

      
    # ensure that dst_vpc is not blank, as it's an optinal parameter
   
       if dst_vpc_from_input != '':
        if dst_vpc_from_input == dst_vpc_from_route:

                  return True
        else:
            raise Exception('Kindly
       check the source route table to ensure a more specific route is present towards
       required destination VPC' + AWS_DOC)
"
    InputPayload:
      InputDstVpc: "{{DestinationVpc}}"
      RouteDstVpc: "{{localDestination.DstVpcId}}"
  isCritical: true
  timeoutSeconds: 30
  onFailure: "Continue"
  nextStep: "getSecurityGroupDetails"
  isEnd: false
- name: "getSecurityGroupDetails"
  action: "aws:executeAwsApi"
  inputs:
    Service: "ec2"
    Api: "DescribeSecurityGroups"
    GroupIds:
    - "{{getSourceDetails.SrcSecurityGroups}}"
    - "{{localDestination.DstSecurityGroups}}"
  outputs:
  - Name: "SecurityGroups"
    Selector: "$"
    Type: "StringMap"
  nextStep: "evalSecurityGroups"
  isCritical: true
  timeoutSeconds: 30
  onFailure: "Continue"
  isEnd: false
- name: "evalSecurityGroups"
  action: "aws:executeScript"
  inputs:
    Runtime: "python3.8"
    Handler: "eval_sg_rules"
    Script: "def eval_sg_rules(events, context):
    from ipaddress import ip_network,ip_address

          src_security_groups = events['SrcSecurityGroups']
    dst_security_groups
       = events['DstSecurityGroups']
    security_group_details = events['SecurityGroups']

          src_ip = ip_address(events['SourceIP'])
    dst_ip = ip_address(events['DestinationIP'])
              
    dst_port = int(events['DestinationPort'])    

    AWS_DOC
       = '
Security groups for your VPC - Working with security groups - https://docs.aws.amazon.com/vpc/latest/userguide/VPC_SecurityGroups.html#WorkingWithSecurityGroups'
            

    def eval_src_egress_rules():                    
        for
       src_security_group in src_security_groups:
            sg = [group for group
       in security_group_details['SecurityGroups'] if group['GroupId'] == src_security_group][0]

                  for rule in sg['IpPermissionsEgress']:
                if ((rule.get('IpProtocol')
       == '-1') or (rule.get('FromPort') == -1 and rule.get('ToPort') == -1) or (dst_port
       in range(rule.get('FromPort'), rule.get('ToPort') +1))):
               
           for cidr in rule['IpRanges']:
                        if dst_ip in ip_network(cidr['CidrIp'],
       strict=False):
                            return True
                
          else:
                        for group in rule['UserIdGroupPairs']:

                                  if any(sg in group['GroupId'] for sg in dst_security_groups)
       :
                                return True
        raise Exception('Egress
       rules on source do not allow traffic towards destination: ' + events['DestinationIP']
       + ':' + str(dst_port) + AWS_DOC)               

    def eval_dst_ingress_rules():

              for dst_security_group in dst_security_groups:
            sg = [group
       for group in security_group_details['SecurityGroups'] if group['GroupId']
       == dst_security_group][0]
            for rule in sg['IpPermissions']:

                      if ((rule.get('IpProtocol') == '-1') or (rule.get('FromPort')
       == -1 and rule.get('ToPort') == -1) or (dst_port in range(rule.get('FromPort'),
       rule.get('ToPort') +1))):
                    for cidr in rule['IpRanges']:

                              if src_ip in ip_network(cidr['CidrIp'], strict=False):

                                  return True
                    else:
      
                        for group in rule['UserIdGroupPairs']:
                
                  if any(sg in group['GroupId'] for sg in src_security_groups):

                                      return True
        raise Exception('Ingress
       rules on destination do not allow traffic from source: ' + events['SourceIP']
       + ' towards destination port ' + str(dst_port) + AWS_DOC)

    eval_src_egress_rules()
              
    eval_dst_ingress_rules()         

    return True
"
    InputPayload:
      SrcSecurityGroups: "{{getSourceDetails.SrcSecurityGroups}}"
      DstSecurityGroups: "{{localDestination.DstSecurityGroups}}"
      SecurityGroups: "{{getSecurityGroupDetails.SecurityGroups}}"
      SourceIP: "{{SourceIP}}"
      DestinationIP: "{{DestinationIP}}"
      DestinationPort: "{{DestinationPort}}"
  isCritical: true
  timeoutSeconds: 30
  onFailure: "Continue"
  isEnd: false
  nextStep: "getNaclDetails"
- name: "getNaclDetails"
  action: "aws:executeAwsApi"
  inputs:
    Service: "ec2"
    Api: "DescribeNetworkAcls"
    Filters:
    - Name: "association.subnet-id"
      Values:
      - "{{getSourceDetails.SrcSubnetId}}"
      - "{{localDestination.DstSubnetId}}"
  outputs:
  - Name: "NetworkAcls"
    Selector: "$.NetworkAcls"
    Type: "MapList"
  nextStep: "evalNacls"
  isCritical: true
  timeoutSeconds: 30
  onFailure: "Continue"
  isEnd: false
- name: "evalNacls"
  action: "aws:executeScript"
  inputs:
    Runtime: "python3.8"
    Handler: "eval_nacls"
    Script: "def eval_nacls(events, context):
    from ipaddress import ip_network,ip_address

          src_subnet_id = events['SrcSubnetId']
    dst_subnet_id = events['DstSubnetId']

          src_port_range = events['SourcePortRange']
    src_port_from = int(src_port_range.split('-')[0])

          src_port_to = int(src_port_range.split('-')[1])

    AWS_DOC = '
Network
       ACLs - Working with network ACLs - https://docs.aws.amazon.com/vpc/latest/userguide/vpc-network-acls.html#nacl-tasks'

      
    if src_subnet_id == dst_subnet_id:
        return True

    src_ip
       = ip_address(events['SourceIP'])        
    dst_ip = ip_address(events['DestinationIP'])
              
    dst_port = int(events['DestinationPort'])

    src_acls = [acl['Entries']
       for acl in events['NetworkAcls'] if src_subnet_id in str(acl['Associations'])][0]

          dst_acls = [acl['Entries'] for acl in events['NetworkAcls'] if dst_subnet_id
       in str(acl['Associations'])][0]

    def eval_src_nacls(acls):         
                 
    
        def check_egress_acls(acls, dst_ip, dst_port):

                  for acl in acls:
                # check ipv4 acl rule only

                      if acl.get('CidrBlock'):
                    #Check IP
 
                         if dst_ip in ip_network(acl['CidrBlock'], strict=False):

                              #Check Port
                        if ((acl.get('Protocol')
       == '-1') or (dst_port in range(acl['PortRange']['From'], acl['PortRange']['To']
       +1))):
                            #Check Action
                      
            if acl['RuleAction'] == 'allow':
                                return
       True
                            else: raise Exception('Source Subnet Network
       Acl Egress Rules do not allow outbound traffic to destination: ' + events['DestinationIP']
       + ':' + str(events['DestinationPort']) + AWS_DOC)
            else:
   
                   raise Exception('Source Subnet Network Acl Egress Rules do not
       allow outbound traffic to destination: ' + events['DestinationIP'] + ':' +
       str(events['DestinationPort']) + AWS_DOC)
            
        def check_ingress_acls(acls,
       src_ip):
            for acl in acls:
                # check ipv4 acl rule
       only
                if acl.get('CidrBlock'):
                    #Check
       IP
                    if src_ip in ip_network(acl['CidrBlock'], strict=False):

                              #Check Port
                        if ((acl.get('Protocol')
       == '-1') or (set(range(src_port_from, src_port_to)).issubset(range(acl['PortRange']['From'],
       acl['PortRange']['To'] +1)))):
                            #Check Action

                                  if acl['RuleAction'] == 'allow':
            
                          return True
                            else: raise Exception('Source
       Subnet Network Acl Ingress Rules do not allow inbound traffic from destination:
       ' + events['DestinationIP'] + AWS_DOC)            
            else:
  
                    raise Exception('Source Subnet Network Acl Ingress Rules do not
       allow inbound traffic from destination: ' + events['DestinationIP'] + AWS_DOC)
                  
        
        egress_acls = [acl for acl in acls if acl['Egress']]
                                      
        ingress_acls = [acl for acl in acls
       if not acl['Egress']]

        src_egress_check_pass = check_egress_acls(egress_acls,
       dst_ip, dst_port)
        src_ingress_check_pass= check_ingress_acls(ingress_acls,
       dst_ip) 

        if src_ingress_check_pass and src_egress_check_pass: 

                  return True

    def eval_dst_nacls(acls):                  
                        
        def check_egress_acls(acls, dst_ip):
        
          for acl in acls:
                # check ipv4 acl rule only
        
              if acl.get('CidrBlock'):
                    #Check IP
         
                 if dst_ip in ip_network(acl['CidrBlock'], strict=False):
     
                         #Check Port
                        if ((acl.get('Protocol')
       == '-1') or (set(range(src_port_from,src_port_to)).issubset(range(acl['PortRange']['From'],
       acl['PortRange']['To'] +1)))):
                            #Check Action

                                  if acl['RuleAction'] == 'allow':
            
                          return True
                            else: raise Exception('Destination
       Subnet Network Acl Egress Rules do not allow outbound traffic to source: '
       + events['SourceIP'] + AWS_DOC)
            else:
                raise
       Exception('Destination Subnet Network Acl Egress Rules do not allow outbound
       traffic to source: ' + events['SourceIP'] + AWS_DOC)
    
        def check_ingress_acls(acls,
       src_ip, dst_port):            
            for acl in acls:
           
           # check ipv4 acl rule only
                if acl.get('CidrBlock'):

                          #Check IP
                    if src_ip in ip_network(acl['CidrBlock'],
       strict=False):
                        #Check Port
                    
          if ((acl.get('Protocol') == '-1') or (dst_port in range(acl['PortRange']['From'],
       acl['PortRange']['To'] +1))):
                            #Check Action

                                  if acl['RuleAction'] == 'allow':
            
                          return True
                            else: raise Exception('Destination
       Subnet Network Acl Ingress Rules do not allow inbound traffic from source:
       ' + events['SourceIP'] + ' towards destination port ' + str(events['DestinationPort'])
       + AWS_DOC)
            else:
                raise Exception('Destination
       Subnet Network Acl Ingress Rules do not allow inbound traffic from source:
       ' + events['SourceIP'] + ' towards destination port ' + str(events['DestinationPort'])
       + AWS_DOC)            
            
        egress_acls = [acl for acl in
       acls if acl['Egress']]                                
        ingress_acls
       = [acl for acl in acls if not acl['Egress']]

        dst_ingress_check_pass=
       check_ingress_acls(ingress_acls, src_ip, dst_port) 
        dst_egress_check_pass
       = check_egress_acls(egress_acls, src_ip)
        
        if dst_ingress_check_pass
       and dst_egress_check_pass: 
            return True
    
    eval_src_nacls(src_acls)

          eval_dst_nacls(dst_acls)

    return True
"
    InputPayload:
      NetworkAcls: "{{getNaclDetails.NetworkAcls}}"
      SourceIP: "{{SourceIP}}"
      DestinationIP: "{{DestinationIP}}"
      DestinationPort: "{{DestinationPort}}"
      SrcSubnetId: "{{getSourceDetails.SrcSubnetId}}"
      DstSubnetId: "{{localDestination.DstSubnetId}}"
      SourcePortRange: "{{SourcePortRange}}"
  isCritical: true
  timeoutSeconds: 30
  onFailure: "Abort"
  isEnd: true
- name: "igwDestination"
  action: "aws:executeScript"
  inputs:
    Runtime: "python3.8"
    Handler: "eval_src_public_ip"
    Script: "def eval_src_public_ip(events, context):
    src_network_interface =
       events['SrcNetworkInterface']
    private_ips = src_network_interface['PrivateIpAddresses']

          src_ip = events['SourceIP']
    src_next_hop = events['SourceNextHop']

          AWS_DOC = '
Amazon EC2 instance IP addressing - Working with IP addresses
       for your instance - https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-instance-addressing.html#working-with-ip-addresses'

      
    if src_next_hop and str(src_next_hop).startswith('nat-'):
        return
       True
    
    for private_ip in private_ips:
        if private_ip['PrivateIpAddress']
       == src_ip:
            if 'PublicIp' in str(private_ip):
              
        return True

    raise Exception('A public IP or Elastic IP is required
       at source to connect to a public destination' + AWS_DOC)
"
    InputPayload:
      SrcNetworkInterface: "{{getSourceDetails.SrcNetworkInterface}}"
      SourceIP: "{{SourceIP}}"
      SourceNextHop: "{{getNextHop.NextHop}}"
  isCritical: true
  timeoutSeconds: 30
  onFailure: "Continue"
  isEnd: false
  nextStep: "getSrcSecurityGroupDetails"
- name: "getSrcSecurityGroupDetails"
  action: "aws:executeAwsApi"
  inputs:
    Service: "ec2"
    Api: "DescribeSecurityGroups"
    GroupIds:
    - "{{getSourceDetails.SrcSecurityGroups}}"
  outputs:
  - Name: "SrcSecurityGroups"
    Selector: "$"
    Type: "StringMap"
  nextStep: "evalSrcSecurityGroups"
  isCritical: true
  timeoutSeconds: 30
  onFailure: "Continue"
  isEnd: false
- name: "evalSrcSecurityGroups"
  action: "aws:executeScript"
  inputs:
    Runtime: "python3.8"
    Handler: "eval_src_egress_rules"
    Script: "def eval_src_egress_rules(events, context):  
    from ipaddress import
       ip_network,ip_address
    src_security_groups = events['SrcSecurityGroups']['SecurityGroups']

          dst_ip = ip_address(events['DestinationIP'])        
    dst_port = int(events['DestinationPort'])
            

    AWS_DOC = '
Security groups for your VPC - Working with security
       groups - https://docs.aws.amazon.com/vpc/latest/userguide/VPC_SecurityGroups.html#WorkingWithSecurityGroups'
            

    for sg in src_security_groups:
        for rule in sg['IpPermissionsEgress']:

                  if ((rule.get('IpProtocol') == '-1') or (rule.get('FromPort') ==
       -1 and rule.get('ToPort') == -1) or (dst_port in range(rule.get('FromPort'),
       rule.get('ToPort') +1))):
                for cidr in rule['IpRanges']:

                          if dst_ip in ip_network(cidr['CidrIp'], strict=False):

                              return True
    raise Exception('Egress rules on source
       do not allow traffic towards destination: ' + events['DestinationIP'] + ':'
       + str(dst_port) + AWS_DOC)            
"
    InputPayload:
      SrcSecurityGroups: "{{getSrcSecurityGroupDetails.SrcSecurityGroups}}"
      DestinationIP: "{{DestinationIP}}"
      DestinationPort: "{{DestinationPort}}"
  isCritical: true
  timeoutSeconds: 30
  onFailure: "Continue"
  isEnd: false
  nextStep: "getSrcNaclDetails"
- name: "getSrcNaclDetails"
  action: "aws:executeAwsApi"
  inputs:
    Service: "ec2"
    Api: "DescribeNetworkAcls"
    Filters:
    - Name: "association.subnet-id"
      Values:
      - "{{getSourceDetails.SrcSubnetId}}"
  outputs:
  - Name: "SrcNetworkAcls"
    Selector: "$.NetworkAcls"
    Type: "MapList"
  nextStep: "evalSrcNacls"
  isCritical: true
  timeoutSeconds: 30
  onFailure: "Continue"
  isEnd: false
- name: "evalSrcNacls"
  action: "aws:executeScript"
  inputs:
    Runtime: "python3.8"
    Handler: "eval_src_nacls"
    Script: "def eval_src_nacls(events, context):
    from ipaddress import ip_network,ip_address
         
    
    src_port_range = events['SourcePortRange']
    src_port_from
       = int(src_port_range.split('-')[0])
    src_port_to = int(src_port_range.split('-')[1])
               
    
    AWS_DOC = '
Network ACLs - Working with network ACLs
       - https://docs.aws.amazon.com/vpc/latest/userguide/vpc-network-acls.html#nacl-tasks'

      
    def check_egress_acls(acls, dst_ip, dst_port):
        for acl in acls:

                  # check ipv4 acl rule only
            if acl.get('CidrBlock'):

                      #Check IP
                if dst_ip in ip_network(acl['CidrBlock'],
       strict=False):
                    #Check Port
                    if ((acl.get('Protocol')
       == '-1') or (dst_port in range(acl['PortRange']['From'], acl['PortRange']['To']
       +1))):
                        #Check Action
                        if
       acl['RuleAction'] == 'allow':
                            return True
 
                             else: raise Exception('Source Subnet ' + events['SrcSubnetId']
       + ' Network Acl Egress Rules do not allow outbound traffic to destination:
       ' + events['DestinationIP'] + ':' + str(events['DestinationPort']) + AWS_DOC)

              else:
            raise Exception('Source Subnet ' + events['SrcSubnetId']
       + ' Network Acl Egress Rules do not allow outbound traffic to destination:
       ' + events['DestinationIP'] + ':' + str(events['DestinationPort']) + AWS_DOC)

          
    def check_ingress_acls(acls, src_ip):
        for acl in acls:

                  # check ipv4 acl rule only
            if acl.get('CidrBlock'):

                      #Check IP
                if src_ip in ip_network(acl['CidrBlock'],
       strict=False):
                    #Check Port
                    if ((acl.get('Protocol')
       == '-1') or (set(range(src_port_from,src_port_to)).issubset(range(acl['PortRange']['From'],
       acl['PortRange']['To'] +1)))):
                        #Check Action
  
                            if acl['RuleAction'] == 'allow':
                  
                return True
                        else: raise Exception('Source
       Subnet ' + events['SrcSubnetId'] + ' Network Acl Ingress Rules do not allow
       inbound traffic from destination: ' + events['DestinationIP'] + AWS_DOC) 
                 
        else:
            raise Exception('Source Subnet ' +
       events['SrcSubnetId'] + ' Network Acl Ingress Rules do not allow inbound traffic
       from destination: ' + events['DestinationIP'] + AWS_DOC)            
   
       
    dst_ip = ip_address(events['DestinationIP'])        
    dst_port =
       int(events['DestinationPort'])

    src_acls = events['SrcNetworkAcls'][0]['Entries']

          egress_acls = [acl for acl in src_acls if acl['Egress']]              
                        
    ingress_acls = [acl for acl in src_acls if not acl['Egress']]

      
    src_egress_check_pass = check_egress_acls(egress_acls, dst_ip, dst_port)

          src_ingress_check_pass= check_ingress_acls(ingress_acls, dst_ip) 

 
         if src_ingress_check_pass and src_egress_check_pass: 
        return True

          
    raise Exception('NetworkAcls do not allow traffic' + AWS_DOC)
"
    InputPayload:
      SrcNetworkAcls: "{{getSrcNaclDetails.SrcNetworkAcls}}"
      SrcSubnetId: "{{getSourceDetails.SrcSubnetId}}"
      DestinationIP: "{{DestinationIP}}"
      DestinationPort: "{{DestinationPort}}"
      SourcePortRange: "{{SourcePortRange}}"
  isCritical: true
  timeoutSeconds: 30
  onFailure: "Abort"
  isEnd: true
- name: "natDestination"
  action: "aws:executeAwsApi"
  inputs:
    Service: "ec2"
    Api: "DescribeNatGateways"
    Filters:
    - Name: "nat-gateway-id"
      Values:
      - "{{getNextHop.NextHop}}"
  outputs:
  - Name: "NatSubnetId"
    Selector: "$.NatGateways[0]['SubnetId']"
    Type: "String"
  - Name: "NatVpcId"
    Selector: "$.NatGateways[0]['VpcId']"
    Type: "String"
  nextStep: "getNatSubnetAcls"
  isCritical: true
  timeoutSeconds: 30
  onFailure: "Continue"
  isEnd: false
- name: "getNatSubnetAcls"
  action: "aws:executeAwsApi"
  inputs:
    Service: "ec2"
    Api: "DescribeNetworkAcls"
    Filters:
    - Name: "association.subnet-id"
      Values:
      - "{{natDestination.NatSubnetId}}"
  outputs:
  - Name: "NatNetworkAcls"
    Selector: "$.NetworkAcls"
    Type: "MapList"
  nextStep: "evalNatNacls"
  isCritical: true
  timeoutSeconds: 30
  onFailure: "Continue"
  isEnd: false
- name: "evalNatNacls"
  action: "aws:executeScript"
  inputs:
    Runtime: "python3.8"
    Handler: "eval_nat_nacls"
    Script: "def eval_nat_nacls(events, context):
    from ipaddress import ip_network,ip_address

          src_subnet_id = events['SrcSubnetId']
    nat_subnet_id = events['NatSubnetId']

      
    src_ip = ip_address(events['SourceIP'])        
    dst_ip = ip_address(events['DestinationIP'])
              
    dst_port = int(events['DestinationPort'])
    src_port_range
       = events['SourcePortRange']
    src_port_from = int(src_port_range.split('-')[0])

          src_port_to = int(src_port_range.split('-')[1])

    nat_acls = events['NatNetworkAcls'][0]['Entries']

          egress_acls = [acl for acl in nat_acls if acl['Egress']]              
                        
    ingress_acls = [acl for acl in nat_acls if not acl['Egress']]

          
    AWS_DOC = '
Network ACLs - Working with network ACLs - https://docs.aws.amazon.com/vpc/latest/userguide/vpc-network-acls.html#nacl-tasks'

      
    def check_egress_towards_dst(acls, dst_ip, dst_port):            
  
            for acl in acls:
            # check ipv4 acl rule only
          
        if acl.get('CidrBlock'):
                #Check IP
                if dst_ip
       in ip_network(acl['CidrBlock'], strict=False):
                    #Check
       Port
                    if ((acl.get('Protocol') == '-1') or (dst_port in
       range(acl['PortRange']['From'], acl['PortRange']['To'] +1))):
          
                    #Check Action
                        if acl['RuleAction'] ==
       'allow':
                            return True
                      
        else: raise Exception('NatGateway Subnet ' + events['SrcSubnetId'] + ' Network
       Acl Egress Rules do not allow outbound traffic to destination: ' + events['DestinationIP']
       + ':' + str(events['DestinationPort']) + AWS_DOC)
        else:
       
           raise Exception('NatGateway Subnet ' + events['SrcSubnetId'] + ' Network
       Acl Egress Rules do not allow outbound traffic to destination: ' + events['DestinationIP']
       + ':' + str(events['DestinationPort']) + AWS_DOC)
        
    def check_ingress_from_dst(acls,
       src_ip):
        for acl in acls:
            # check ipv4 acl rule only

                  if acl.get('CidrBlock'):
                #Check IP
         
             if src_ip in ip_network(acl['CidrBlock'], strict=False):
         
                 #Check Port
                    if ((acl.get('Protocol') == '-1')
       or (set(range(src_port_from,src_port_to)).issubset(range(acl['PortRange']['From'],
       acl['PortRange']['To'] +1)))):
                        #Check Action
  
                            if acl['RuleAction'] == 'allow':
                  
                return True
                        else: raise Exception('NatGateway
       Subnet ' + events['SrcSubnetId'] + ' Network Acl Ingress Rules do not allow
       inbound traffic from destination: ' + events['DestinationIP'] + AWS_DOC)

              else:
            raise Exception('NatGateway Subnet ' + events['SrcSubnetId']
       + ' Network Acl Ingress Rules do not allow inbound traffic from destination:
       ' + events['DestinationIP'] + AWS_DOC)

    def check_ingress_from_src(acls,
       src_ip, dst_port):
        for acl in acls:
            # check ipv4 acl
       rule only
            if acl.get('CidrBlock'):
                #Check IP

                      if src_ip in ip_network(acl['CidrBlock'], strict=False):

                          #Check Port
                    if ((acl.get('Protocol')
       == '-1') or (dst_port in range(acl['PortRange']['From'], acl['PortRange']['To']
       +1))):
                        #Check Action
                        if
       acl['RuleAction'] == 'allow':
                            return True
 
                             else: raise Exception('NatGateway Subnet Network Acl
       Ingress Rules do not allow inbound traffic from source: ' + events['SourceIP']
       + ' towards destination port ' + str(events['DestinationPort']) + AWS_DOC)

              else:
            raise Exception('NatGateway Subnet Network Acl Ingress
       Rules do not allow inbound traffic from source: ' + events['SourceIP'] + '
       towards destination port ' + str(events['DestinationPort']) + AWS_DOC)


          def check_egress_towards_src(acls, dst_ip):
        for acl in acls:

                  # check ipv4 acl rule only
            if acl.get('CidrBlock'):

                      #Check IP
                if dst_ip in ip_network(acl['CidrBlock'],
       strict=False):
                    #Check Port
                    if ((acl.get('Protocol')
       == '-1') or (set(range(src_port_from,src_port_to)).issubset(range(acl['PortRange']['From'],
       acl['PortRange']['To'] +1)))):
                        #Check Action
  
                            if acl['RuleAction'] == 'allow':
                  
                return True
                        else: raise Exception('NatGateway
       Subnet Network Acl Egress Rules do not allow outbound traffic to source: '
       + events['SourceIP'] + AWS_DOC)
        else:
            raise Exception('NatGateway
       Subnet Network Acl Egress Rules do not allow outbound traffic to source: '
       + events['SourceIP'] + AWS_DOC)

    check_egress_towards_dst(egress_acls,
       dst_ip, dst_port)
    check_ingress_from_dst(ingress_acls, dst_ip)
    

          if src_subnet_id == nat_subnet_id:
        return True
    
    check_ingress_from_src(ingress_acls,
       src_ip, dst_port)
    check_egress_towards_src(egress_acls, src_ip)

 
         return True
"
    InputPayload:
      NatNetworkAcls: "{{getNatSubnetAcls.NatNetworkAcls}}"
      SourceIP: "{{SourceIP}}"
      DestinationIP: "{{DestinationIP}}"
      DestinationPort: "{{DestinationPort}}"
      SrcSubnetId: "{{getSourceDetails.SrcSubnetId}}"
      NatSubnetId: "{{natDestination.NatSubnetId}}"
      SourcePortRange: "{{SourcePortRange}}"
  isCritical: true
  timeoutSeconds: 30
  onFailure: "Continue"
  isEnd: false
  nextStep: "getNatRouteDetails"
- name: "getNatRouteDetails"
  action: "aws:executeScript"
  outputs:
  - Name: "NatRoutes"
    Selector: "$.Payload.NatRoutes"
    Type: "MapList"
  inputs:
    Runtime: "python3.8"
    Handler: "get_nat_route_details"
    Script: "def get_nat_route_details(events, context):
    output = {}
    import
       boto3
    ec2_client = boto3.client('ec2')
    routes = ec2_client.describe_route_tables(

              Filters=[
        {
            'Name': 'association.subnet-id',

                  'Values': [
                events['NatSubnetId']
          
        ]
        }
    ]
    )

    if len(routes['RouteTables']) > 0:
  
            routes = routes['RouteTables'][0]['Routes']
    # if RouteTable is not
       returned, this indicates association of subnet with main route table
   
       else:
        try:
            routes = ec2_client.describe_route_tables(

                      Filters=[
                    {
                        'Name':
       'association.main',
                        'Values': [
               
                   'true'
                        ]
                    },
  
                        {
                        'Name': 'vpc-id',
          
                    'Values': [
                            events['NatVpcId']

                              ]
                    }                    
    
                  ]
            )['RouteTables'][0]['Routes']
        except Exception
       as e:
            raise Exception('Could not find route table for NAT Gateway')

          
    output['NatRoutes'] = routes
    return output
"
    InputPayload:
      NatSubnetId: "{{natDestination.NatSubnetId}}"
      NatVpcId: "{{natDestination.NatVpcId}}"
  isCritical: true
  timeoutSeconds: 30
  onFailure: "Continue"
  isEnd: false
  nextStep: "getNatNextHop"
- name: "getNatNextHop"
  action: "aws:executeScript"
  inputs:
    Runtime: "python3.8"
    Handler: "get_nat_next_hop"
    Script: "def get_nat_next_hop(events, context):
    from ipaddress import ip_network,ip_address

          src_subnet_id = events['SrcSubnetId']
    nat_subnet_id = events['NatSubnetId']

      
    AWS_DOC = '
NAT gateways - Working with NAT gateways - https://docs.aws.amazon.com/vpc/latest/userguide/vpc-nat-gateway.html#nat-gateway-working-with'

      
    if src_subnet_id == nat_subnet_id:
        raise Exception('NatGateway
       and Source cannot be placed in the same subnet, NatGateway should be in a
       public subnet' + AWS_DOC)
    
    routes = events['NatRoutes'] 
    destination
       = ip_address(events['DestinationIP'])        
    most_specific = -1    
         

    for route in routes:
        if route.get('DestinationCidrBlock'):

                  mask = int(route['DestinationCidrBlock'].split('/')[1])
     
             if not 'DestinationPrefixListId' in str(route) and destination in ip_network(route['DestinationCidrBlock'],
       strict=False) and mask > most_specific:
                if route['State']
        != 'blackhole':
                    most_specific = mask
             
             next_hop = route
    #0.0.0.0/0
    if most_specific >= 0 and 'igw-'
       in str(next_hop):
        return True
    raise Exception('No Internet Gateway
       route found for destination: ' + events['DestinationIP'] + AWS_DOC)

"
    InputPayload:
      NatRoutes: "{{getNatRouteDetails.NatRoutes}}"
      DestinationIP: "{{DestinationIP}}"
      NatSubnetId: "{{natDestination.NatSubnetId}}"
      SrcSubnetId: "{{getSourceDetails.SrcSubnetId}}"
  isCritical: true
  timeoutSeconds: 30
  onFailure: "Continue"
  isEnd: false
  nextStep: "igwDestination"
- name: "peeringDestination"
  action: "aws:executeAwsApi"
  outputs:
  - Name: "VpcPeeringConnection"
    Selector: "$.VpcPeeringConnections[0]"
    Type: "StringMap"
  inputs:
    Service: "ec2"
    Api: "DescribeVpcPeeringConnections"
    Filters:
    - Name: "vpc-peering-connection-id"
      Values:
      - "{{getNextHop.NextHop}}"
  isCritical: true
  timeoutSeconds: 30
  onFailure: "Continue"
  isEnd: false
  nextStep: "checkVpcPeeringConnection"
- name: "checkVpcPeeringConnection"
  action: "aws:executeScript"
  inputs:
    Runtime: "python3.8"
    Handler: "check_vpc_peering_connection"
    Script: "def check_vpc_peering_connection(events, context):
    vpc_peering_connection
       = events['VpcPeeringConnection']
    dst_vpc = events['DestinationVpc']

          AWS_DOC = 'https://docs.aws.amazon.com/vpc/latest/peering/working-with-vpc-peering.html'

          if vpc_peering_connection['AccepterVpcInfo']['Region'] == vpc_peering_connection['RequesterVpcInfo']['Region']:

              pass
    else:
        raise Exception('Troubleshooting Cross Region
       peering connection is not yet supported')
    if dst_vpc != '':
       
       if dst_vpc in str(vpc_peering_connection):
            pass
        else:

                  raise Exception('Kindly check the VPC peering route in route table
       at the source resource subnet, it does not match the expected destination
       VPC
' + AWS_DOC)

    return True
"
    InputPayload:
      VpcPeeringConnection: "{{peeringDestination.VpcPeeringConnection}}"
      DestinationVpc: "{{DestinationVpc}}"
  isCritical: true
  timeoutSeconds: 30
  onFailure: "Abort"
  isEnd: false
  nextStep: "getDestinationPeerDetails"
- name: "getDestinationPeerDetails"
  action: "aws:executeAwsApi"
  outputs:
  - Name: "DstPeerSubnetId"
    Selector: "$.NetworkInterfaces[0].SubnetId"
    Type: "String"
  - Name: "DstPeerVpcId"
    Selector: "$.NetworkInterfaces[0].VpcId"
    Type: "String"
  inputs:
    Service: "ec2"
    Api: "DescribeNetworkInterfaces"
    Filters:
    - Name: "addresses.private-ip-address"
      Values:
      - "{{DestinationIP}}"
  isCritical: true
  timeoutSeconds: 30
  onFailure: "Continue"
  isEnd: false
  nextStep: "getDstPeerRouteDetails"
- name: "getDstPeerRouteDetails"
  action: "aws:executeScript"
  outputs:
  - Name: "Routes"
    Selector: "$.Payload.PeerRoutes"
    Type: "MapList"
  inputs:
    Runtime: "python3.8"
    Handler: "get_dst_peer_route_details"
    Script: "def get_dst_peer_route_details(events, context):
    output = {}
 
         import boto3
    ec2_client = boto3.client('ec2')
    routes = ec2_client.describe_route_tables(

              Filters=[
        {
            'Name': 'association.subnet-id',

                  'Values': [
                events['PeerSubnetId']
         
         ]
        }
    ]
    )

    if len(routes['RouteTables']) > 0:
 
             routes = routes['RouteTables'][0]['Routes']
    # if RouteTable is
       not returned, this indicates association of subnet with main route table

          else:
        try:
            routes = ec2_client.describe_route_tables(

                      Filters=[
                    {
                        'Name':
       'association.main',
                        'Values': [
               
                   'true'
                        ]
                    },
  
                        {
                        'Name': 'vpc-id',
          
                    'Values': [
                            events['PeerVpcId']

                              ]
                    }                    
    
                  ]
            )['RouteTables'][0]['Routes']
        except Exception
       as e:
            raise Exception('Could not find route table for VPC Peering
       Connection')
    
    output['PeerRoutes'] = routes
    return output
"
    InputPayload:
      PeerSubnetId: "{{getDestinationPeerDetails.DstPeerSubnetId}}"
      PeerVpcId: "{{getDestinationPeerDetails.DstPeerVpcId}}"
  isCritical: true
  timeoutSeconds: 30
  onFailure: "Continue"
  nextStep: "evalPeerRouteTable"
  isEnd: false
- name: "evalPeerRouteTable"
  action: "aws:executeScript"
  inputs:
    Runtime: "python3.8"
    Handler: "eval_peer_route_table"
    Script: "def eval_peer_route_table(events, context):
    from ipaddress import
       ip_network,ip_address
    routes = events['Routes'] 
    src_ip = ip_address(events['SourceIP'])
       
    peering_id = events['PeeringId']       
    most_specific = -1 
 
         next_hop = {}

    AWS_DOC = '
Working with VPC peering connections
       - https://docs.aws.amazon.com/vpc/latest/peering/working-with-vpc-peering.html'

          for route in routes:
        if route.get('DestinationCidrBlock'):
 
                 mask = int(route['DestinationCidrBlock'].split('/')[1])
      
            if not 'DestinationPrefixListId' in str(route) and src_ip in ip_network(route['DestinationCidrBlock'],
       strict=False) and mask > most_specific:
                if route['State']
       != 'blackhole':
                    most_specific = mask
              
            next_hop = route
    if next_hop.get('VpcPeeringConnectionId') == peering_id:

              return True
    else:
        raise Exception('Destination Subnet
       route table does not contain a valid peering route for source: ' + events['SourceIP']
       + AWS_DOC)
"
    InputPayload:
      Routes: "{{getDstPeerRouteDetails.Routes}}"
      SourceIP: "{{SourceIP}}"
      PeeringId: "{{getNextHop.NextHop}}"
  isCritical: true
  timeoutSeconds: 30
  onFailure: "Continue"
  nextStep: "localDestination"
  isEnd: false
- name: "hopTypeNotSupported"
  action: "aws:executeScript"
  inputs:
    Runtime: "python3.8"
    Handler: "hop_type_not_supported"
    Script: "def hop_type_not_supported(events, context):
    nexthop = events['NextHop']

          raise Exception('Automation detected next hop as ' + nexthop + '. Currently,
       This document supports troubleshooting destinations via local, InternetGateway,
       NatGateway & VPC Peering only. This document will now perform source side
       checks only.')
"
    InputPayload:
      NextHop: "{{getNextHop.NextHop}}"
  isCritical: true
  timeoutSeconds: 30
  onFailure: "Continue"
  nextStep: "getSrcSecurityGroupDetails"
  isEnd: false
