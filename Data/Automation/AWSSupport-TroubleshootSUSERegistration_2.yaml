description: "# AWSSupport-TroubleshootSUSERegistration
---
 This runbook checks
   if the EC2 SUSE Instance meets the prerequisites for EC2 Instances to register
   to SUSE Update Infrastructure. This includes checks related to EC2 Instance Metadata
   Service(IMDS) access, regional server access over https, SMT server access over
   http/https,smt-ec2.susecloud.net access over https and Billing Product/MarketPlace
   Product Code associated with the Amazon EC2 instance. If all the requirements
   are met, this document will register the EC2 SUSE Instance to SUSE Update Infrastructure.
   This document also fixes some known registration related issues such as Broken
   BaseProduct symbolic link, multiple entries in the file /etc/hosts related to
   the SMT server.

---

### Parameters
1. **InstanceId**: 

Type: String

  
Description: **(Required)** EC2 Instance you want to register to SUSE Update Infrastructure.
   (e.g. i-05fa91429c6cdcb39)

2.  **AutomationAssumeRole**:
Type: String


  Description: **(Optional)** IAM role which AWS Systems Manager will assume to execute
   this automation. For more information, visit - https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-setup.html
   .  If no role is specified, this document will use the permissions of the user
   that executes this document."
schemaVersion: "0.3"
outputs:
- "FinalOutput.output"
assumeRole: "{{ AutomationAssumeRole }}"
parameters:
  InstanceId:
    type: "String"
    description: "(Required) EC2 Instance you want to register to SUSE Update Infrastructure
       (e.g. i-05fa91429c6cdcb39).."
    allowedPattern: "^[m]{0,1}i-[a-z0-9]{8,17}$"
  AutomationAssumeRole:
    type: "String"
    description: "(Optional) IAM role which AWS Systems Manager will assume to execute
       this automation. For more information, visit - https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-setup.html"
    allowedPattern: "^$|^arn:aws:iam::[0-9]*:role/[/w+=,.@-]+$"
    default: ""
mainSteps:
- name: "AssertInstanceIsManagedInstance"
  action: "aws:assertAwsResourceProperty"
  description: "Confirm if the EC2 instance is a managed instance."
  inputs:
    Service: "ssm"
    Api: "DescribeInstanceInformation"
    PropertySelector: "$.InstanceInformationList[0].PingStatus"
    DesiredValues:
    - "Online"
    InstanceInformationFilterList:
    - key: "InstanceIds"
      valueSet:
      - "{{ InstanceId }}"
  nextStep: "ConfirmSuseOS"
  timeoutSeconds: 300
  maxAttempts: 2
- name: "ConfirmSuseOS"
  action: "aws:runCommand"
  inputs:
    DocumentName: "AWS-RunShellScript"
    InstanceIds:
    - "{{ InstanceId }}"
    Parameters:
      commands: "#!/bin/bash

# baseproduct symbolic link should reference if SLES
         for SAP
readonly SAP_BASEPRODUCT="/etc/products.d/SLES_SAP.prod"
# baseproduct
         symbolic link should reference if SLES
readonly SLES_BASEPRODUCT="/etc/products.d/SLES.prod"
        
# Is this SLES-SAP or SLES?
function os() {
  echo "1. Checking if the
         EC2 instance is based on SUSE Enterprise Linux."
  if test -f "${SAP_BASEPRODUCT}"
        ; then
  echo "[Passed] $( hostnamectl  | grep -i "Operating System" )"
        
  elif test -f "${SLES_BASEPRODUCT}"; then
  echo "[Passed] $( hostnamectl
          | grep -i "Operating System" )"
  else 
    echo "[Failed] No supported
         OS. Exiting."
texit 1
  fit
}

os


"
  description: "Confirm if the EC2 instance is based on SUSE Enterprise Linux."
  timeoutSeconds: 300
- name: "CheckcloudregionsrvclientpackageVersion"
  action: "aws:runCommand"
  inputs:
    DocumentName: "AWS-RunShellScript"
    InstanceIds:
    - "{{ InstanceId }}"
    Parameters:
      commands: "#!/bin/bash

# baseproduct symbolic link should reference if SLES
         for SAP
readonly SAP_BASEPRODUCT="/etc/products.d/SLES_SAP.prod"
# baseproduct
         symbolic link should reference if SLES

readonly SLES_BASEPRODUCT="/etc/products.d/SLES.prod"
        

# Is this SLES-SAP or SLES?
function os() {
  if test -f "${SAP_BASEPRODUCT}"
        ; then

  OS="SAP"
  baseversion="$(awk -F'[<>]' '/<baseversion>/{print
         $3}' ${SAP_BASEPRODUCT} )"
  slebase="SLE${baseversion}"
  arch="
        $(awk -F'[<>]' '/<arch>/{print $3}' ${SAP_BASEPRODUCT} )"

  elif test
         -f "${SLES_BASEPRODUCT}"; then
  OS="SLES"
  baseversion="$(awk -F'[<>]'
         '/<baseversion>/{print $3}' ${SLES_BASEPRODUCT})"
  slebase="SLE${baseversion}"
        
  arch="$(awk -F'[<>]' '/<arch>/{print $3}' ${SLES_BASEPRODUCT})"


          else 
  exit 1
  fi  
}
# functions to verify if package versions are
         less than equal
function verlte() {
  [  "${1}" = "`echo -e "${1}
        n${2}" | sort -V | head -n1`" ]
}

function verlt() {
  [ "${1}" =
         "${2}" ] && return 1 || verlte "${1}" "${2}"
}

# Check that package
         versions are at minimum recommended
function check_regionclient_version()
         {
  echo "2. Checking if the package cloud-regionsrv-client version is
         higher or equal than the required version 9.0.0"
  local required_version="
        9.0.0"
  local installed_version="$(rpm -q cloud-regionsrv-client --queryformat
         "%{VERSION}")"
  if verlt $installed_version $required_version; then

          if [ $baseversion == 12 ]  || [ $baseversion == 15 ] && [ $arch == "aarch64"
         ]  || [ $arch == "x86_64" ]; then  
techo "PROBLEM: Update infrastructure
         packages need to be updated manually."

  echo "=============Solution============="
        

  echo "Follow below steps to download package and Install it on your
         EC2 instance:

wget --no-check-certificate https://52.15.49.139/late_instance_offline_update_ec2_${arch}_$slebase.tar.gz

        
sha1sum late_instance_offline_update_ec2_${arch}_$slebase.tar.gz

tar
         -xf late_instance_offline_update_ec2_${arch}_$slebase.tar.gz

cd $arch

        
zypper --no-refresh --no-remote --non-interactive in *.rpm

/usr/sbin/registercloudguest
         --force-new"


echo "==============End================="

texit
         1
fi
  else 
techo "[Passed] cloud-regionsrv-client package version
         is OK."
  fi
}


os
check_regionclient_version





"
  description: "Check if the package cloud-regionsrv-client version is higher or equal
     than the required version 9.0.10"
  timeoutSeconds: 300
- name: "CheckBaseProduct"
  action: "aws:runCommand"
  description: "Checking baseproduct symbolic link."
  inputs:
    DocumentName: "AWS-RunShellScript"
    InstanceIds:
    - "{{ InstanceId }}"
    Parameters:
      commands: "#!/bin/bash

# baseproduct symbolic link should reference if SLES
         for SAP
readonly SAP_BASEPRODUCT="/etc/products.d/SLES_SAP.prod"
# baseproduct
         symbolic link should reference if SLES
readonly SLES_BASEPRODUCT="/etc/products.d/SLES.prod"
        
# If baseproduct symbolic link is wrong, there can be update issues
# Check
         if baseproduct link is correct for installed OS and fix it if not
function
         check_baseproduct() {
  echo "3. Checking if baseproduct symbolic link
         is broken or not"
  local baseproduct_file="/etc/products.d/baseproduct"
        
  local baselink="$(readlink -f ${baseproduct_file})"
  if test -f "
        ${SAP_BASEPRODUCT}"; then
    if [[ "${baselink}" = "${SAP_BASEPRODUCT}"
         ]]; then
t  echo "[Passed] baseproduct OK"
    else
t  echo "Baseproduct
         problem found. Fixing..."
t  ln -sf "${SAP_BASEPRODUCT}" "${baseproduct_file}"
        
    echo "[Passed] Baseproduct problem fixed."
    fi
  elif test -f
         "${SLES_BASEPRODUCT}"; then
tif [[ "${baselink}" = "${SLES_BASEPRODUCT}"
         ]]; then
tttecho "[Passed] baseproduct OK"
telse
tttecho "
        Baseproduct problem found. Fixing..."
tttln -sf "${SLES_BASEPRODUCT}"
         "${baseproduct_file}"
      echo "[Passed] Baseproduct problem fixed."
        
tfi
  else
  exit 1
  fi
}
check_baseproduct


"
  onFailure: "Continue"
  timeoutSeconds: 300
- name: "CheckHostsFileForMultipleRecords"
  action: "aws:runCommand"
  inputs:
    Parameters:
      commands: "#!/bin/bash

# If there are multiple SMT entries in /etc/hosts,
         there can be update issues
# Check /etc/hosts files for problems and fix
         if there are
function check_hosts() {
  ETC_HOSTS="/etc/hosts"
  PATTERN1="
        smt-ec2.susecloud.net"
  PATTERN2="Added by SMT registration do not remove."
        
  echo "4.a Checking /etc/hosts for multiple records about smt-ec2.susecloud.net"
        
  NUM_HOST_ENTRIES="$(grep -c $PATTERN1 $ETC_HOSTS)"
  if [[ "${NUM_HOST_ENTRIES}"
         -ge 2 ]]; then
    COUNT="$((COUNT+1))"
techo "[Failed] PROBLEM: Multiple
         SMT records exist, deleting."
    delete_hosts
  elif [[ "${NUM_HOST_ENTRIES}"
         -eq 0 ]]; then
    COUNT="$((COUNT+1))"
    echo "[Warning] Warning:
         No SMT records exist in the file /etc/hosts."
  else
techo "[Passed]
         File /etc/hosts is OK."
t# Now check that the hosts records matches correct
         region
tcheck_current_smt
  fi
}
# Metadata access is required. Check
         metadata is accessible
function check_metadata() {
  if [[ "${AWS_SSM_INSTANCE_ID}"
         =~ ^[i]-[a-z0-9]{8,17}$ ]]; then
    local company="amazon"
    local
         http_code=$(curl -m 5 -s -o /dev/null -w "%{http_code}" http://169.254.169.254/latest/meta-data/)

            local http_code_token=$(curl -m 5 -s -o /dev/null -w "%{http_code}"
         -X PUT "http://169.254.169.254/latest/api/token" -H "X-aws-ec2-metadata-token-ttl-seconds:
         21600")
    if [ $http_code -eq "200" ]; then
      check_region=$(curl
         http://169.254.169.254/latest/meta-data/placement/region 2>/dev/null )

            else
    TOKEN=`curl -X PUT "http://169.254.169.254/latest/api/token"
         -H "X-aws-ec2-metadata-token-ttl-seconds: 21600" 2>/dev/null `
    check_region=$(curl
         -H "X-aws-ec2-metadata-token: $TOKEN" http://169.254.169.254/latest/meta-data/placement/region
         2>/dev/null )
    fi
    if [[ -z "${check_region}" ]] || [[ ${#check_region}
         -gt 25 ]]; then
      exit 1
    else
      local CMD1="grep -o '[0-9]
        +[.][0-9]+[.][0-9]+[.][0-9]+' | tr '
' ' '"
      local CMD="grep
         -oP '(([0-9]{1,3}.){3}[0-9]{1,3})(" region="$check_region"
        />)'"
      # Get SMT servers that are in region
      local get_smt="
        $(echo ${!company} | eval $CMD | eval $CMD1)"
      smt_servers=( $get_smt
         )
      echo $smt_servers > /tmp/smtserver
    fi
  fi
}

# Check
         if current smt server in /etc/hosts is region correct
function check_current_smt()
         {
  echo "4.b Checking SMT server entry is correct in /etc/hosts."

          # Get current /etc/hosts
  local smt_ip="$(getent hosts smt-ec2.susecloud.net
         | awk {'print $1'})"

  if [[ "${smt_servers[@]}" =~ "${smt_ip}"
         ]]; then
    echo "[Passed] SMT server entry OK"
  fi

  if [[ ! "
        ${smt_servers[@]}" =~ "${smt_ip}" ]]; then
    echo "[Warning] PROBLEM:
         SMT server entry is for wrong region."
  fi
}  
# Delete /etc/hosts
         entry
function delete_hosts() {
# backup the file /etc/hosts before removing
         the duplicate line of smt-ec2.susecloud.net
echo "[Passed] Backup the
         file /etc/hosts to /etc/hosts.backup before removing the duplicate line
         of smt-ec2.susecloud.net."
cp  /etc/hosts /etc/hosts.backup

  sed --in-place=.sc-repocheck
         "/$PATTERN1/d" $ETC_HOSTS
  sed -i "/$PATTERN2/d" $ETC_HOSTS
echo
         "[Passed] SMT Duplicate lines removed from the file /etc/hosts"
}
amazon=$(cat
         <<EOF
<?xml version='1.0' encoding='UTF-8'?>
<servers>
  <server type="
        smt" name="smt-ec2.susecloud.net" ip="13.244.54.57" region="af-south-1"
        />
  <server type="smt" name="smt-ec2.susecloud.net" ip="13.244.40.27"
         region="af-south-1"/>
  <server type="smt" name="smt-ec2.susecloud.net"
         ip="13.245.60.134" region="af-south-1"/>
  <server type="smt" name="
        smt-ec2.susecloud.net" ip="18.162.90.181" region="ap-east-1"/>
  <server
         type="smt" name="smt-ec2.susecloud.net" ip="18.162.132.113" region="
        ap-east-1"/>
  <server type="smt" name="smt-ec2.susecloud.net" ip="
        18.162.83.253" region="ap-east-1"/>
  <server type="smt" name="smt-ec2.susecloud.net"
         ip="54.248.86.233" region="ap-northeast-1"/>
  <server type="smt"
         name="smt-ec2.susecloud.net" ip="54.248.240.93" region="ap-northeast-1"
        />
  <server type="smt" name="smt-ec2.susecloud.net" ip="54.248.226.128"
         region="ap-northeast-1"/>
  <server type="smt" name="smt-ec2.susecloud.net"
         ip="52.79.38.96" region="ap-northeast-2"/>
  <server type="smt" name="
        smt-ec2.susecloud.net" ip="52.79.39.98" region="ap-northeast-2"/>
 
         <server type="smt" name="smt-ec2.susecloud.net" ip="52.79.134.51"
         region="ap-northeast-2"/>
  <server type="smt" name="smt-ec2.susecloud.net"
         ip="52.66.49.238" region="ap-south-1"/>
  <server type="smt" name="
        smt-ec2.susecloud.net" ip="52.66.45.16" region="ap-south-1"/>
  <server
         type="smt" name="smt-ec2.susecloud.net" ip="52.66.51.63" region="
        ap-south-1"/>
  <server type="smt" name="smt-ec2.susecloud.net" ip="
        122.248.246.124" region="ap-southeast-1"/>
  <server type="smt" name="
        smt-ec2.susecloud.net" ip="54.254.106.151" region="ap-southeast-1"/>

          <server type="smt" name="smt-ec2.susecloud.net" ip="54.251.254.125"
         region="ap-southeast-1"/>
  <server type="smt" name="smt-ec2.susecloud.net"
         ip="54.253.249.15" region="ap-southeast-2"/>
  <server type="smt"
         name="smt-ec2.susecloud.net" ip="54.253.114.150" region="ap-southeast-2"
        />
  <server type="smt" name="smt-ec2.susecloud.net" ip="54.66.121.137"
         region="ap-southeast-2"/>
  <server type="smt" name="smt-ec2.susecloud.net"
         ip="52.60.53.175" region="ca-central-1"/>
  <server type="smt" name="
        smt-ec2.susecloud.net" ip="52.60.53.224" region="ca-central-1"/>
  <server
         type="smt" name="smt-ec2.susecloud.net" ip="52.60.50.162" region="
        ca-central-1"/>
  <server type="smt" name="smt-ec2.susecloud.net" ip="
        54.223.131.108" region="cn-north-1"/>
  <server type="smt" name="smt-ec2.susecloud.net"
         ip="54.223.140.138" region="cn-north-1"/>
  <server type="smt" name="
        smt-ec2.susecloud.net" ip="54.222.142.49" region="cn-north-1"/>
  <server
         type="smt" name="smt-ec2.susecloud.net" ip="52.83.151.90" region="
        cn-northwest-1"/>
  <server type="smt" name="smt-ec2.susecloud.net"
         ip="52.83.113.211" region="cn-northwest-1"/>
  <server type="smt"
         name="smt-ec2.susecloud.net" ip="52.83.247.110" region="cn-northwest-1"
        />
  <server type="smt" name="smt-ec2.susecloud.net" ip="54.93.130.182"
         region="eu-central-1"/>
  <server type="smt" name="smt-ec2.susecloud.net"
         ip="54.93.131.24" region="eu-central-1"/>
  <server type="smt" name="
        smt-ec2.susecloud.net" ip="52.28.214.37" region="eu-central-1"/>
  <server
         type="smt" name="smt-ec2.susecloud.net" ip="15.161.33.0" region="
        eu-south-1"/>
  <server type="smt" name="smt-ec2.susecloud.net" ip="
        15.161.39.2" region="eu-south-1"/>
  <server type="smt" name="smt-ec2.susecloud.net"
         ip="15.161.27.146" region="eu-south-1"/>
  <server type="smt" name="
        smt-ec2.susecloud.net" ip="13.53.91.131" region="eu-north-1"/>
  <server
         type="smt" name="smt-ec2.susecloud.net" ip="13.53.91.167" region="
        eu-north-1"/>
  <server type="smt" name="smt-ec2.susecloud.net" ip="
        13.53.77.232" region="eu-north-1"/>
  <server type="smt" name="smt-ec2.susecloud.net"
         ip="54.246.90.215" region="eu-west-1"/>
  <server type="smt" name="
        smt-ec2.susecloud.net" ip="54.75.232.245" region="eu-west-1"/>
  <server
         type="smt" name="smt-ec2.susecloud.net" ip="176.34.126.172" region="
        eu-west-1"/>
  <server type="smt" name="smt-ec2.susecloud.net" ip="
        52.56.58.194" region="eu-west-2"/>
  <server type="smt" name="smt-ec2.susecloud.net"
         ip="52.56.58.190" region="eu-west-2"/>
  <server type="smt" name="
        smt-ec2.susecloud.net" ip="52.56.59.89" region="eu-west-2"/>
  <server
         type="smt" name="smt-ec2.susecloud.net" ip="52.47.108.87" region="
        eu-west-3"/>
  <server type="smt" name="smt-ec2.susecloud.net" ip="
        52.47.113.10" region="eu-west-3"/>
  <server type="smt" name="smt-ec2.susecloud.net"
         ip="52.47.92.102" region="eu-west-3"/>
  <server type="smt" name="
        smt-ec2.susecloud.net" ip="15.185.47.44" region="me-south-1"/>
  <server
         type="smt" name="smt-ec2.susecloud.net" ip="157.175.138.207" region="
        me-south-1"/>
  <server type="smt" name="smt-ec2.susecloud.net" ip="
        157.175.6.182" region="me-south-1"/>
  <server type="smt" name="smt-ec2.susecloud.net"
         ip="177.71.187.15" region="sa-east-1"/>
  <server type="smt" name="
        smt-ec2.susecloud.net" ip="54.232.112.38" region="sa-east-1"/>
  <server
         type="smt" name="smt-ec2.susecloud.net" ip="54.232.114.156" region="
        sa-east-1"/>
  <server type="smt" name="smt-ec2.susecloud.net" ip="
        54.197.240.216" region="us-east-1"/>
  <server type="smt" name="smt-ec2.susecloud.net"
         ip="54.225.105.144" region="us-east-1"/>
  <server type="smt" name="
        smt-ec2.susecloud.net" ip="107.22.231.220" region="us-east-1"/>
  <server
         type="smt" name="smt-ec2.susecloud.net" ip="52.15.49.139" region="
        us-east-2"/>
  <server type="smt" name="smt-ec2.susecloud.net" ip="
        52.15.84.50" region="us-east-2"/>
  <server type="smt" name="smt-ec2.susecloud.net"
         ip="52.15.50.30" region="us-east-2"/>
  <server type="smt" name="
        smt-ec2.susecloud.net" ip="50.18.104.175" region="us-west-1"/>
  <server
         type="smt" name="smt-ec2.susecloud.net" ip="50.18.105.39" region="
        us-west-1"/>
  <server type="smt" name="smt-ec2.susecloud.net" ip="
        54.215.80.72" region="us-west-1"/>
  <server type="smt" name="smt-ec2.susecloud.net"
         ip="54.244.114.254" region="us-west-2"/>
  <server type="smt" name="
        smt-ec2.susecloud.net" ip="54.245.112.93" region="us-west-2"/>
  <server
         type="smt" name="smt-ec2.susecloud.net" ip="54.245.101.73" region="
        us-west-2"/>
</servers>
EOF
)
# Run all checks
 check_metadata
 check_hosts

        
"
    DocumentName: "AWS-RunShellScript"
    InstanceIds:
    - "{{ InstanceId }}"
  description: "Checking the file /etc/hosts for multiple records of smt-ec2.susecloud.net"
  onFailure: "Continue"
  timeoutSeconds: 300
- name: "CheckifCurlexists"
  action: "aws:runCommand"
  inputs:
    DocumentName: "AWS-RunShellScript"
    InstanceIds:
    - "{{ InstanceId }}"
    Parameters:
      commands: "#!/bin/bash
# Billing Code or marketplaceProductCodes is required.
         Check if the instance has a Billing Code or marketplaceProductCodes
function
         check_curl_command() {
    echo "5. Checking If curl package is installed."
        
    local Is_Installed=$(which curl)
    if [[ -n "${Is_Installed}" ]]
         ; then
     echo "[Passed] Curl package is installed."
    else   

            echo "[Failed] You need to install the curl package to run this SSM
         automation document AWSSupport-TroubleshootSUSERegistration: sudo zypper
         in curl"
    exit 1
    fi
}
check_curl_command


"
  description: "Check if the curl command is installed"
  timeoutSeconds: 300
- name: "CheckIMDSAccess"
  action: "aws:runCommand"
  inputs:
    DocumentName: "AWS-RunShellScript"
    InstanceIds:
    - "{{ InstanceId }}"
    Parameters:
      commands: "#!/bin/bash
# Metadata access is required. Check metadata is accessible

        function check_metadata() {
  echo "6. Checking if Instance Metadata service
         (IMDS) 169.254.169.254 is accessible."
  local http_code=$(curl -m 5 -s
         -o /dev/null -w "%{http_code}" http://169.254.169.254/latest/meta-data/)

          local http_code_token=$(curl -m 5 -s -o /dev/null -w "%{http_code}" -X
         PUT "http://169.254.169.254/latest/api/token" -H "X-aws-ec2-metadata-token-ttl-seconds:
         21600")
  if [ $http_code -eq "200" ]; then
    echo "[Passed] Instance
         Meta Data Service(IMDSv1) 169.254.169.254 access is OK."
  elif [ $http_code_token
         -eq "200" ]; then
    echo "[Passed] Instance Meta Data Service(IMDSv2)
         169.254.169.254 access is OK."
  else
  echo "[Failed] PROBLEM: Instance
         Meta Data Service is not accessible. Fix access to Instance Meta Data Service
         at 169.254.169.254"
  exit 1
  fi
}
check_metadata


"
  description: "Metadata service 169.254.169.254 access is required. Checking metadata
     is accessible."
  onFailure: "Continue"
  maxAttempts: 2
  timeoutSeconds: 300
- name: "CheckOnDemandSUSESubscriptionCode"
  action: "aws:runCommand"
  inputs:
    DocumentName: "AWS-RunShellScript"
    InstanceIds:
    - "{{ InstanceId }}"
    Parameters:
      commands: "#!/bin/bash
# Function to detect all the proxy information: http_proxy,https_proxy
         and credentials
function check_proxy() {
  # Check if proxy is configured
         in the file /etc/sysconfig/proxy 
  local proxy_enabled=$(cat /etc/sysconfig/proxy
         | grep -i PROXY_ENABLED | grep -i yes)
    if [[ -n "${proxy_enabled}"
         ]] ; then
     http_proxy=$(cat /etc/sysconfig/proxy | grep -i http_proxy
         | awk -F "=" '{ print $2 }' | sed -e "s/"//g" | sed -e "s/ //g"
        )
     https_proxy=$(cat /etc/sysconfig/proxy | grep -i https_proxy | awk
         -F "=" '{ print $2 }' | sed -e "s/"//g" | sed -e "s/ //g")
  
          if [[ -n "${http_proxy}" ]] && [[ -n "${https_proxy}" ]]  ; then

               echo "${http_proxy}" | grep -o '[0-9]+[.][0-9]+[.][0-9]+[.][0-9]
        +' > /dev/null 2>&1 || echo "${http_proxy}" | grep -P '(?:https?://)'
         > /dev/null 2>&1

     if [[ $? -eq 0 ]] ; then 
     is_proxy=true

               no_proxy=$(cat /etc/sysconfig/proxy | grep -i no_proxy | grep "169.254.169.254"
        )
       if [ -n "${no_proxy}" ]  ; then      
       echo "[Passed]
         Proxy configuration is OK."
       else
       echo "[Failed] You need
         to configure the instance metadata service IP 169.254.169.254 in the NO_PROXY
         environment variable in the file /etc/sysconfig/proxy. More information
         here: https://www.suse.com/support/kb/doc/?id=000017441"
       exit 1

               fi
     fi    
    fi
    # Check if proxy is configured in the
         file /root/.bashrc
    elif [ -f /root/.bashrc ] ; then
     http_proxy=$(cat
         /root/.bashrc | grep -i http_proxy | awk -F "=" '{ print $2 }' | sed -e
         "s/"//g" | sed -e "s/ //g")
     https_proxy=$(cat /root/.bashrc|
         grep -i https_proxy | awk -F "=" '{ print $2 }' | sed -e "s/"//g"
         | sed -e "s/ //g")
    if [[ -n "${http_proxy}" ]] && [[ -n "${https_proxy}"
         ]]  ; then
    echo "${http_proxy}" | grep -o '[0-9]+[.][0-9]+[.][0-9]
        +[.][0-9]+' > /dev/null 2>&1 || echo "${http_proxy}" | grep -P '(?:https?:
        //)' > /dev/null 2>&1

     if [[ $? -eq 0 ]] ; then 
     is_proxy=true

               no_proxy=$(cat /root/.bashrc | grep -i no_proxy | grep "169.254.169.254"
        )
       if [ -n "${no_proxy}" ]  ; then      
       echo "[Passed]
         Proxy configuration is OK."
       else
       echo "[Failed] You need
         to configure the instance metadata service IP 169.254.169.254 in the NO_PROXY
         environment variable in the file /root/.bashrc. More information here :
         https://www.suse.com/support/kb/doc/?id=000017441"
       exit 1
   
            fi
     fi
    fi
    else
     is_proxy=false
    fi

}
# Billing
         Code or marketplaceProductCodes is required. Check if the instance has a
         Billing Code or marketplaceProductCodes
function check_Ondemand_SUSE_Subscription()
         {
  if [[ "${AWS_SSM_INSTANCE_ID}" =~ ^[i]-[a-z0-9]{8,17}$ ]]; then

            local api_call="curl http://169.254.169.254/latest/dynamic/instance-identity/document"
        
    echo "7. Checking if Billing Code or Marketplace Product Code is available."
        
    local http_code=$(curl -m 5 -s -o /dev/null -w "%{http_code}" http://169.254.169.254/latest/meta-data/)

            local http_code_token=$(curl -m 5 -s -o /dev/null -w "%{http_code}"
         -X PUT "http://169.254.169.254/latest/api/token" -H "X-aws-ec2-metadata-token-ttl-seconds:
         21600")
    if [ $http_code -eq "200" ]; then
    billing_code=$( $api_call
         2>/dev/null | grep -i billingProducts | grep -v null)
    marketplace_code=$(
         $api_call 2>/dev/null | grep -i marketplaceProductCodes | grep -v null)

            else
    TOKEN=`curl -X PUT "http://169.254.169.254/latest/api/token"
         -H "X-aws-ec2-metadata-token-ttl-seconds: 21600" 2>/dev/null `
    billing_code=$(curl
         -H "X-aws-ec2-metadata-token: $TOKEN" $api_call 2>/dev/null | grep billingProducts
         | grep -v null)
    marketplace_code=$(curl -H "X-aws-ec2-metadata-token:
         $TOKEN" $api_call 2>/dev/null | grep marketplaceProductCodes | grep -v
         null)
    fi
      if [[ -n "${billing_code}" ]] ; then
      echo
         "[Passed] Your EC2 instance has a billing code as AWS On-demand SUSE Subscription
         to update your EC2 instance."
      elif [[ -n "${marketplace_code}"
         ]] ; then 
      echo "[Passed] Your EC2 instance has a Marketplace Product
         Code as AWS On-demand SUSE Subscription to update your EC2 instance."

              else  
      echo "[Failed] Your EC2 instance doesn't have neither
         a Billing Code nor Marketplace Product Code. To solve this issue , you can
         refer to this article: https://www.suse.com/support/kb/doc/?id=000019601."
        
      exit 1
      fi
    fi
}
check_proxy
check_Ondemand_SUSE_Subscription

        
"
  description: "Billing Code or marketplaceProductCodes is required. Check if the
     instance has a Billing Code  or marketplaceProductCodes"
  maxAttempts: 2
  onFailure: "Abort"
  timeoutSeconds: 300
- name: "AccessRegionServerOverHttps"
  action: "aws:runCommand"
  description: "Check if the EC2 instance has access to at least 1 region server over
     https"
  inputs:
    Parameters:
      commands: "#!/bin/bash

# Function to detect all the proxy information: http_proxy,https_proxy
         and credentials
function check_proxy() {

  # check if proxy is configured
         here /etc/sysconfig/proxy 

  local proxy_enabled=$(cat /etc/sysconfig/proxy
         | grep -i PROXY_ENABLED | grep -i yes)
    if [[ -n "${proxy_enabled}"
         ]] ; then
     http_proxy=$(cat /etc/sysconfig/proxy | grep -i http_proxy
         | awk -F "=" '{ print $2 }' | sed -e "s/"//g" | sed -e "s/ //g"
        )
     https_proxy=$(cat /etc/sysconfig/proxy | grep -i https_proxy | awk
         -F "=" '{ print $2 }' | sed -e "s/"//g" | sed -e "s/ //g")
  
          if [[ -n "${http_proxy}" ]] && [[ -n "${https_proxy}" ]]  ; then

            echo "${http_proxy}" | grep -o '[0-9]+[.][0-9]+[.][0-9]+[.][0-9]
        +' > /dev/null 2>&1 || echo "${http_proxy}" | grep -P '(?:https?://)'
         > /dev/null 2>&1

    if [[ $? -eq 0 ]] ; then 
     is_proxy=true

            fi
    else
     is_proxy=false
    fi
    # check if proxy is configured
         here /root/.bashrc
    elif [ -f /root/.bashrc ] ; then
     http_proxy=$(cat
         /root/.bashrc | grep -i http_proxy | awk -F "=" '{ print $2 }' | sed -e
         "s/"//g" | sed -e "s/ //g")
     https_proxy=$(cat /root/.bashrc|
         grep -i https_proxy | awk -F "=" '{ print $2 }' | sed -e "s/"//g"
         | sed -e "s/ //g")
    if [[ -n "${http_proxy}" ]] && [[ -n "${https_proxy}"
         ]]  ; then
    echo "${http_proxy}" | grep -o '[0-9]+[.][0-9]+[.][0-9]
        +[.][0-9]+' > /dev/null 2>&1 || echo "${http_proxy}" | grep -P '(?:https?:
        //)' > /dev/null 2>&1

    if [[ $? -eq 0 ]] ; then 
     is_proxy=true

            fi
    else
     is_proxy=false
    fi
    else
     is_proxy=false

            fi
if [ "$is_proxy" = false ] ; then
     proxy_credentials=false

        else
    curlrc=/root/.curlrc
    if [ -f $curlrc ] ; then 
      proxy_user=$(cat
         /root/.curlrc | grep -i proxy-user | awk -F "=" '{ print $2 }' | sed -e
         "s/"//g" | sed -e "s/ //g")
       if [[ -n "${proxy_user}" ]]
         ; then
        proxy_credentials=true   
       else   
        proxy_credentials=false

               fi
    else
     proxy_credentials=false
    fi
fi
}

# Check
         if the instance has access to at least 1 region server over https
function
         check_region_servers() {
  if [[ "${AWS_SSM_INSTANCE_ID}" =~ ^[i]-[a-z0-9]{8,17}$
         ]]; then
    echo "8. Checking if the EC2 instance has access to at least
         1 region server over https."
    local good_count=0
    local ssl_count=0

            local timeout_count=0
    local req_count=0
    local regsrv_cnt=0

            if test -f /etc/regionserverclnt.cfg ; then
    local regsrv_cnt=$(cat
         /etc/regionserverclnt.cfg | grep regionsrv | awk {'print $3'} | awk -F '[
        t,]' '{print  NF}')
    local get_region_servers="$(cat /etc/regionserverclnt.cfg
         | grep regionsrv | awk {'print $3'})"
    IFS=', ' read -r -a region_servers
         <<< "$get_region_servers"
    local company="amazon"
    local http_code=$(curl
         -m 5 -s -o /dev/null -w "%{http_code}" http://169.254.169.254/latest/meta-data/)

            local http_code_token=$(curl -m 5 -s -o /dev/null -w "%{http_code}"
         -X PUT "http://169.254.169.254/latest/api/token" -H "X-aws-ec2-metadata-token-ttl-seconds:
         21600")
    if [ $http_code -eq "200" ]; then
    check_region=$(curl
         http://169.254.169.254/latest/meta-data/placement/region 2>/dev/null )

            else
    TOKEN=`curl -X PUT "http://169.254.169.254/latest/api/token"
         -H "X-aws-ec2-metadata-token-ttl-seconds: 21600" 2>/dev/null `
    check_region=$(curl
         -H "X-aws-ec2-metadata-token: $TOKEN" http://169.254.169.254/latest/meta-data/placement/region
         2>/dev/null )
    fi
    for i in "${region_servers[@]}"; do
     
         if [ "$is_proxy" = false ] ; then
      local https_return_code=$(curl
         -k -m 5 -s -o /dev/null -w "%{http_code}" https://$i/regionInfo?regionHint=${check_region}
         --cacert /var/lib/regionService/certs/$i.pem)
      elif [ "$is_proxy"
         = true ] && [ "$proxy_credentials" = true ] ; then
      local https_return_code=$(curl
         -k -m 5 -s -o /dev/null -w "%{http_code}" https://$i/regionInfo?regionHint=${check_region}
         --cacert /var/lib/regionService/certs/$i.pem --proxy $https_proxy --proxy-user
         $proxy_user )
      else
      local https_return_code=$(curl -k -m 5
         -s -o /dev/null -w "%{http_code}" https://$i/regionInfo?regionHint=${check_region}
         --cacert /var/lib/regionService/certs/$i.pem --proxy $https_proxy)
   
           fi
    if [ $https_return_code -eq "200" ]; then
      good_count=$((good_count+1))

            elif [ $https_return_code -eq "503" ]; then
      ssl_count=$((ssl_count+1))

            elif [ $https_return_code -eq "000" ]; then
      timeout_count=$((timeout_count+1))

            else
      req_count=$((req_count+1))
    fi
    done

    if [
         $regsrv_cnt -eq $timeout_count ]; then
    echo "[Failed] PROBLEM: No
         access to a region server. Open port 443 for outbound communication to a
         region server:"
    echo "${region_servers[*]}"
    exit 1
    elif
         [ $regsrv_cnt -eq $ssl_count ]; then
    echo "[Failed] PROBLEM: MITM
         proxy misconfiguration. Proxy cannot intercept certs in /var/lib/regionService/certs.
         Please exclude the below IPs from SSL interception in your proxy:"
  
          echo "${region_servers[*]}"
    exit 1
    elif [ $regsrv_cnt -eq $req_count
         ]; then
    echo "[Failed] PROBLEM: No access to a region server."

            echo "${region_servers[*]}"
    exit 1
    else
    echo "[Passed]
         Region server access is OK."
    fi

  else
  echo "[Failed] PROBLEM:
         The package regionServiceClientConfigEC2 is not installed in your EC2 Instance.
         You need to install the package regionServiceClientConfigEC2 and run the
         Automation document again."
  exit 1
  fi
fi
}
 check_proxy
 check_region_servers
         


"
    DocumentName: "AWS-RunShellScript"
    InstanceIds:
    - "{{ InstanceId }}"
  onFailure: "Continue"
  timeoutSeconds: 300
- name: "CheckHttpAccessToSMTServers"
  action: "aws:runCommand"
  description: "If EC2 instance isn't yet set for https_only, check if outbound traffic
     over port 80 is open to SMT servers. If it's closed, report and exit."
  inputs:
    DocumentName: "AWS-RunShellScript"
    InstanceIds:
    - "{{ InstanceId }}"
    Parameters:
      commands: "#!/bin/bash
# Function to detect all the proxy information: http_proxy,https_proxy
         and credentials
function check_proxy() {
  # check if proxy is configured
         here /etc/sysconfig/proxy 
   local proxy_enabled=$(cat /etc/sysconfig/proxy
         | grep -i PROXY_ENABLED | grep -i yes)
    if [[ -n "${proxy_enabled}"
         ]] ; then
     http_proxy=$(cat /etc/sysconfig/proxy | grep -i http_proxy
         | awk -F "=" '{ print $2 }' | sed -e "s/"//g" | sed -e "s/ //g"
        )
     https_proxy=$(cat /etc/sysconfig/proxy | grep -i https_proxy | awk
         -F "=" '{ print $2 }' | sed -e "s/"//g" | sed -e "s/ //g")
  
          if [[ -n "${http_proxy}" ]] && [[ -n "${https_proxy}" ]]  ; then

            echo "${http_proxy}" | grep -o '[0-9]+[.][0-9]+[.][0-9]+[.][0-9]
        +' > /dev/null 2>&1 || echo "${http_proxy}" | grep -P '(?:https?://)'
         > /dev/null 2>&1

    if [[ $? -eq 0 ]] ; then 
     is_proxy=true

            fi
    else
     is_proxy=false
    fi
    # check if proxy is configured
         here /root/.bashrc
    elif [ -f /root/.bashrc ] ; then
     http_proxy=$(cat
         /root/.bashrc | grep -i http_proxy | awk -F "=" '{ print $2 }' | sed -e
         "s/"//g" | sed -e "s/ //g")
     https_proxy=$(cat /root/.bashrc|
         grep -i https_proxy | awk -F "=" '{ print $2 }' | sed -e "s/"//g"
         | sed -e "s/ //g")
    if [[ -n "${http_proxy}" ]] && [[ -n "${https_proxy}"
         ]]  ; then
    echo "${http_proxy}" | grep -o '[0-9]+[.][0-9]+[.][0-9]
        +[.][0-9]+' > /dev/null 2>&1 || echo "${http_proxy}" | grep -P '(?:https?:
        //)' > /dev/null 2>&1

    if [[ $? -eq 0 ]] ; then 
     is_proxy=true

            fi
    else
     is_proxy=false
    fi
    else
     is_proxy=false

            fi
if [ "$is_proxy" = false ] ; then
     proxy_credentials=false

        else
    curlrc=/root/.curlrc
    if [ -f $curlrc ] ; then 
      proxy_user=$(cat
         /root/.curlrc | grep -i proxy-user | awk -F "=" '{ print $2 }' | sed -e
         "s/"//g" | sed -e "s/ //g")
       if [[ -n "${proxy_user}" ]]
         ; then
        proxy_credentials=true
       else
        proxy_credentials=false

               fi
    else
     proxy_credentials=false
    fi
fi
}
# If instance
         isn't yet set for https_only, check if port 80 is open.If not opened, report
         and exit
function check_http() {
  echo "9. Checking if SMT servers are
         accessible over http"
  
  smt_servers=$(cat /tmp/smtserver)
  if test
         -f /etc/regionserverclnt.cfg ; then
  if (cat /etc/regionserverclnt.cfg
         | grep -q "httpsOnly = true"); then
techo "[Passed] HTTP check is unnecessary.
         httpsOnly=true. OK"
  else
tfor i in "${smt_servers[@]}"; do
   
         local api_call="curl -m 5 -s -o /dev/null -w "%{http_code}"  http://$i/rmt.crt"
        
    if [ "$is_proxy" = false ] ; then
t  http_return_code=$( $api_call)

            elif [ "$is_proxy" = true ] && [ "$proxy_credentials" = true ] ;
         then
    http_return_code=$( $api_call --proxy $http_proxy --proxy-user
         $proxy_user )
    else
    http_return_code=$( $api_call--proxy $http_proxy
         )
    fi
t  if [ $http_return_code -ne "200" ]; then
        echo
         "[Failed] PROBLEM: HTTP access issue. Open port 80 for outbound communication
         to SMT servers:"
        echo "${smt_servers[*]}"
        exit 1
t
          else 
t    echo "[Passed] HTTP access to SMT servers is OK."
tt
        break
t  fi
tdonet
fi
else
echo "[Failed] PROBLEM: The package regionServiceClientConfigEC2
         is not installed in your EC2 Instance. Try to install the package regionServiceClientConfigEC2
         and re-run the Automation document again: sudo zypper in regionServiceClientConfigEC2"
        
exit 1
fi
}
 check_proxy
 check_http


"
  onFailure: "Continue"
  timeoutSeconds: 300
- name: "CheckHttpsAccessToSMTServers"
  action: "aws:runCommand"
  inputs:
    DocumentName: "AWS-RunShellScript"
    InstanceIds:
    - "{{ InstanceId }}"
    Parameters:
      commands: "#!/bin/bash

# Function to detect all the proxy information: http_proxy,https_proxy
         and credentials
function check_proxy() {
  # check if proxy is configured
         here /etc/sysconfig/proxy 
  local proxy_enabled=$(cat /etc/sysconfig/proxy
         | grep -i PROXY_ENABLED | grep -i yes)
    if [[ -n "${proxy_enabled}"
         ]] ; then

     http_proxy=$(cat /etc/sysconfig/proxy | grep -i http_proxy
         | awk -F "=" '{ print $2 }' | sed -e "s/"//g" | sed -e "s/ //g"
        )
     https_proxy=$(cat /etc/sysconfig/proxy | grep -i https_proxy | awk
         -F "=" '{ print $2 }' | sed -e "s/"//g" | sed -e "s/ //g")
  
          if [[ -n "${http_proxy}" ]] && [[ -n "${https_proxy}" ]]  ; then

            echo "${http_proxy}" | grep -o '[0-9]+[.][0-9]+[.][0-9]+[.][0-9]
        +' > /dev/null 2>&1 || echo "${http_proxy}" | grep -P '(?:https?://)'
         > /dev/null 2>&1

    if [[ $? -eq 0 ]] ; then 
     is_proxy=true

            fi
    else
     is_proxy=false
    fi
    # check if proxy is configured
         here /root/.bashrc
    elif [ -f /root/.bashrc ] ; then
     http_proxy=$(cat
         /root/.bashrc | grep -i http_proxy | awk -F "=" '{ print $2 }' | sed -e
         "s/"//g" | sed -e "s/ //g")
     https_proxy=$(cat /root/.bashrc|
         grep -i https_proxy | awk -F "=" '{ print $2 }' | sed -e "s/"//g"
         | sed -e "s/ //g")
    if [[ -n "${http_proxy}" ]] && [[ -n "${https_proxy}"
         ]]  ; then
    echo "${http_proxy}" | grep -o '[0-9]+[.][0-9]+[.][0-9]
        +[.][0-9]+' > /dev/null 2>&1 || echo "${http_proxy}" | grep -P '(?:https?:
        //)' > /dev/null 2>&1

    if [[ $? -eq 0 ]] ; then 
     is_proxy=true

            fi
    else
     is_proxy=false
    fi
    else
     is_proxy=false

            fi
if [ "$is_proxy" = false ] ; then

     proxy_credentials=false

        else
    curlrc=/root/.curlrc
    if [ -f $curlrc ] ; then 
      proxy_user=$(cat
         /root/.curlrc | grep -i proxy-user | awk -F "=" '{ print $2 }' | sed -e
         "s/"//g" | sed -e "s/ //g")

       if [[ -n "${proxy_user}"
         ]] ; then
        proxy_credentials=true   
       else
        proxy_credentials=false

               fi
    else
     proxy_credentials=false
    fi
fi
}
# Check
         if smt servers are accessible over https
function check_https() {
  echo
         "10. Checking if SMT servers are accessible over https."
  smt_servers=$(cat
         /tmp/smtserver)
  if test -f /etc/regionserverclnt.cfg ; then
  for i
         in "${smt_servers[@]}"; do
    if [ "$is_proxy" = false ] ; then

            local https_return_code=$(curl -k -m 5 -s -o /dev/null -w "%{http_code}"
         https://$i/api/health/status)
    elif [ "$is_proxy" = true ] && [ "
        $proxy_credentials" = true ] ; then
    local https_return_code=$(curl -k
         -m 5 -s -o /dev/null -w "%{http_code}" https://$i/api/health/status --proxy
         $https_proxy --proxy-user $proxy_user ) 
    else
    local https_return_code=$(curl
         -k -m 5 -s -o /dev/null -w "%{http_code}" https://$i/api/health/status
         --proxy $https_proxy )
    fi
tif [ $https_return_code -eq "000" ];
         then
t  echo "[Failed] PROBLEM: HTTPS access issue. Open port 443 for
         outbound communication to SMT servers:"
t  echo "${smt_servers[*]}"
        
    exit 1
  elif [ $https_return_code -eq "503" ]; then
  t  echo
         "[Failed] PROBLEM: MITM proxy misconfiguration. Proxy cannot intercept
         certs of the SMT Servers.Please exclude the below IPs from SSL interception
         in your proxy:"
t  echo "${smt_servers[*]}"
    exit 1
telse
 
             echo "[Passed] HTTPS access to the SMT servers is OK."
t  break

        tfi
  done
  else
  echo  "[Failed] PROBLEM: The package regionServiceClientConfigEC2
         is not installed in your EC2 Instance. You need to install the package regionServiceClientConfigEC2
         and re-run the Automation document again."
  exit 1
  fi
}

 check_proxy

         check_https


"
  description: "Check if SMT servers are accessible over https"
  onFailure: "Continue"
  timeoutSeconds: 300
- name: "CheckHttpsCertificationOfTheSMTServers"
  action: "aws:runCommand"
  description: "Check if smt-ec2.susecloud.net is accessible over https"
  inputs:
    DocumentName: "AWS-RunShellScript"
    InstanceIds:
    - "{{ InstanceId }}"
    Parameters:
      commands: "#!/bin/bash

# Function to detect all the proxy information: http_proxy,https_proxy
         and credentials
function check_proxy() {
  # check if proxy is configured
         here /etc/sysconfig/proxy 
  local proxy_enabled=$(cat /etc/sysconfig/proxy
         | grep -i PROXY_ENABLED | grep -i yes)
    if [[ -n "${proxy_enabled}"
         ]] ; then
     http_proxy=$(cat /etc/sysconfig/proxy | grep -i http_proxy
         | awk -F "=" '{ print $2 }' | sed -e "s/"//g" | sed -e "s/ //g"
        )
     https_proxy=$(cat /etc/sysconfig/proxy | grep -i https_proxy | awk
         -F "=" '{ print $2 }' | sed -e "s/"//g" | sed -e "s/ //g")
  
          if [[ -n "${http_proxy}" ]] && [[ -n "${https_proxy}" ]]  ; then

            echo "${http_proxy}" | grep -o '[0-9]+[.][0-9]+[.][0-9]+[.][0-9]
        +' > /dev/null 2>&1 || echo "${http_proxy}" | grep -P '(?:https?://)'
         > /dev/null 2>&1

    if [[ $? -eq 0 ]] ; then 
     is_proxy=true

            fi
    else
     is_proxy=false
    fi
    # check if proxy is configured
         here /root/.bashrc
    elif [ -f /root/.bashrc ] ; then
     http_proxy=$(cat
         /root/.bashrc | grep -i http_proxy | awk -F "=" '{ print $2 }' | sed -e
         "s/"//g" | sed -e "s/ //g")
     https_proxy=$(cat /root/.bashrc|
         grep -i https_proxy | awk -F "=" '{ print $2 }' | sed -e "s/"//g"
         | sed -e "s/ //g")
    if [[ -n "${http_proxy}" ]] && [[ -n "${https_proxy}"
         ]]  ; then
     is_proxy=true
    else
     is_proxy=false
    fi

            else
     is_proxy=false
    fi
if [ "$is_proxy" = false ] ; then

             proxy_credentials=false
else
    curlrc=/root/.curlrc
    if [ -f
         $curlrc ] ; then 
      proxy_user=$(cat /root/.curlrc | grep -i proxy-user
         | awk -F "=" '{ print $2 }' | sed -e "s/"//g" | sed -e "s/ //g"
        )
       if [[ -n "${proxy_user}" ]] ; then
        proxy_credentials=true

               else  
        proxy_credentials=false
       fi
    else
   
          proxy_credentials=false
    fi
fi

}
# Clean up the temporarily file
         /tmp/smtpserver
function remove_tmp_file(){
sudo rm -rf /tmp/smtserver

        }

# Check if smt-ec2.susecloud.net is accessible over https
function check_https_cert()
         {
  echo "11. Checking if smt-ec2.susecloud.net URL is accessible over
         https."
  filename=$( ls -Art /usr/share/pki/trust/anchors/ | tail -n
         1)
  local api_call="curl -k -m 5 -s -o /dev/null -w "%{http_code}"
         https://smt-ec2.susecloud.net/api/health/status"
  if [ "$is_proxy"
         = false ] ; then
   
  local https_return_code=$( $api_call --cacert /usr/share/pki/trust/anchors/$filename)

          elif [ "$is_proxy" = true ] && [ "$proxy_credentials" = true ] ; then

          local https_return_code=$( $api_call --cacert /usr/share/pki/trust/anchors/$filename
         --proxy $https_proxy --proxy-user $proxy_user )
  else
  local https_return_code=$(
         $api_call --cacert /usr/share/pki/trust/anchors/$filename --proxy $https_proxy)

          fi
 
  if [ $https_return_code -eq "000" ]; then
    local smt_ip="
        $(getent hosts smt-ec2.susecloud.net | awk {'print $1'})"
    echo "[Failed]
         PROBLEM: You need to add the domain smt-ec2.susecloud.net in the /etc/hosts
         in your proxy to be able to resolve the domain name smt-ec2.susecloud.net
         to one of the SMT servers IPs as : $smt_ip smt-ec2.susecloud.net   smt-ec2
          "
    exit 1
  elif [ $https_return_code -eq "503" ]; then
    echo
         "[Failed] PROBLEM: You need to white-list the domain name smt-ec2.susecloud.net
         from the SSL interception in your proxy or firewall."
    exit 1
  else

              echo "[Passed] SMT certification is OK." 
  fi

}
 check_proxy

         remove_tmp_file
 check_https_cert


"
  onFailure: "Continue"
  timeoutSeconds: 300
- name: "RegisterInstanceToSUSEUpdateInfrastructure"
  action: "aws:runCommand"
  description: "Force the client to register to SMT again"
  inputs:
    DocumentName: "AWS-RunShellScript"
    InstanceIds:
    - "{{ InstanceId }}"
    Parameters:
      commands: "#!/bin/bash
# Force the client to register to SMT again
#######################################

        function registercloudguestnow() {
SUSEConnect --cleanup
sed -i '/^# Added
         by SMT reg/,+1d' /etc/hosts
/usr/sbin/registercloudguest --force-new >
         /dev/null 2>&1
}  

# Register the ec2 instance to SUSE Update Infrastructure
         
function report() {
echo  "12. Register the EC2 Instance to SUSE Update
         Infrastructure. Running registercloudguest..."
registercloudguestnow

        SUSEConnect -s | grep -qi "Not Registered"
if [ $? -eq 0 ] ; then
echo
          "[Failed] Your EC2 instance is Not Registered to SUSE Update Infrastructure.
         Please Contact AWS Support to fix the issue."
exit 1
else
echo  "[Passed]
         Your EC2 instance is Registered to SUSE Update Infrastructure."
fi
}

        
report

"
  timeoutSeconds: 300
- name: "FinalOutput"
  action: "aws:executeScript"
  description: "Consolidates the results of all steps and generates a report on the
     passed and failed checks."
  onFailure: "Abort"
  isEnd: "true"
  inputs:
    Runtime: "python3.7"
    Handler: "script_handler"
    InputPayload:
      Os: "{{ConfirmSuseOS.Output}}"
      PackageVersion: "{{CheckcloudregionsrvclientpackageVersion.Output}}"
      BaseProduct: "{{CheckBaseProduct.Output}}"
      HostFile: "{{CheckHostsFileForMultipleRecords.Output}}"
      Curl: "{{CheckifCurlexists.Output}}"
      IMDS: "{{CheckIMDSAccess.Output}}"
      SubscriptionCode: "{{CheckOnDemandSUSESubscriptionCode.Output}}"
      RegionServer: "{{AccessRegionServerOverHttps.Output}}"
      HTTPSMT: "{{CheckHttpAccessToSMTServers.Output}}"
      HTTPSSMT: "{{CheckHttpsAccessToSMTServers.Output}}"
      CertificationSMT: "{{CheckHttpsCertificationOfTheSMTServers.Output}}"
      Registered: "{{RegisterInstanceToSUSEUpdateInfrastructure.Output}}"
    Script: "def script_handler(events, context):
   import json

   #Capturing
       other steps output.

   Heading = "Total Number of Tests: 12

"

         Os = events['Os']
   PackageVersion = events['PackageVersion']
   BaseProduct
       = events['BaseProduct']
   HostFile = events['HostFile']
   curl = events['Curl']

         IMDS = events['IMDS']
   SubscriptionCode = events['SubscriptionCode']

         RegionServer = events['RegionServer']
   HTTPSMT = events['HTTPSMT']

         HTTPSSMT = events['HTTPSSMT']
   CertificationSMT = events['CertificationSMT']

         Registered = events['Registered']

   stepsHeaders = ["
",
     
               "
 
"
   ]

   Result = Heading + stepsHeaders[0] + Os +
       stepsHeaders[1] + PackageVersion + stepsHeaders[1] + BaseProduct + stepsHeaders[1]
       + HostFile + stepsHeaders[1] + curl + stepsHeaders[1] + IMDS + stepsHeaders[1]
       + SubscriptionCode + stepsHeaders[1] + RegionServer + stepsHeaders[1] + HTTPSMT
       + stepsHeaders[1] + HTTPSSMT + stepsHeaders[1] + CertificationSMT + stepsHeaders[1]
       + Registered

   return {'output': Result}
"
  outputs:
  - Name: "output"
    Selector: "$.Payload.output"
    Type: "String"
