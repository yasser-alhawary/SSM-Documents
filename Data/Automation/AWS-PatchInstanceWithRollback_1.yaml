schemaVersion: "0.3"
description: "Brings EC2 Instance into compliance with standing Baseline; rolls back
   root Volume on failure."
assumeRole: "{{AutomationAssumeRole}}"
parameters:
  InstanceId:
    type: "String"
    description: "(Required) EC2 InstanceId to which we apply the patch-baseline"
  ReportS3Bucket:
    type: "String"
    description: "(Optional) S3 Bucket destination for the full Compliance Report
       generated during process"
    default: ""
  AutomationAssumeRole:
    type: "String"
    description: "(Optional) The ARN of the role that allows Automation to perform
       the actions on your behalf."
    default: ""
  LambdaAssumeRole:
    type: "String"
    description: "(Optional) The ARN of the role that allows Lambda created by Automation
       to perform the actions on your behalf. If not specified a transient role will
       be created to execute the Lambda function."
    default: ""
mainSteps:
- name: "createDocumentStack"
  maxAttempts: 8
  action: "aws:createStack"
  inputs:
    Capabilities:
    - "CAPABILITY_IAM"
    ClientRequestToken: "{{automation:EXECUTION_ID}}"
    StackName: "PatchInstanceWithRollbackStack{{automation:EXECUTION_ID}}"
    Parameters:
    - ParameterKey: "LambdaRoleArn"
      ParameterValue: "{{LambdaAssumeRole}}"
    - ParameterKey: "IdentifyRootVolumeLambdaName"
      ParameterValue: "IdentifyRootVolumeLambda-{{automation:EXECUTION_ID}}"
    - ParameterKey: "SleepThruInstallationLambdaName"
      ParameterValue: "SleepThruInstallationLambda-{{automation:EXECUTION_ID}}"
    - ParameterKey: "CheckComplianceLambdaName"
      ParameterValue: "CheckComplianceLambda-{{automation:EXECUTION_ID}}"
    - ParameterKey: "SaveComplianceReportToS3LambdaName"
      ParameterValue: "SaveRptToS3Lambda-{{automation:EXECUTION_ID}}"
    - ParameterKey: "ReportFailureLambdaName"
      ParameterValue: "ReportFailureLambda-{{automation:EXECUTION_ID}}"
    - ParameterKey: "RestoreFromSnapshotLambdaName"
      ParameterValue: "RestoreFromSnapshotLambda-{{automation:EXECUTION_ID}}"
    - ParameterKey: "DeleteSnapshotLambdaName"
      ParameterValue: "DeleteSnapshotLambda-{{automation:EXECUTION_ID}}"
    TemplateBody: "AWSTemplateFormatVersion: '2010-09-09'
Conditions:
  LambdaAssumeRoleNotSpecified:

          Fn::Or:
    - Fn::Equals:
      - {Ref: LambdaRoleArn}
      - ''

          - Fn::Equals:
      - {Ref: LambdaRoleArn}
      - undefined
Parameters:

        CheckComplianceLambdaName: {Description: 'The lambda function name for the
       predicate
      which evaluates the state of the EC-2 operand''s patch state
       compliance

      ', Type: String}
  DeleteSnapshotLambdaName: {Description:
       'The lambda function name for the closings
      cleanup predicate (case
       in which the EC-2 operand is deemed Compliant)

      ', Type: String}

        IdentifyRootVolumeLambdaName: {Description: 'The lambda function name for
       the predicate
      which acquires the id of the root Volume of the operand
       EC2 Instance.

      ', Type: String}
  LambdaRoleArn: {Default: '', Description:
       'The ARN of the role that allows Lambda
      created by Automation to perform
       the action on your behalf

      ', Type: String}
  ReportFailureLambdaName:
       {Description: 'The lambda function name for the predicate
      which reports
       failure upon detection execution failure state indicators

      ', Type:
       String}
  RestoreFromSnapshotLambdaName: {Description: 'The lambda function
       name for the recovery
      action predicate (case in which the EC-2 operand
       is deemed NonCompliant)

      ', Type: String}
  SaveComplianceReportToS3LambdaName:
       {Description: 'The lambda function name for
      the predicate which consumes
       a serialized Compliance report and saves it in
      S3

      ', Type:
       String}
  SleepThruInstallationLambdaName: {Description: 'The lambda function
       name for the
      predicate which monitors the installation, deferring subsequent
       step procession
      until the installations are completed or the Lambda
       exhausts its allotted lifespan

      ', Type: String}
Resources:
  CheckComplianceLambda:

          Properties:
      Code: {ZipFile: "import boto3
from botocore.config
       import Config
import json

          import sys
from datetime import
       datetime

MAX_REPORT_ITEMS = 1200
SUCCESS_MESSAGE
           =
       "Instance patched successfully"
FAILURE_MESSAGE = "Patching failed
      
           and Instance restored to original state"
LIMITED_REPORT_DESCRIPTION_MESSAGE
      
           = "Listing last %d applicable compliance items. To get the
       full report
           use the option to persist report in S3" % MAX_REPORT_ITEMS
      nFULL_REPORT_DESCRIPTION_MESSAGE
           = "Listing all compliance
       items."
config = Config(
tretries = {

          tt'max_attempts':
       20,
tt'mode': 'standard'
t}
)
ssm = boto3.client('ssm',

                 config=config)
s3 = boto3.resource('s3')

def is_compliant(ec2_id):
      n
          treport = {
tt"is_compliant": None,
tt"
      items": [],
t}
tnoncompliance_found
           = False

      ttoken = None
twhile 1:
ttif token is None:
tttlist_compliance_result
      
           = ssm.list_compliance_items(
ttttFilters=[{'Key': 'ComplianceType',
      
           'Values': ['Patch']}],
ttttResourceIds=[ec2_id],
      nttttResourceTypes=["
          ManagedInstance"]
tt
      t)

ttelse:
tttlist_compliance_result =
           ssm.list_compliance_items(
      nttttFilters=[{'Key': 'ComplianceType',
           'Values': ['Patch']}],
      nttttResourceIds=[ec2_id],
ttttResourceTypes=["
   
             ManagedInstance"],
ttttNextToken=token
ttt)

      ttcompliances =
           list_compliance_result["ComplianceItems
      "]

ttfor a_val in compliances:

          tttpatch_item
       = {
tttt"PatchId": a_val["Id"],
tttt"Severity
      "
          : a_val["Severity"],
tttt"ComplianceType
      ": a_val["ComplianceType"
          ],
tttt"State"
      : a_val["Details"]["PatchState"]
ttt}
tt
     
           treport["items"].append(patch_item)
tttif a_val["Status
      "] != "
          COMPLIANT" and a_val["Details"]["PatchState
      "] != "NotApplicable"
          :
ttttnoncompliance_found
       = True
ttif "NextToken" in list_compliance_result:

    
            ttttoken = list_compliance_result["NextToken"]
ttelse:
      ntttbreak

          
ttif token is None:
tttbreak
      n
treport["is_compliant"] = noncompliance_found
           is
       False
treturn report

def is_success_case(ec2_id):
treturn is_compliant(ec2_id)
      n
          
def get_account_id(lambdaArn):
taccount_id = lambdaArn.split(
      ":")[4]

          treturn account_id

def get_region(lambdaArn):
      ntregion = lambdaArn.split("
          :")[3]
treturn region
      n
def save_to_s3(event, context, compliance_report):

          taccount_id
       = get_account_id(context.invoked_function_arn)
tregion =
         
        get_region(context.invoked_function_arn)
tdate = str(datetime.now().day)
      n
          tmonth = str(datetime.now().month)
tyear = str(datetime.now().year)
      n
          tfile_path = "AWSLogs/" + account_id + "/SystemsManager/
      " + region
           + "/" + year + "/" + month + "/
      " + date + "/" + event["ReportFileName"
          ]
trpt_s3_obj
       = s3.Object(event["S3Bucket"], file_path)
trpt_s3_obj.put(Body=json.dumps(compliance_report))
      n
          trpt_s3_obj_acl = s3.ObjectAcl(event["S3Bucket"], file_path)
      ntrpt_s3_obj_acl.put(ACL='bucket-owner-full-control')

          

      treturn file_path

def filter_not_applicable_items(compliance_report):
      n
          tapplicable_items = []
tfor item in compliance_report:
      nttif item["
          State"] != "NotApplicable":
t
      ttapplicable_items.append(item)
t
          return applicable_items
      n
def handler(event, context):
tcompliance_report
           = is_success_case(event[
      "InstanceId"])
toutput = {
tt"Result"
          : SUCCESS_MESSAGE
       if compliance_report["is_compliant"] else FAILURE_MESSAGE,

  
              tt"PatchingSuccess": compliance_report["is_compliant
      "]
t}

t
          if len(event["S3Bucket"]) > 0:
t
      tfile_path = save_to_s3(event, context,
           compliance_report[
      "items"])
ttoutput["ReportFileName"] = file_path

    
            ttoutput["S3Bucket"] = event["S3Bucket"]

tif len(compliance_report[
      "
          items"]) > MAX_REPORT_ITEMS:
ttoutput["Description
      "] = LIMITED_REPORT_DESCRIPTION_MESSAGE

          ttapplicable_items
       = filter_not_applicable_items(compliance_report["
          items"
      ])
ttoutput["items"] = applicable_items[-MAX_REPORT_ITEMS:]

      
          telse:
ttoutput["Description"] = FULL_REPORT_DESCRIPTION_MESSAGE
      n
          ttoutput["items"] = compliance_report["items"
      ]
treturn output
"}
      FunctionName: {Ref: CheckComplianceLambdaName}

            Handler: index.handler
      MemorySize: 128
      Role:
        Fn::If:

              - LambdaAssumeRoleNotSpecified
        - Fn::GetAtt: [LambdaRole,
       Arn]
        - {Ref: LambdaRoleArn}
      Runtime: python3.7
      Timeout:
       300
    Type: AWS::Lambda::Function
  DeleteSnapshotLambda:
    Properties:

            Code: {ZipFile: "import boto3
import time
from botocore.exceptions
       import
           ClientError

SNAPSHOT_NOT_FOUND_ERROR_CODE = 
      "InvalidSnapshot.NotFound"
          
POLL_INTERVAL = 5
POLL_MAX_TRIES
       = 8

ssm = boto3.client('ssm')
ec2
           = boto3.client('ec2')
      n

def check_for_deletion(snapshot_id):
ttry:

          t
      tec2.describe_snapshots(SnapshotIds=[snapshot_id])
texcept ClientError
      
           as api_client_error:
ttif api_client_error.response["
      Error"]["Code"
          ] == SNAPSHOT_NOT_FOUND_ERROR_CODE:

      tttreturn True
ttelse:
ttt
          raise


def
       wait_for_deletion(snapshot_id, max_tries=POLL_MAX_TRIES,
           wait_time=POLL_INTERVAL):
      nttotal_iterations = 0
twhile total_iterations
           < max_tries:
      ntttotal_iterations += 1
ttif check_for_deletion(snapshot_id)

                 is True:
tttreturn True
tttime.sleep(wait_time)
      n

def delete_snapshot(snapshot_id):

          tec2.delete_snapshot(SnapshotId=snapshot_id)
      ntwait_for_deletion(snapshot_id)

          

def handler(event,
       context):
tsnap_id = event["PrePatchSnapshot"
          ]

      ntdelete_snapshot(snap_id)
treturn {"ResultCase": "Snapshot Deleted
      "
          }
"}
      FunctionName: {Ref: DeleteSnapshotLambdaName}

            Handler: index.handler
      MemorySize: 128
      Role:
        Fn::If:

              - LambdaAssumeRoleNotSpecified
        - Fn::GetAtt: [LambdaRole,
       Arn]
        - {Ref: LambdaRoleArn}
      Runtime: python3.7
      Timeout:
       60
    Type: AWS::Lambda::Function
  IdentifyRootVolumeLambda:
    Properties:

            Code: {ZipFile: "import boto3

ec2_client = boto3.client('ec2')
      n
def get_root_device_name(instance_id):

          troot_device_name
       = ec2_client.describe_instance_attribute(
ttAttribute='rootDeviceName',
      
           InstanceId=instance_id
t)["RootDeviceName"]["Value
      "]
treturn root_device_name

          
def get_root_volume_id_of_ec2(instance_id):
      ntroot_device_name = get_root_device_name(instance_id)

          
      tvolume_id = ec2_client.describe_volumes(
ttFilters=[{'Name': 'attachment.instance-id',
      
           'Values': [instance_id]},
tttt {'Name': 'attachment.device',
       'Values':
           [root_device_name]}]
t)["Volumes"][0][
      "VolumeId"]
treturn volume_id

          

def handler(event,
       context):
tinstance_id = event["InstanceId"]

          
      treturn get_root_volume_id_of_ec2(instance_id)
"}
      FunctionName: {Ref:
       IdentifyRootVolumeLambdaName}
      Handler: index.handler
      MemorySize:
       128
      Role:
        Fn::If:
        - LambdaAssumeRoleNotSpecified

              - Fn::GetAtt: [LambdaRole, Arn]
        - {Ref: LambdaRoleArn}
 
           Runtime: python3.7
      Timeout: 128
    Type: AWS::Lambda::Function

        LambdaRole:
    Condition: LambdaAssumeRoleNotSpecified
    Properties:

            AssumeRolePolicyDocument:
        Statement:
        - Action: ['sts:AssumeRole']

                Effect: Allow
          Principal:
            Service: [lambda.amazonaws.com]

              Version: '2012-10-17'
      Path: /
      Policies:
      - PolicyDocument:

                Statement:
            Action: ['ec2:CreateSnapshot', 'ec2:DeleteSnapshot',
       'ec2:DescribeInstances',
              'ec2:DescribeSnapshots', 'ec2:DescribeVolumes',
       'ec2:DescribeInstanceAttribute',
              'ec2:CreateVolume', 'ec2:AttachVolume',
       'ec2:DetachVolume', 'ec2:StartInstances',
              'ec2:StopInstances',
       'ssm:ListCommands', 'ssm:ListComplianceItems',
              's3:PutObject',
       's3:PutObjectAcl', 'cloudwatch:*', 'logs:CreateLogGroup',
              'logs:CreateLogStream',
       'logs:PutLogEvents']
            Effect: Allow
            Resource: '*'

                Version: '2012-10-17'
        PolicyName: PatchInstanceWithRollbackLambdaPolicy

          Type: AWS::IAM::Role
  ReportFailureLambda:
    Properties:
      Code:
       {ZipFile: "

def handler(event, context):
tcompliance_report = event[
      "
          CheckCompliance"]
tif compliance_report["PatchingSuccess
      "]:
ttreturn
           "Patching Succeeded!"
telse:
      nttraise Exception("Patching Failed"
          )
"}
      FunctionName:
       {Ref: ReportFailureLambdaName}
      Handler: index.handler
      MemorySize:
       128
      Role:
        Fn::If:
        - LambdaAssumeRoleNotSpecified

              - Fn::GetAtt: [LambdaRole, Arn]
        - {Ref: LambdaRoleArn}
 
           Runtime: python3.7
      Timeout: 60
    Type: AWS::Lambda::Function

        RestoreFromSnapshotLambda:
    Properties:
      Code: {ZipFile: "import
       boto3
import time

ssm = boto3.client('ssm')
ec2_client
      
           = boto3.client('ec2')
ec2_rsc = boto3.resource('ec2')


def
       count_vols_attached_to_host(vol):

          treturn len(ec2_client.describe_volumes(VolumeIds=[vol.id])[
      "Volumes"
          ][0]["Attachments"])


def wait_4_detach(vol):
      ntwhile count_vols_attached_to_host(vol)
           > 0:
tttime.sleep(5)
      nttif count_vols_attached_to_host(vol) == 0:

          tttreturn
       True


def wait_4_attach(vol):
twhile count_vols_attached_to_host(vol)
      
           < 1:
tttime.sleep(5)
ttif count_vols_attached_to_host(vol)
       == 1:

          tttreturn True


def get_root_device_name(instance_id):
      ntroot_device_name
           = ec2_client.describe_instance_attribute(
      nttAttribute='rootDeviceName',
           InstanceId=instance_id
      nt)["RootDeviceName"]["Value"]
treturn root_device_name
      n
          

def get_volume_id(instance_id, device_name):
tvolume_id
       = ec2_client.describe_volumes(

          ttFilters=[{'Name': 'attachment.instance-id',
       'Values': [instance_id]},

          tttt {'Name': 'attachment.device',
       'Values': [device_name]}]
t)["
          Volumes"][0]["VolumeId
      "]
treturn volume_id


def restore_vol_fm_snapshot(ec2_id,
  
               snap_id, dev, vol_id):
tvol = ec2_rsc.Volume(vol_id)


      tnew_vol_init
           = ec2_client.create_volume(AvailabilityZone=vol.availability_zone,
       SnapshotId=snap_id)

          tnew_vol_id = new_vol_init['VolumeId']
      ntnew_vol = ec2_rsc.Volume(new_vol_id)

          tec2_client.get_waiter('volume_available').wait(VolumeIds=[new_vol_id])
      n
          
tec2_client.stop_instances(InstanceIds=[ec2_id])
tec2_client.get_waiter('instance_stopped').wait(InstanceIds=[ec2_id])
      n
          
tec2_client.detach_volume(Device=dev, InstanceId=ec2_id,
       VolumeId=vol_id)

          twait_4_detach(vol)
tec2_client.attach_volume(Device=dev,
       InstanceId=ec2_id,
           VolumeId=new_vol_id)
twait_4_attach(new_vol)
      n
tec2_client.start_instances(InstanceIds=[ec2_id])

          tec2_client.get_waiter('instance_running').wait(InstanceIds=[ec2_id])
      n
          
treturn True


def handler(event, context):
tinstance_id
       = event["
          InstanceId"]
tsnap_id = event["SnapshotId
      "]
troot_device_name = get_root_device_name(instance_id)

       
         troot_volume_id = get_volume_id(instance_id, root_device_name)


      trestore_vol_fm_snapshot(instance_id,
           snap_id, root_device_name,
       root_volume_id)
treturn {"ResultCase":
           "Restoration
       Applied"}"}
      FunctionName: {Ref: RestoreFromSnapshotLambdaName}

            Handler: index.handler
      MemorySize: 128
      Role:
        Fn::If:

              - LambdaAssumeRoleNotSpecified
        - Fn::GetAtt: [LambdaRole,
       Arn]
        - {Ref: LambdaRoleArn}
      Runtime: python3.7
      Timeout:
       300
    Type: AWS::Lambda::Function
  SaveComplianceReportToS3Lambda:

          Properties:
      Code: {ZipFile: "
def handler(event, context):
      ntif (len(event["S3Bucket"
          ]) > 0):
ttreturn {
      nttt"ReportFileName": event["CheckCompliance"
        
        ]["ReportFileName"],
ttt"S3Bucket": event["S3Bucket
      "]
tt}

          telse:
ttreturn None
"}
      FunctionName:
       {Ref: SaveComplianceReportToS3LambdaName}
      Handler: index.handler

            MemorySize: 128
      Role:
        Fn::If:
        - LambdaAssumeRoleNotSpecified

              - Fn::GetAtt: [LambdaRole, Arn]
        - {Ref: LambdaRoleArn}
 
           Runtime: python3.7
      Timeout: 60
    Type: AWS::Lambda::Function

        SleepThruInstallationLambda:
    Properties:
      Code: {ZipFile: "import
       boto3

ec2_rsc = boto3.resource('ec2')


def wait_for_restart(ec2_inst):
      n
          tec2_inst.wait_until_running()


def handler(event, context):
      ntinstance
           = ec2_rsc.Instance(event["InstanceId"])
      ntreturn wait_for_restart(instance)
"}
      FunctionName: {Ref: SleepThruInstallationLambdaName}

            Handler: index.handler
      MemorySize: 128
      Role:
        Fn::If:

              - LambdaAssumeRoleNotSpecified
        - Fn::GetAtt: [LambdaRole,
       Arn]
        - {Ref: LambdaRoleArn}
      Runtime: python3.7
      Timeout:
       300
    Type: AWS::Lambda::Function
"
- name: "IdentifyRootVolume"
  action: "aws:invokeLambdaFunction"
  inputs:
    FunctionName: "IdentifyRootVolumeLambda-{{automation:EXECUTION_ID}}"
    Payload: "{"InstanceId": "{{InstanceId}}"}"
- name: "PrePatchSnapshot"
  action: "aws:executeAutomation"
  inputs:
    DocumentName: "AWS-CreateSnapshot"
    RuntimeParameters:
      VolumeId: "{{IdentifyRootVolume.Payload}}"
      Description: "ApplyPatchBaseline restoration case contingency"
- name: "installMissingUpdates"
  action: "aws:runCommand"
  maxAttempts: 1
  onFailure: "Continue"
  inputs:
    DocumentName: "AWS-RunPatchBaseline"
    InstanceIds:
    - "{{InstanceId}}"
    Parameters:
      Operation: "Install"
- name: "SleepThruInstallation"
  action: "aws:invokeLambdaFunction"
  maxAttempts: 10
  inputs:
    FunctionName: "SleepThruInstallationLambda-{{automation:EXECUTION_ID}}"
    Payload: "{"InstanceId": "{{InstanceId}}"}"
- name: "CheckCompliance"
  action: "aws:invokeLambdaFunction"
  description: "Check compliance status of instance and output report of compliance
     items. Output may not contain all items, the full report will be in S3 if S3Bucket
     is specified."
  inputs:
    FunctionName: "CheckComplianceLambda-{{automation:EXECUTION_ID}}"
    Payload: "{"InstanceId": "{{InstanceId}}", "S3Bucket": "{{ReportS3Bucket}}"
      , "ReportFileName": "PatchInstanceWithRollback-{{automation:EXECUTION_ID}}.json"
      }"
- name: "SaveComplianceReportToS3"
  action: "aws:invokeLambdaFunction"
  inputs:
    FunctionName: "SaveRptToS3Lambda-{{automation:EXECUTION_ID}}"
    Payload: "{"S3Bucket": "{{ReportS3Bucket}}", "CheckCompliance": {{CheckCompliance.Payload}}}"
- name: "ReportSuccessOrFailure"
  action: "aws:invokeLambdaFunction"
  onFailure: "step:RestoreFromSnapshot"
  maxAttempts: 1
  inputs:
    FunctionName: "ReportFailureLambda-{{automation:EXECUTION_ID}}"
    Payload: "{"CheckCompliance": {{CheckCompliance.Payload}}}"
  nextStep: "DeleteSnapshot"
- name: "RestoreFromSnapshot"
  action: "aws:invokeLambdaFunction"
  onFailure: "step:DeleteSnapshot"
  inputs:
    FunctionName: "RestoreFromSnapshotLambda-{{automation:EXECUTION_ID}}"
    Payload: "{"InstanceId": "{{InstanceId}}", "SnapshotId": "{{PrePatchSnapshot.Output}}"
      , "CheckCompliance": {{CheckCompliance.Payload}}}"
  nextStep: "DeleteSnapshot"
- name: "DeleteSnapshot"
  action: "aws:invokeLambdaFunction"
  onFailure: "step:deleteCloudFormationTemplate"
  maxAttempts: 16
  inputs:
    FunctionName: "DeleteSnapshotLambda-{{automation:EXECUTION_ID}}"
    Payload: "{"PrePatchSnapshot": "{{PrePatchSnapshot.Output}}"}"
  nextStep: "deleteCloudFormationTemplate"
- name: "deleteCloudFormationTemplate"
  action: "aws:deleteStack"
  maxAttempts: 16
  inputs:
    StackName: "PatchInstanceWithRollbackStack{{automation:EXECUTION_ID}}"
  isEnd: "true"
outputs:
- "IdentifyRootVolume.Payload"
- "PrePatchSnapshot.Output"
- "SaveComplianceReportToS3.Payload"
- "RestoreFromSnapshot.Payload"
- "CheckCompliance.Payload"
