description: "*This document will Troubleshoot internet access for lambda when launched
   in VPC"
schemaVersion: "0.3"
assumeRole: "{{ AutomationAssumeRole }}"
outputs:
- "checkVpc.vpc"
- "checkVpc.subnet"
- "checkVpc.securityGroups"
- "checkSubnet.subnets"
- "checkSecurityGroups.secgrps"
- "checkNACL.NACL"
parameters:
  AutomationAssumeRole:
    type: "String"
    description: "(Optional) The ARN of the role that allows Automation to perform
       the actions on your behalf."
    allowedPattern: "^$|^arn:aws:iam::[0-9]*:role/[/w+=,.@-]+$"
    default: ""
  FunctionName:
    type: "String"
    description: "(Required) The function name whose connectivity needs to be validated."
    default: ""
  destinationIp:
    type: "String"
    description: "(Required) The destination Ip where you  want to initiate an outbound
       internet access."
    default: ""
    allowedPattern: "b((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(.|$)){4}b"
  destinationPort:
    type: "String"
    description: "(Optional) The destination port where you want to initiate an outbound
       internet access."
    default: "443"
    allowedPattern: "^([0-9]{1,4}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5])$"
mainSteps:
- name: "checkVpc"
  action: "aws:executeScript"
  inputs:
    Runtime: "python3.8"
    Handler: "checkVpc"
    Script: "import boto3
def checkVpc(events,context):
  client=boto3.client('lambda')

        response = client.get_function(FunctionName=events['FunctionName'])
  if
       'VpcConfig' in response['Configuration'] and response['Configuration']['VpcConfig']['VpcId']
       != "":
    return response['Configuration']['VpcConfig']
  else:
   
       return {"VpcId":"Your Lambda is not associated to any VPC"}
"
    InputPayload:
      FunctionName: "{{FunctionName}}"
  outputs:
  - Name: "vpc"
    Selector: "$.Payload.VpcId"
    Type: "String"
  - Name: "subnet"
    Selector: "$.Payload.SubnetIds"
    Type: "StringList"
  - Name: "securityGroups"
    Selector: "$.Payload.SecurityGroupIds"
    Type: "StringList"
  - Name: "vpcflag"
    Selector: "$.Payload.vpcflag"
    Type: "String"
  description: "#### Verify if the VPC is configured for your Lambda function"
- name: "vpcFlag"
  action: "aws:branch"
  inputs:
    Choices:
    - Not:
        Variable: "{{checkVpc.vpc}}"
        StringEquals: "Your Lambda is not associated to any VPC"
      NextStep: "checkSubnet"
  isEnd: true
- name: "checkSubnet"
  action: "aws:executeScript"
  inputs:
    Runtime: "python3.8"
    Handler: "checkSubnet"
    Script: "import boto3
from ipaddress import ip_network,ip_address
client=boto3.client('ec2')

      
def getMainRTmap(mainRt,subnetWithMainRouteTable,destination):
  response
       = client.describe_route_tables(RouteTableIds=[mainRt])['RouteTables'][0]['Routes']

        routeTableSubnetMap={}
  RouteTableToTarget={}
  destination = ip_address(destination)

        subnetToNat={}

  for subnet in subnetWithMainRouteTable:
    routeTableSubnetMap[subnet]=mainRt

      
  most_specific = -1
  next_hop={}  

  for route in response:
    if
       route.get('DestinationCidrBlock'):
      mask = int(route['DestinationCidrBlock'].split('/')[1])

            if not 'DestinationPrefixListId' in str(route) and destination in ip_network(route['DestinationCidrBlock'],
       strict=False) and mask > most_specific:
        most_specific = mask
  
            state=route['State']
        next_hop = route

  RouteTableToTarget[mainRt]={}

        RouteTableToTarget[mainRt]['Route']=next_hop

  
  if 'GatewayId' in next_hop:

          if next_hop['GatewayId'] == 'local':
      RouteTableToTarget[mainRt]["
      Analysis"]="This Route Table has a local route for your given destination
       IP"
    else:
      RouteTableToTarget[mainRt]["Analysis"]="This Route
       Table has an internet gateway route for your destination. However, route should
       be pointed to NAT gateway. Correct this route entry to NAT gateway."
  elif
       'NatGatewayId' in next_hop:
    for subnet in subnetWithMainRouteTable:

            subnetToNat[subnet]=next_hop['NatGatewayId']
    RouteTableToTarget[mainRt]["
      Analysis"]="This Route Table has an NAT gateway route for your destination.
       Check whether this NAT gateway is launched in public subnet or if it exists
       (check for blackhole routes)."  
  elif next_hop:
    RouteTableToTarget[mainRt]["
      Analysis"]="This Route table has a route for given destination IP which is
       other than internet gateway, NAT or local route" 
  else:
    RouteTableToTarget[mainRt]["
      Analysis"]="This Route Table does not have an NAT gateway route for your destination.
       Please have a NAT Gateway as a target for this route."
    RouteTableToTarget[mainRt]['MainRouteTable']="
      yes"
  return RouteTableToTarget,routeTableSubnetMap,subnetToNat

def getLambdaEni(subnet,sec_grp):

        sec_grp.sort()
  try:
    response = client.describe_network_interfaces(

                    Filters=[
                {'Name': 'attachment.instance-owner-id','Values':
       ['amazon-aws']},
                {'Name': 'group-id','Values': sec_grp},

                      {'Name': 'subnet-id','Values': [subnet]}
                
            ]
                      )
  except e as Exception:
      print("
      Error occured as "+str(e))

  for eni in response['NetworkInterfaces']:

          enisecGrp=[]
    for group in eni['Groups']:
      enisecGrp.append(group['GroupId'])

            enisecGrp.sort()
    
    if sec_grp == enisecGrp:
      return eni['PrivateIpAddress']

      

def checkPath(response,destination_ip,subnetIds,vpcId):
  routeTableSubnetMap={}

        RouteTableToTarget={}
  destination = ip_address(destination_ip)
  subnetToNat={}

        
  for routeTables in response['RouteTables']:
    subnetFlag=[]
    for
       AssociationState in routeTables['Associations']:
      if 'SubnetId' in AssociationState:

              if AssociationState['SubnetId'] in subnetIds:
          routeTableSubnetMap[AssociationState['SubnetId']]=AssociationState['RouteTableId']

                subnetFlag.append(AssociationState['SubnetId'])

    most_specific
       = -1
    next_hop={}

    for route in routeTables['Routes']:
      if
       'DestinationCidrBlock' in route:
        mask = int(route['DestinationCidrBlock'].split('/')[1])

              if not 'DestinationPrefixListId' in str(route) and destination in ip_network(route['DestinationCidrBlock'])
       and mask > most_specific:
          most_specific = mask
          state=route['State']

                next_hop = route

    RouteTableToTarget[routeTables['RouteTableId']]={}

          RouteTableToTarget[routeTables['RouteTableId']]['Route']=next_hop     
       
    if 'GatewayId' in next_hop:  
      if next_hop['GatewayId'] == 'local':

              RouteTableToTarget[routeTables['RouteTableId']]["Analysis"]="This
       Route Table has a local route for your given destination IP"
      else:
        
        RouteTableToTarget[routeTables['RouteTableId']]["Analysis"]="
      This Route Table has an internet gateway route for your destination. However,
       route should be pointed to NAT gateway. Correct this route entry to NAT gateway."
      
    elif 'NatGatewayId' in next_hop:
      for subnet in subnetFlag:
  
            subnetToNat[subnet]=next_hop['NatGatewayId']
      RouteTableToTarget[routeTables['RouteTableId']]["
      Analysis"]="This Route Table has an NAT gateway route for your destination.
       Check whether this NAT gateway is launched in public subnet or if it exists
       (blackhole routes)."
    elif next_hop:
      RouteTableToTarget[routeTables['RouteTableId']]["
      Analysis"]="This Route table has a route for given destination IP which is
       other than internet gateway, NAT or local route"
    else:
      RouteTableToTarget[routeTables['RouteTableId']]["
      Analysis"]="This Route Table does not have an NAT gateway route or any other
       route for your destination. Please have a NAT Gateway as a target for this
       route."

  subnetWithMainRouteTable=list(set(subnetIds) - set(routeTableSubnetMap.keys()))

      
  if subnetWithMainRouteTable:
    mainRt=""
    response = client.describe_route_tables(Filters=[{'Name':
       'vpc-id','Values': [vpcId]}])
    for routeTable in response['RouteTables']:

            for association in routeTable['Associations']:
        if association['Main']
       == True:
          mainRt=association['RouteTableId']
    RouteTableToTarget1,routeTableSubnetMap1,subnetToNat1=getMainRTmap(mainRt,subnetWithMainRouteTable,destination)
            
    subnetToNat.update(subnetToNat1)
    routeTableSubnetMap.update(routeTableSubnetMap1)

          RouteTableToTarget.update(RouteTableToTarget1)
    return RouteTableToTarget,routeTableSubnetMap,subnetToNat

        
  else:   
    return RouteTableToTarget,routeTableSubnetMap,subnetToNat
              


def checkSubnet(events,context):

  client=boto3.client('ec2')

        subnetIds=events['subnet']
  secgrps=events['secgrps'] 
  vpcId=events['vpcId']

        response = client.describe_route_tables(Filters=[{'Name': 'association.subnet-id','Values':
       subnetIds}])
  RouteTableToTarget,routeTableSubnetMap,subnetToNat=checkPath(response,events['destinationIp'],subnetIds,vpcId)

      
  natList=[]
  natMap={}

  for k,v in RouteTableToTarget.items():
  
        if 'NatGatewayId' in v['Route'] and v['Route']['State'] == 'active':
  
          subnetId = client.describe_nat_gateways(NatGatewayIds=[v['Route']['NatGatewayId']])['NatGateways'][0]['SubnetId']

            natList.append(subnetId)
      natMap[v['Route']['NatGatewayId']]=subnetId

            response = client.describe_route_tables(Filters=[{'Name': 'association.subnet-id','Values':
       [subnetId]}])
      result=checkPath(response,events['destinationIp'],[subnetId],vpcId)[0]

      
      for k1,v1 in result.items():
        if v1['Route'] == {}:
      
          v['Analysis']="NAT Gateway does not have any route for the destination
       IP"
        elif 'GatewayId' in v1['Route']:
          v['Analysis']="
      This Route Table has an active NAT gateway path. Also, The NAT gateway is launched
       in public subnet"
        else:
          v['Analysis']="This Route Table
       has an active NAT gateway path. However, The NAT gateway is not launched in
       public subnet. The NAT Subnet does not have any internet gateway routing path
       for your destination ip"

  result={'subnet':{},'LambdaSubnetIpToNatSubnet':{}}

      
  for subnet,routeTable in routeTableSubnetMap.items():
    result['subnet'][subnet]=RouteTableToTarget[routeTable]

          result['subnet'][subnet]['RouteTable']=routeTable

  LambdaSubnetIpToNatSubnet={}

        for subnet, nat in subnetToNat.items():
    lambdaIp=getLambdaEni(subnet,secgrps)

          if nat in natMap:
      LambdaSubnetIpToNatSubnet[lambdaIp]=natMap[nat]

          else:
      pass  

  result['LambdaSubnetIpToNatSubnet']=LambdaSubnetIpToNatSubnet

        result['NAT_Gateway_subnets']=list(set(natList))

  return result
"
    InputPayload:
      vpcId: "{{checkVpc.vpc}}"
      subnet: "{{checkVpc.subnet}}"
      destinationIp: "{{destinationIp}}"
      secgrps: "{{checkVpc.securityGroups}}"
  outputs:
  - Name: "subnets"
    Selector: "$.Payload.subnet"
    Type: "StringMap"
  - Name: "Natsubnets"
    Selector: "$.Payload.NAT_Gateway_subnets"
    Type: "StringList"
  - Name: "LambdaSubnetIpToNatSubnet"
    Selector: "$.Payload.LambdaSubnetIpToNatSubnet"
    Type: "StringMap"
- name: "checkSecurityGroups"
  action: "aws:executeScript"
  inputs:
    Runtime: "python3.8"
    Handler: "checkSecurityGroups"
    Script: "import boto3
from ipaddress import ip_network,ip_address

def checkSecurityGroups(events,context):

      
  destinationIp=ip_address(events['destinationIp'])
  allowedPorts=int(events['destinationPort'])

        
  client=boto3.client('ec2')
  response = client.describe_security_groups(GroupIds=events['secgrps'])

      
  result={}
  
  for securityGroup in response['SecurityGroups']:
    result[securityGroup['GroupId']]=''

          for rule in securityGroup['IpPermissionsEgress']:
      if rule['IpProtocol']
       == '-1' or (rule['FromPort'] == allowedPorts and rule['ToPort'] == allowedPorts)
       or (allowedPorts in range(rule['FromPort'],rule['ToPort']+1)):
        for
       cidr in rule['IpRanges']:
          if destinationIp in ip_network(cidr['CidrIp']):

                  result[securityGroup['GroupId']] = {"Status":"Allowed"}
 
                 result[securityGroup['GroupId']]['Analysis']="This security group
       has allowed destintion IP and port in its outbuond rule."
            break

          ift'Status' not in result[securityGroup['GroupId']]:
        result[securityGroup['GroupId']]
       = {"Status":"notAllowed"}
        result[securityGroup['GroupId']]['Analysis']="
      This security group does not have an outbound rule for your destination IP or
       destination port. Please allow them in the outbound rule."

  return result
"
    InputPayload:
      destinationIp: "{{destinationIp}}"
      destinationPort: "{{destinationPort}}"
      secgrps: "{{checkVpc.securityGroups}}"
  outputs:
  - Name: "secgrps"
    Selector: "$.Payload"
    Type: "StringMap"
- name: "checkNACL"
  action: "aws:executeScript"
  inputs:
    Runtime: "python3.8"
    Handler: "checkNACL"
    Script: "import boto3
from ipaddress import ip_network,ip_address

def echeck(entries,destinationIp,allowedPorts,ipcheck):

        for entry in entries:
    if 'CidrBlock' in entry:
      if  destinationIp
       in ip_network(entry['CidrBlock']):
        if ipcheck == "destinationIp"
      :
          if entry['Egress'] == True and (entry['Protocol'] == '-1' or ((allowedPorts
       in range(entry['PortRange']['From'],entry['PortRange']['To']+1)) if 'PortRange'
       in entry else False)):
            if entry['RuleAction'] == 'deny':
  
                  return 'notAllowed'
            if entry['RuleAction'] == 'allow':

                    return 'Allowed'
        else:
          if entry['Egress']
       == True and (entry['Protocol'] == '-1' or ( (set(range(1024,65535)).issubset(range(entry['PortRange']['From'],entry['PortRange']['To']
       +1))) if 'PortRange' in entry else False)):
            if entry['RuleAction']
       == 'deny':
              return 'notAllowed'
            if entry['RuleAction']
       == 'allow':
              return 'Allowed'

def icheck(entries,destinationIp,allowedPorts,ipcheck):

        for entry in entries:
    if 'CidrBlock' in entry:
      if  destinationIp
       in ip_network(entry['CidrBlock']):
        if ipcheck == "destinationIp"
      :
          if entry['Egress'] == False and (entry['Protocol'] == '-1' or (
       (set(range(1024,65535)).issubset(range(entry['PortRange']['From'],entry['PortRange']['To']
       +1))) if 'PortRange' in entry else False)):
            if entry['RuleAction']
       == 'deny':
              return 'notAllowed'
            if entry['RuleAction']
       == 'allow':
              return 'Allowed'
        else:
          if entry['Egress']
       == False and (entry['Protocol'] == '-1' or ((allowedPorts in range(entry['PortRange']['From'],entry['PortRange']['To']+1))
       if 'PortRange' in entry else False)):
            if entry['RuleAction']
       == 'deny':
              return 'notAllowed'
            if entry['RuleAction']
       == 'allow':
              return 'Allowed'

def checkNACL(events,context):

        print("printing all the events")
  print(events)
  natsubList=events['natSubnets']

        destinationIp=ip_address(events['destinationIp'])
  allowedPorts=int(events['destinationPort'])

        LambdaIptoNatSubnet=events['LambdaSubnetIpToNatSubnet']
  natSubnets=events['natSubnets']

        TotalSubs=events['lambdaSubnets']
  TotalSubs.extend(natsubList)
  print(TotalSubs)

        subnetNacl={}

  client=boto3.client('ec2')    
  response = client.describe_network_acls(Filters=[{'Name':
       'association.subnet-id','Values': TotalSubs}])
  print(response)
  for NetworkAcl
       in response['NetworkAcls']:
    subnetFlag={}
    for association in NetworkAcl['Associations']:

            if association['SubnetId'] in TotalSubs and association['SubnetId'] not
       in natsubList:
        subnetFlag[association['SubnetId']]='LambdaSubnet'

              subnetNacl[association['SubnetId']]t= {}
        subnetNacl[association['SubnetId']]['NACL']
       = association['NetworkAclId']
      if association['SubnetId'] in TotalSubs
       and association['SubnetId'] in natsubList:
        subnetFlag[association['SubnetId']]='NatSubnet'

              subnetNacl[association['SubnetId']]t= {}
        subnetNacl[association['SubnetId']]['NACL']
       = association['NetworkAclId']

      

    tempE='notAllowed'
    tempI='notAllowed'

      
    tempE=echeck(NetworkAcl['Entries'],destinationIp,allowedPorts,"destinationIp"
      )
    tempI=icheck(NetworkAcl['Entries'],destinationIp,allowedPorts,"destinationIp"
      )

    if tempE == tempI == 'notAllowed':  
      Analysis="There is no
       ingress or egress rule allowed in your NACL for your desired destination and
       ports. Please allow them in NACL egress and ingress rules"
    elif tempE
       == "notAllowed" and tempI == "Allowed":
      Analysis="This NACL has
       an allow rule for Ingress traffic but there is no Egress rule. Please allow
       the destination IP / destionation port in Egress rule"
    elif tempE ==
       "Allowed" and tempI == "notAllowed":
      Analysis="This NACL has an
       allow rule for Egress traffic but there is no Ingress rule. Please allow the
       destination IP / destionation port in Ingress rule"    
    else:
    
        Analysis="This NACL has both Egress and Ingress rule allowing your desired
       destination IP / destionation port"

    
    for k,v in subnetFlag.items():

            subnetNacl[k]['destinationIp_Egress'] = tempE
      subnetNacl[k]['destinationIp_Ingress']
       = tempI
      subnetNacl[k]['Analysis'] = Analysis

      if v == 'NatSubnet':

              subnetNacl[k]['LambdaIpRules']={}
        for k1,v1 in LambdaIptoNatSubnet.items():

                if v1 == k:
            tempE=echeck(NetworkAcl['Entries'],ip_address(k1),allowedPorts,"
      LambdaIpCheck")
            tempI=icheck(NetworkAcl['Entries'],ip_address(k1),allowedPorts,"
      LambdaIpCheck")

          if tempE == tempI == 'notAllowed':
         
         analysis="This is a NAT subnet NACL. It does not have ingress or egress
       rule allowed in it for Lambda's corresponding private ip " +str(k1) +" Please
       allow this IP in your egress and ingress NACL rules"

          elif tempE
       == "notAllowed" and tempI == "Allowed":
            analysis="This is
       a NAT subnet NACL. It does not have egress rule allowed in it for Lambda's
       corresponding private ip " +str(k1) +" Please allow this IP in your egress
       NACL rules"
          elif tempE == "Allowed" and tempI == "notAllowed"
      :
            analysis="This is a NAT subnet NACL. It does not have ingress
       rule allowed in it for Lambda's corresponding private ip " +str(k1) +" Please
       allow this IP in your ingress NACL rules"
          else:
            analysis="
      This NACL has both Egress and Ingress rule allowing the Lambda's corresponding
       private ip " +str(k1)


          subnetNacl[k]['LambdaIpRules'][k1]={}

                subnetNacl[k]['LambdaIpRules'][k1]['Egress']=tempE
          subnetNacl[k]['LambdaIpRules'][k1]['Ingress']=tempI

                subnetNacl[k]['LambdaIpRules'][k1]['Analysis']=analysis

  return
       subnetNacl
"
    InputPayload:
      destinationIp: "{{destinationIp}}"
      destinationPort: "{{destinationPort}}"
      natSubnets: "{{checkSubnet.Natsubnets}}"
      lambdaSubnets: "{{checkVpc.subnet}}"
      LambdaSubnetIpToNatSubnet: "{{checkSubnet.LambdaSubnetIpToNatSubnet}}"
  outputs:
  - Name: "NACL"
    Selector: "$.Payload"
    Type: "StringMap"
