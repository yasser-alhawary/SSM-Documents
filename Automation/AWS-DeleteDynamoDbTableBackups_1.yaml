description: "Deletes DynamoDB table backups based on retention days 'OR' count."
schemaVersion: "0.3"
assumeRole: "{{ AutomationAssumeRole }}"
parameters:
  TableName:
    type: "String"
    description: "(Required) Name of the DynamoDB Table."
  RetentionCount:
    type: "String"
    description: "(Optional) The number of backups to retain for the table. If more
       than the specified number of backup exist, the oldest backups beyond that
       number are deleted. Either RetentionCount or RetentionDays can  be used, not
       both."
    default: "10"
  RetentionDays:
    type: "String"
    description: "(Optional) The number of days to retain backups for the table. Backups
       older than the specified number of days are deleted. Either RetentionCount
       or RetentionDays can  be used, not both."
    default: ""
  LambdaAssumeRole:
    type: "String"
    description: "(Optional) The ARN of the role that allows Lambda created by Automation
       to perform the actions on your behalf. If not specified a transient role will
       be created to execute the Lambda function."
    default: ""
  AutomationAssumeRole:
    type: "String"
    description: "(Optional) The ARN of the role that allows Automation to perform
       the actions on your behalf. "
    default: ""
mainSteps:
- name: "createDocumentStack"
  action: "aws:createStack"
  inputs:
    Capabilities:
    - "CAPABILITY_IAM"
    StackName: "DeleteDynamoDbTableBackupsLambaStack{{automation:EXECUTION_ID}}"
    Parameters:
    - ParameterKey: "LambdaRoleArn"
      ParameterValue: "{{LambdaAssumeRole}}"
    - ParameterKey: "LambdaName"
      ParameterValue: "DeleteTableBackupsLambda-{{automation:EXECUTION_ID}}"
    - ParameterKey: "TableName"
      ParameterValue: "{{TableName}}"
    TemplateBody: "AWSTemplateFormatVersion: '2010-09-09'
Conditions:
  LambdaAssumeRoleNotSpecified:

          Fn::Or:
    - Fn::Equals:
      - {Ref: LambdaRoleArn}
      - ''

          - Fn::Equals:
      - {Ref: LambdaRoleArn}
      - undefined
Parameters:

        LambdaName: {Description: 'The lambda function name

      ', Type: String}

        LambdaRoleArn: {Default: '', Description: 'The ARN of the role that allows
       Lambda
      created by Automation to perform the action on your behalf

      
      ', Type: String}
  TableName: {Description: 'The name of the DynamoDB
       Table for which backups are deleted

      ', Type: String}
Resources:

        DeleteDynamoDbTableBackups:
    Properties:
      Code: {ZipFile: "#
      n# Copyright 2018 Amazon.com, Inc. or its affiliates. All
           Rights
       Reserved.
#
# Permission is hereby granted, free of charge, to
   
              any person obtaining a copy of this
# software and associated documentation
      
           files (the "Software"), to deal in the Software
# without
       restriction,
           including without limitation the rights to use,
       copy, modify,
# merge,
           publish, distribute, sublicense,
       and/or sell copies of the Software, and
           to
# permit persons
       to whom the Software is furnished to do so.
#

          # THE SOFTWARE
       IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
     
            OR IMPLIED,
# INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
      
           FITNESS FOR A
# PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
       NO EVENT SHALL
           THE AUTHORS OR COPYRIGHT
# HOLDERS BE LIABLE
       FOR ANY CLAIM, DAMAGES OR
           OTHER LIABILITY, WHETHER IN AN ACTION
      n# OF CONTRACT, TORT OR OTHERWISE,
           ARISING FROM, OUT OF OR IN
       CONNECTION WITH THE
# SOFTWARE OR THE USE
           OR OTHER DEALINGS
       IN THE SOFTWARE.
#
import boto3
from datetime import
          
       datetime, timedelta, tzinfo

ZERO = timedelta(0)


class UTC(tzinfo):
      n
          
tdef utcoffset(self, dt):
ttreturn ZERO

tdef
       tzname(self, dt):

          ttreturn "UTC"

tdef dst(self,
       dt):
ttreturn ZERO

def handler(event,
           context):
      n
tdef get_table_backups(client, tablename):

ttargs =
     
            {
ttt"TableName" : tablename
tt}

ttwhile
       True:
tttresp
           =  client.list_backups(**args)

      tttfor backup in resp.get("BackupSummaries"
          , []):
      nttttyield backup
tttif "LastEvaluatedBackupArn" in resp:
      n
          ttttargs["ExclusiveStartBackupArn"] = resp["
      LastEvaluatedBackupArn"
          ]
tttelse:
ttttbreak
      n
tclient = boto3.client("dynamodb")

          
ttable_name
       = event["TableName"].strip()
ttry:
ttretention_count
 
                = int(event.get("RetentionCount", "0").strip('"
      ').strip())
texcept:

          ttretention_count = 0

ttry:
      nttretention_days = int(event.get("
          RetentionDays", 
      "0").strip('"').strip())
texcept:
ttretention_days
    
             = 0

tif (retention_count == 0) and (retention_days == 0):
      nttraise
           ValueError("RetentionCount or RetentionDays
       parameter must be specified"
          )

tif (retention_count
       > 0) and (retention_days > 0):
ttraise ValueError("
         
       Only one of RetentionCount or RetentionDays parameters can be specified"
      
          )

tbackups = sorted(get_table_backups(client, table_name),
       key=lambda
           b: b["BackupCreationDateTime"], reverse=True)
      n
tdeleting = []


          tdelete_before = datetime.utcnow().replace(tzinfo=UTC())
       - timedelta(days=int(retention_days))

          
tif retention_days
       > 0:
tti = 0
ttwhile i < len(backups):
tt
          
      tif backups[i]["BackupCreationDateTime"] < delete_before:
ttt
      tdeleting.append(backups.pop(i)["
          BackupArn"])
tt
      telse:
tttti += 1

tif retention_count > 0:

         
       ttif retention_count > 0:
tttdeleting += [b["BackupArn"
      ] for b in
           backups[retention_count:]]

tfor backup_arn
       in deleting:
ttclient.delete_backup(BackupArn=backup_arn)

   
             
treturn {
tt"DeletedBackupsArns": deleting
t}
      n
"}
      FunctionName: {Ref: LambdaName}
      Handler: index.handler

            MemorySize: 128
      Role:
        Fn::If:
        - LambdaAssumeRoleNotSpecified

              - Fn::GetAtt: [LambdaRole, Arn]
        - {Ref: LambdaRoleArn}
 
           Runtime: python3.7
      Timeout: 60
    Type: AWS::Lambda::Function

        LambdaRole:
    Condition: LambdaAssumeRoleNotSpecified
    Properties:

            AssumeRolePolicyDocument:
        Statement:
        - Action: ['sts:AssumeRole']

                Effect: Allow
          Principal:
            Service: [lambda.amazonaws.com]

              Version: '2012-10-17'
      Path: /
      Policies:
      - PolicyDocument:

                Statement:
          - Action: ['dynamodb:ListBackups']
      
            Effect: Allow
            Resource: '*'
          - Action: ['dynamodb:DeleteBackup']

                  Effect: Allow
            Resource:
              Fn::Join:

                    - ''
              - - Fn::Join:
                  - ':'

                        - - arn
                    - {Ref: 'AWS::Partition'}

                          - dynamodb
                    - {Ref: 'AWS::Region'}

                          - {Ref: 'AWS::AccountId'}
                    - table/

                      - {Ref: TableName}
                - /backup/*
         
       Version: '2012-10-17'
        PolicyName: DeleteDynamoDbTableBackupsLambdaPolicy

          Type: AWS::IAM::Role
"
- name: "deleteDynamoDbTableBackups"
  action: "aws:invokeLambdaFunction"
  inputs:
    FunctionName: "DeleteTableBackupsLambda-{{automation:EXECUTION_ID}}"
    Payload: "{"TableName": "{{TableName}}", "RetentionCount": "{{RetentionCount}}"
      , "RetentionDays": "{{RetentionDays}}"}"
- name: "deleteCloudFormationTemplate"
  action: "aws:deleteStack"
  inputs:
    StackName: "DeleteDynamoDbTableBackupsLambaStack{{automation:EXECUTION_ID}}"
outputs:
- "deleteDynamoDbTableBackups.Payload"
